create database cine4
with owner postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bool
is 'boolean, ''true''/''false''';

alter type pg_catalog.bool
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bytea
is 'variable-length string, binary values escaped';

alter type pg_catalog.bytea
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.char
is 'single character';

alter type pg_catalog.char
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.name
is '63-byte type for storing system identifiers';

alter type pg_catalog.name
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int8
is '~18 digit integer, 8-byte storage';

alter type pg_catalog.int8
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int2
is '-32 thousand to 32 thousand, 2-byte storage';

alter type pg_catalog.int2
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int4
is '-2 billion to 2 billion integer, 4-byte storage';

alter type pg_catalog.int4
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regproc
is 'registered procedure';

alter type pg_catalog.regproc
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.text
is 'variable-length string, no limit specified';

alter type pg_catalog.text
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.oid
is 'object identifier(oid), maximum 4 billion';

alter type pg_catalog.oid
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tid
is '(block, offset), physical location of tuple';

alter type pg_catalog.tid
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.xid
is 'transaction id';

alter type pg_catalog.xid
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.cid
is 'command identifier type, sequence in transaction id';

alter type pg_catalog.cid
  owner to postgres;

-- Unknown how to generate base type type

alter type pg_catalog.json
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.xml
is 'XML content';

alter type pg_catalog.xml
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_node_tree
is 'string representing an internal node tree';

alter type pg_catalog.pg_node_tree
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.smgr
is 'storage manager';

alter type pg_catalog.smgr
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.point
is 'geometric point ''(x, y)''';

alter type pg_catalog.point
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.lseg
is 'geometric line segment ''(pt1,pt2)''';

alter type pg_catalog.lseg
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.path
is 'geometric path ''(pt1,...)''';

alter type pg_catalog.path
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.box
is 'geometric box ''(lower left,upper right)''';

alter type pg_catalog.box
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.polygon
is 'geometric polygon ''(pt1,...)''';

alter type pg_catalog.polygon
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.line
is 'geometric line';

alter type pg_catalog.line
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.cidr
is 'network IP address/netmask, network address';

alter type pg_catalog.cidr
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.float4
is 'single-precision floating point number, 4-byte storage';

alter type pg_catalog.float4
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.float8
is 'double-precision floating point number, 8-byte storage';

alter type pg_catalog.float8
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.abstime
is 'absolute, limited-range date and time (Unix system time)';

alter type pg_catalog.abstime
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.reltime
is 'relative, limited-range time interval (Unix delta time)';

alter type pg_catalog.reltime
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tinterval
is '(abstime,abstime), time interval';

alter type pg_catalog.tinterval
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.circle
is 'geometric circle ''(center,radius)''';

alter type pg_catalog.circle
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr8
is 'XX:XX:XX:XX:XX:XX:XX:XX, MAC address';

alter type pg_catalog.macaddr8
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.money
is 'monetary amounts, $d,ddd.cc';

alter type pg_catalog.money
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr
is 'XX:XX:XX:XX:XX:XX, MAC address';

alter type pg_catalog.macaddr
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.inet
is 'IP address/netmask, host address, netmask optional';

alter type pg_catalog.inet
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.aclitem
is 'access control list';

alter type pg_catalog.aclitem
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bpchar
is 'char(length), blank-padded string, fixed storage length';

alter type pg_catalog.bpchar
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.varchar
is 'varchar(length), non-blank-padded string, variable storage length';

alter type pg_catalog.varchar
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.date
is 'date';

alter type pg_catalog.date
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.time
is 'time of day';

alter type pg_catalog.time
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timestamp
is 'date and time';

alter type pg_catalog.timestamp
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timestamptz
is 'date and time with time zone';

alter type pg_catalog.timestamptz
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.interval
is '@ <number> <units>, time interval';

alter type pg_catalog.interval
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timetz
is 'time of day with time zone';

alter type pg_catalog.timetz
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bit
is 'fixed-length bit string';

alter type pg_catalog.bit
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.varbit
is 'variable-length bit string';

alter type pg_catalog.varbit
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.numeric
is 'numeric(precision, decimal), arbitrary precision number';

alter type pg_catalog.numeric
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.refcursor
is 'reference to cursor (portal name)';

alter type pg_catalog.refcursor
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regprocedure
is 'registered procedure (with args)';

alter type pg_catalog.regprocedure
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regoper
is 'registered operator';

alter type pg_catalog.regoper
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regoperator
is 'registered operator (with args)';

alter type pg_catalog.regoperator
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regclass
is 'registered class';

alter type pg_catalog.regclass
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regtype
is 'registered type';

alter type pg_catalog.regtype
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.uuid
is 'UUID datatype';

alter type pg_catalog.uuid
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.txid_snapshot
is 'txid snapshot';

alter type pg_catalog.txid_snapshot
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_lsn
is 'PostgreSQL LSN datatype';

alter type pg_catalog.pg_lsn
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_ndistinct
is 'multivariate ndistinct coefficients';

alter type pg_catalog.pg_ndistinct
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_dependencies
is 'multivariate dependencies';

alter type pg_catalog.pg_dependencies
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tsvector
is 'text representation for text search';

alter type pg_catalog.tsvector
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tsquery
is 'query representation for text search';

alter type pg_catalog.tsquery
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.gtsvector
is 'GiST index internal text representation for text search';

alter type pg_catalog.gtsvector
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regconfig
is 'registered text search configuration';

alter type pg_catalog.regconfig
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regdictionary
is 'registered text search dictionary';

alter type pg_catalog.regdictionary
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.jsonb
is 'Binary JSON';

alter type pg_catalog.jsonb
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regnamespace
is 'registered namespace';

alter type pg_catalog.regnamespace
  owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regrole
is 'registered role';

alter type pg_catalog.regrole
  owner to postgres;

create domain information_schema.cardinal_number as integer
  constraint cardinal_number_domain_check check (VALUE >= 0);

alter domain information_schema.cardinal_number
  owner to postgres;

create domain information_schema.character_data as varchar;

alter domain information_schema.character_data
  owner to postgres;

create domain information_schema.sql_identifier as varchar;

alter domain information_schema.sql_identifier
  owner to postgres;

create domain information_schema.time_stamp as timestamp(2) with time zone
  default CURRENT_TIMESTAMP(2);

alter domain information_schema.time_stamp
  owner to postgres;

create domain information_schema.yes_or_no as varchar(3)
  constraint yes_or_no_check check ((VALUE) :: text = ANY
                                    ((ARRAY ['YES' :: character varying, 'NO' :: character varying]) :: text []));

alter domain information_schema.yes_or_no
  owner to postgres;

create table pg_catalog.pg_default_acl
(
  defaclrole      oid    not null,
  defaclnamespace oid    not null,
  defaclobjtype   "char" not null,
  defaclacl       aclitem []
);

alter table pg_catalog.pg_default_acl
  owner to postgres;

create unique index pg_default_acl_role_nsp_obj_index
  on pg_catalog.pg_default_acl (defaclrole, defaclnamespace, defaclobjtype);

create unique index pg_default_acl_oid_index
  on pg_catalog.pg_default_acl (oid);

create table pg_catalog.pg_pltemplate
(
  tmplname      name    not null,
  tmpltrusted   boolean not null,
  tmpldbacreate boolean not null,
  tmplhandler   text    not null,
  tmplinline    text,
  tmplvalidator text,
  tmpllibrary   text    not null,
  tmplacl       aclitem []
);

alter table pg_catalog.pg_pltemplate
  owner to postgres;

create unique index pg_pltemplate_name_index
  on pg_catalog.pg_pltemplate (tmplname);

create table pg_catalog.pg_tablespace
(
  spcname    name not null,
  spcowner   oid  not null,
  spcacl     aclitem [],
  spcoptions text []
);

alter table pg_catalog.pg_tablespace
  owner to postgres;

create unique index pg_tablespace_oid_index
  on pg_catalog.pg_tablespace (oid);

create unique index pg_tablespace_spcname_index
  on pg_catalog.pg_tablespace (spcname);

create table pg_catalog.pg_shdepend
(
  dbid       oid     not null,
  classid    oid     not null,
  objid      oid     not null,
  objsubid   integer not null,
  refclassid oid     not null,
  refobjid   oid     not null,
  deptype    "char"  not null
);

alter table pg_catalog.pg_shdepend
  owner to postgres;

create index pg_shdepend_depender_index
  on pg_catalog.pg_shdepend (dbid, classid, objid, objsubid);

create index pg_shdepend_reference_index
  on pg_catalog.pg_shdepend (refclassid, refobjid);

create table pg_catalog.pg_type
(
  typname        name     not null,
  typnamespace   oid      not null,
  typowner       oid      not null,
  typlen         smallint not null,
  typbyval       boolean  not null,
  typtype        "char"   not null,
  typcategory    "char"   not null,
  typispreferred boolean  not null,
  typisdefined   boolean  not null,
  typdelim       "char"   not null,
  typrelid       oid      not null,
  typelem        oid      not null,
  typarray       oid      not null,
  typinput       regproc  not null,
  typoutput      regproc  not null,
  typreceive     regproc  not null,
  typsend        regproc  not null,
  typmodin       regproc  not null,
  typmodout      regproc  not null,
  typanalyze     regproc  not null,
  typalign       "char"   not null,
  typstorage     "char"   not null,
  typnotnull     boolean  not null,
  typbasetype    oid      not null,
  typtypmod      integer  not null,
  typndims       integer  not null,
  typcollation   oid      not null,
  typdefaultbin  pg_node_tree,
  typdefault     text,
  typacl         aclitem []
);

alter table pg_catalog.pg_type
  owner to postgres;

create unique index pg_type_oid_index
  on pg_catalog.pg_type (oid);

create unique index pg_type_typname_nsp_index
  on pg_catalog.pg_type (typname, typnamespace);

create table pg_catalog.pg_attribute
(
  attrelid      oid      not null,
  attname       name     not null,
  atttypid      oid      not null,
  attstattarget integer  not null,
  attlen        smallint not null,
  attnum        smallint not null,
  attndims      integer  not null,
  attcacheoff   integer  not null,
  atttypmod     integer  not null,
  attbyval      boolean  not null,
  attstorage    "char"   not null,
  attalign      "char"   not null,
  attnotnull    boolean  not null,
  atthasdef     boolean  not null,
  attidentity   "char"   not null,
  attisdropped  boolean  not null,
  attislocal    boolean  not null,
  attinhcount   integer  not null,
  attcollation  oid      not null,
  attacl        aclitem [],
  attoptions    text [],
  attfdwoptions text []
);

alter table pg_catalog.pg_attribute
  owner to postgres;

create unique index pg_attribute_relid_attnam_index
  on pg_catalog.pg_attribute (attrelid, attname);

create unique index pg_attribute_relid_attnum_index
  on pg_catalog.pg_attribute (attrelid, attnum);

create table pg_catalog.pg_proc
(
  proname         name      not null,
  pronamespace    oid       not null,
  proowner        oid       not null,
  prolang         oid       not null,
  procost         real      not null,
  prorows         real      not null,
  provariadic     oid       not null,
  protransform    regproc   not null,
  proisagg        boolean   not null,
  proiswindow     boolean   not null,
  prosecdef       boolean   not null,
  proleakproof    boolean   not null,
  proisstrict     boolean   not null,
  proretset       boolean   not null,
  provolatile     "char"    not null,
  proparallel     "char"    not null,
  pronargs        smallint  not null,
  pronargdefaults smallint  not null,
  prorettype      oid       not null,
  proargtypes     oidvector not null,
  proallargtypes  oid [],
  proargmodes     "char" [],
  proargnames     text [],
  proargdefaults  pg_node_tree,
  protrftypes     oid [],
  prosrc          text      not null,
  probin          text,
  proconfig       text [],
  proacl          aclitem []
);

alter table pg_catalog.pg_proc
  owner to postgres;

create unique index pg_proc_oid_index
  on pg_catalog.pg_proc (oid);

create unique index pg_proc_proname_args_nsp_index
  on pg_catalog.pg_proc (proname, proargtypes, pronamespace);

create table pg_catalog.pg_class
(
  relname             name     not null,
  relnamespace        oid      not null,
  reltype             oid      not null,
  reloftype           oid      not null,
  relowner            oid      not null,
  relam               oid      not null,
  relfilenode         oid      not null,
  reltablespace       oid      not null,
  relpages            integer  not null,
  reltuples           real     not null,
  relallvisible       integer  not null,
  reltoastrelid       oid      not null,
  relhasindex         boolean  not null,
  relisshared         boolean  not null,
  relpersistence      "char"   not null,
  relkind             "char"   not null,
  relnatts            smallint not null,
  relchecks           smallint not null,
  relhasoids          boolean  not null,
  relhaspkey          boolean  not null,
  relhasrules         boolean  not null,
  relhastriggers      boolean  not null,
  relhassubclass      boolean  not null,
  relrowsecurity      boolean  not null,
  relforcerowsecurity boolean  not null,
  relispopulated      boolean  not null,
  relreplident        "char"   not null,
  relispartition      boolean  not null,
  relfrozenxid        xid      not null,
  relminmxid          xid      not null,
  relacl              aclitem [],
  reloptions          text [],
  relpartbound        pg_node_tree
);

alter table pg_catalog.pg_class
  owner to postgres;

create unique index pg_class_oid_index
  on pg_catalog.pg_class (oid);

create unique index pg_class_relname_nsp_index
  on pg_catalog.pg_class (relname, relnamespace);

create index pg_class_tblspc_relfilenode_index
  on pg_catalog.pg_class (reltablespace, relfilenode);

create table pg_catalog.pg_authid
(
  rolname        name    not null,
  rolsuper       boolean not null,
  rolinherit     boolean not null,
  rolcreaterole  boolean not null,
  rolcreatedb    boolean not null,
  rolcanlogin    boolean not null,
  rolreplication boolean not null,
  rolbypassrls   boolean not null,
  rolconnlimit   integer not null,
  rolpassword    text,
  rolvaliduntil  timestamp with time zone
);

alter table pg_catalog.pg_authid
  owner to postgres;

create unique index pg_authid_rolname_index
  on pg_catalog.pg_authid (rolname);

create unique index pg_authid_oid_index
  on pg_catalog.pg_authid (oid);

create table pg_catalog.pg_auth_members
(
  roleid       oid     not null,
  member       oid     not null,
  grantor      oid     not null,
  admin_option boolean not null
);

alter table pg_catalog.pg_auth_members
  owner to postgres;

create unique index pg_auth_members_role_member_index
  on pg_catalog.pg_auth_members (roleid, member);

create unique index pg_auth_members_member_role_index
  on pg_catalog.pg_auth_members (member, roleid);

create table pg_catalog.pg_database
(
  datname       name    not null,
  datdba        oid     not null,
  encoding      integer not null,
  datcollate    name    not null,
  datctype      name    not null,
  datistemplate boolean not null,
  datallowconn  boolean not null,
  datconnlimit  integer not null,
  datlastsysoid oid     not null,
  datfrozenxid  xid     not null,
  datminmxid    xid     not null,
  dattablespace oid     not null,
  datacl        aclitem []
);

alter table pg_catalog.pg_database
  owner to postgres;

create unique index pg_database_datname_index
  on pg_catalog.pg_database (datname);

create unique index pg_database_oid_index
  on pg_catalog.pg_database (oid);

create table pg_catalog.pg_foreign_server
(
  srvname    name not null,
  srvowner   oid  not null,
  srvfdw     oid  not null,
  srvtype    text,
  srvversion text,
  srvacl     aclitem [],
  srvoptions text []
);

alter table pg_catalog.pg_foreign_server
  owner to postgres;

create unique index pg_foreign_server_oid_index
  on pg_catalog.pg_foreign_server (oid);

create unique index pg_foreign_server_name_index
  on pg_catalog.pg_foreign_server (srvname);

create table pg_catalog.pg_user_mapping
(
  umuser    oid not null,
  umserver  oid not null,
  umoptions text []
);

alter table pg_catalog.pg_user_mapping
  owner to postgres;

create unique index pg_user_mapping_oid_index
  on pg_catalog.pg_user_mapping (oid);

create unique index pg_user_mapping_user_server_index
  on pg_catalog.pg_user_mapping (umuser, umserver);

create table pg_catalog.pg_sequence
(
  seqrelid     oid     not null,
  seqtypid     oid     not null,
  seqstart     bigint  not null,
  seqincrement bigint  not null,
  seqmax       bigint  not null,
  seqmin       bigint  not null,
  seqcache     bigint  not null,
  seqcycle     boolean not null
);

alter table pg_catalog.pg_sequence
  owner to postgres;

create unique index pg_sequence_seqrelid_index
  on pg_catalog.pg_sequence (seqrelid);

create table pg_catalog.pg_foreign_data_wrapper
(
  fdwname      name not null,
  fdwowner     oid  not null,
  fdwhandler   oid  not null,
  fdwvalidator oid  not null,
  fdwacl       aclitem [],
  fdwoptions   text []
);

alter table pg_catalog.pg_foreign_data_wrapper
  owner to postgres;

create unique index pg_foreign_data_wrapper_oid_index
  on pg_catalog.pg_foreign_data_wrapper (oid);

create unique index pg_foreign_data_wrapper_name_index
  on pg_catalog.pg_foreign_data_wrapper (fdwname);

create table pg_catalog.pg_shdescription
(
  objoid      oid  not null,
  classoid    oid  not null,
  description text not null
);

alter table pg_catalog.pg_shdescription
  owner to postgres;

create unique index pg_shdescription_o_c_index
  on pg_catalog.pg_shdescription (objoid, classoid);

create table pg_catalog.pg_aggregate
(
  aggfnoid         regproc  not null,
  aggkind          "char"   not null,
  aggnumdirectargs smallint not null,
  aggtransfn       regproc  not null,
  aggfinalfn       regproc  not null,
  aggcombinefn     regproc  not null,
  aggserialfn      regproc  not null,
  aggdeserialfn    regproc  not null,
  aggmtransfn      regproc  not null,
  aggminvtransfn   regproc  not null,
  aggmfinalfn      regproc  not null,
  aggfinalextra    boolean  not null,
  aggmfinalextra   boolean  not null,
  aggsortop        oid      not null,
  aggtranstype     oid      not null,
  aggtransspace    integer  not null,
  aggmtranstype    oid      not null,
  aggmtransspace   integer  not null,
  agginitval       text,
  aggminitval      text
);

alter table pg_catalog.pg_aggregate
  owner to postgres;

create unique index pg_aggregate_fnoid_index
  on pg_catalog.pg_aggregate (aggfnoid);

create table pg_catalog.pg_am
(
  amname    name    not null,
  amhandler regproc not null,
  amtype    "char"  not null
);

alter table pg_catalog.pg_am
  owner to postgres;

create unique index pg_am_name_index
  on pg_catalog.pg_am (amname);

create unique index pg_am_oid_index
  on pg_catalog.pg_am (oid);

create table pg_catalog.pg_amop
(
  amopfamily     oid      not null,
  amoplefttype   oid      not null,
  amoprighttype  oid      not null,
  amopstrategy   smallint not null,
  amoppurpose    "char"   not null,
  amopopr        oid      not null,
  amopmethod     oid      not null,
  amopsortfamily oid      not null
);

alter table pg_catalog.pg_amop
  owner to postgres;

create unique index pg_amop_fam_strat_index
  on pg_catalog.pg_amop (amopfamily, amoplefttype, amoprighttype, amopstrategy);

create unique index pg_amop_opr_fam_index
  on pg_catalog.pg_amop (amopopr, amoppurpose, amopfamily);

create unique index pg_amop_oid_index
  on pg_catalog.pg_amop (oid);

create table pg_catalog.pg_amproc
(
  amprocfamily    oid      not null,
  amproclefttype  oid      not null,
  amprocrighttype oid      not null,
  amprocnum       smallint not null,
  amproc          regproc  not null
);

alter table pg_catalog.pg_amproc
  owner to postgres;

create unique index pg_amproc_fam_proc_index
  on pg_catalog.pg_amproc (amprocfamily, amproclefttype, amprocrighttype, amprocnum);

create unique index pg_amproc_oid_index
  on pg_catalog.pg_amproc (oid);

create table pg_catalog.pg_attrdef
(
  adrelid oid      not null,
  adnum   smallint not null,
  adbin   pg_node_tree,
  adsrc   text
);

alter table pg_catalog.pg_attrdef
  owner to postgres;

create unique index pg_attrdef_adrelid_adnum_index
  on pg_catalog.pg_attrdef (adrelid, adnum);

create unique index pg_attrdef_oid_index
  on pg_catalog.pg_attrdef (oid);

create table pg_catalog.pg_cast
(
  castsource  oid    not null,
  casttarget  oid    not null,
  castfunc    oid    not null,
  castcontext "char" not null,
  castmethod  "char" not null
);

alter table pg_catalog.pg_cast
  owner to postgres;

create unique index pg_cast_oid_index
  on pg_catalog.pg_cast (oid);

create unique index pg_cast_source_target_index
  on pg_catalog.pg_cast (castsource, casttarget);

create table pg_catalog.pg_constraint
(
  conname       name    not null,
  connamespace  oid     not null,
  contype       "char"  not null,
  condeferrable boolean not null,
  condeferred   boolean not null,
  convalidated  boolean not null,
  conrelid      oid     not null,
  contypid      oid     not null,
  conindid      oid     not null,
  confrelid     oid     not null,
  confupdtype   "char"  not null,
  confdeltype   "char"  not null,
  confmatchtype "char"  not null,
  conislocal    boolean not null,
  coninhcount   integer not null,
  connoinherit  boolean not null,
  conkey        smallint [],
  confkey       smallint [],
  conpfeqop     oid [],
  conppeqop     oid [],
  conffeqop     oid [],
  conexclop     oid [],
  conbin        pg_node_tree,
  consrc        text
);

alter table pg_catalog.pg_constraint
  owner to postgres;

create index pg_constraint_conname_nsp_index
  on pg_catalog.pg_constraint (conname, connamespace);

create index pg_constraint_conrelid_index
  on pg_catalog.pg_constraint (conrelid);

create index pg_constraint_contypid_index
  on pg_catalog.pg_constraint (contypid);

create unique index pg_constraint_oid_index
  on pg_catalog.pg_constraint (oid);

create table pg_catalog.pg_conversion
(
  conname        name    not null,
  connamespace   oid     not null,
  conowner       oid     not null,
  conforencoding integer not null,
  contoencoding  integer not null,
  conproc        regproc not null,
  condefault     boolean not null
);

alter table pg_catalog.pg_conversion
  owner to postgres;

create unique index pg_conversion_default_index
  on pg_catalog.pg_conversion (connamespace, conforencoding, contoencoding, oid);

create unique index pg_conversion_name_nsp_index
  on pg_catalog.pg_conversion (conname, connamespace);

create unique index pg_conversion_oid_index
  on pg_catalog.pg_conversion (oid);

create table pg_catalog.pg_depend
(
  classid     oid     not null,
  objid       oid     not null,
  objsubid    integer not null,
  refclassid  oid     not null,
  refobjid    oid     not null,
  refobjsubid integer not null,
  deptype     "char"  not null
);

alter table pg_catalog.pg_depend
  owner to postgres;

create index pg_depend_depender_index
  on pg_catalog.pg_depend (classid, objid, objsubid);

create index pg_depend_reference_index
  on pg_catalog.pg_depend (refclassid, refobjid, refobjsubid);

create table pg_catalog.pg_description
(
  objoid      oid     not null,
  classoid    oid     not null,
  objsubid    integer not null,
  description text    not null
);

alter table pg_catalog.pg_description
  owner to postgres;

create unique index pg_description_o_c_o_index
  on pg_catalog.pg_description (objoid, classoid, objsubid);

create table pg_catalog.pg_index
(
  indexrelid     oid        not null,
  indrelid       oid        not null,
  indnatts       smallint   not null,
  indisunique    boolean    not null,
  indisprimary   boolean    not null,
  indisexclusion boolean    not null,
  indimmediate   boolean    not null,
  indisclustered boolean    not null,
  indisvalid     boolean    not null,
  indcheckxmin   boolean    not null,
  indisready     boolean    not null,
  indislive      boolean    not null,
  indisreplident boolean    not null,
  indkey         int2vector not null,
  indcollation   oidvector  not null,
  indclass       oidvector  not null,
  indoption      int2vector not null,
  indexprs       pg_node_tree,
  indpred        pg_node_tree
);

alter table pg_catalog.pg_index
  owner to postgres;

create index pg_index_indrelid_index
  on pg_catalog.pg_index (indrelid);

create unique index pg_index_indexrelid_index
  on pg_catalog.pg_index (indexrelid);

create table pg_catalog.pg_inherits
(
  inhrelid  oid     not null,
  inhparent oid     not null,
  inhseqno  integer not null
);

alter table pg_catalog.pg_inherits
  owner to postgres;

create index pg_inherits_parent_index
  on pg_catalog.pg_inherits (inhparent);

create unique index pg_inherits_relid_seqno_index
  on pg_catalog.pg_inherits (inhrelid, inhseqno);

create table pg_catalog.pg_language
(
  lanname       name    not null,
  lanowner      oid     not null,
  lanispl       boolean not null,
  lanpltrusted  boolean not null,
  lanplcallfoid oid     not null,
  laninline     oid     not null,
  lanvalidator  oid     not null,
  lanacl        aclitem []
);

alter table pg_catalog.pg_language
  owner to postgres;

create unique index pg_language_name_index
  on pg_catalog.pg_language (lanname);

create unique index pg_language_oid_index
  on pg_catalog.pg_language (oid);

create table pg_catalog.pg_largeobject
(
  loid   oid     not null,
  pageno integer not null,
  data   bytea   not null
);

alter table pg_catalog.pg_largeobject
  owner to postgres;

create unique index pg_largeobject_loid_pn_index
  on pg_catalog.pg_largeobject (loid, pageno);

create table pg_catalog.pg_namespace
(
  nspname  name not null,
  nspowner oid  not null,
  nspacl   aclitem []
);

alter table pg_catalog.pg_namespace
  owner to postgres;

create unique index pg_namespace_nspname_index
  on pg_catalog.pg_namespace (nspname);

create unique index pg_namespace_oid_index
  on pg_catalog.pg_namespace (oid);

create table pg_catalog.pg_opclass
(
  opcmethod    oid     not null,
  opcname      name    not null,
  opcnamespace oid     not null,
  opcowner     oid     not null,
  opcfamily    oid     not null,
  opcintype    oid     not null,
  opcdefault   boolean not null,
  opckeytype   oid     not null
);

alter table pg_catalog.pg_opclass
  owner to postgres;

create unique index pg_opclass_am_name_nsp_index
  on pg_catalog.pg_opclass (opcmethod, opcname, opcnamespace);

create unique index pg_opclass_oid_index
  on pg_catalog.pg_opclass (oid);

create table pg_catalog.pg_operator
(
  oprname      name    not null,
  oprnamespace oid     not null,
  oprowner     oid     not null,
  oprkind      "char"  not null,
  oprcanmerge  boolean not null,
  oprcanhash   boolean not null,
  oprleft      oid     not null,
  oprright     oid     not null,
  oprresult    oid     not null,
  oprcom       oid     not null,
  oprnegate    oid     not null,
  oprcode      regproc not null,
  oprrest      regproc not null,
  oprjoin      regproc not null
);

alter table pg_catalog.pg_operator
  owner to postgres;

create unique index pg_operator_oid_index
  on pg_catalog.pg_operator (oid);

create unique index pg_operator_oprname_l_r_n_index
  on pg_catalog.pg_operator (oprname, oprleft, oprright, oprnamespace);

create table pg_catalog.pg_rewrite
(
  rulename   name    not null,
  ev_class   oid     not null,
  ev_type    "char"  not null,
  ev_enabled "char"  not null,
  is_instead boolean not null,
  ev_qual    pg_node_tree,
  ev_action  pg_node_tree
);

alter table pg_catalog.pg_rewrite
  owner to postgres;

create unique index pg_rewrite_oid_index
  on pg_catalog.pg_rewrite (oid);

create unique index pg_rewrite_rel_rulename_index
  on pg_catalog.pg_rewrite (ev_class, rulename);

create table pg_catalog.pg_statistic
(
  starelid    oid      not null,
  staattnum   smallint not null,
  stainherit  boolean  not null,
  stanullfrac real     not null,
  stawidth    integer  not null,
  stadistinct real     not null,
  stakind1    smallint not null,
  stakind2    smallint not null,
  stakind3    smallint not null,
  stakind4    smallint not null,
  stakind5    smallint not null,
  staop1      oid      not null,
  staop2      oid      not null,
  staop3      oid      not null,
  staop4      oid      not null,
  staop5      oid      not null,
  stanumbers1 real [],
  stanumbers2 real [],
  stanumbers3 real [],
  stanumbers4 real [],
  stanumbers5 real [],
  stavalues1  anyarray,
  stavalues2  anyarray,
  stavalues3  anyarray,
  stavalues4  anyarray,
  stavalues5  anyarray
);

alter table pg_catalog.pg_statistic
  owner to postgres;

create unique index pg_statistic_relid_att_inh_index
  on pg_catalog.pg_statistic (starelid, staattnum, stainherit);

create table pg_catalog.pg_trigger
(
  tgrelid        oid        not null,
  tgname         name       not null,
  tgfoid         oid        not null,
  tgtype         smallint   not null,
  tgenabled      "char"     not null,
  tgisinternal   boolean    not null,
  tgconstrrelid  oid        not null,
  tgconstrindid  oid        not null,
  tgconstraint   oid        not null,
  tgdeferrable   boolean    not null,
  tginitdeferred boolean    not null,
  tgnargs        smallint   not null,
  tgattr         int2vector not null,
  tgargs         bytea      not null,
  tgqual         pg_node_tree,
  tgoldtable     name,
  tgnewtable     name
);

alter table pg_catalog.pg_trigger
  owner to postgres;

create index pg_trigger_tgconstraint_index
  on pg_catalog.pg_trigger (tgconstraint);

create unique index pg_trigger_tgrelid_tgname_index
  on pg_catalog.pg_trigger (tgrelid, tgname);

create unique index pg_trigger_oid_index
  on pg_catalog.pg_trigger (oid);

create table pg_catalog.pg_opfamily
(
  opfmethod    oid  not null,
  opfname      name not null,
  opfnamespace oid  not null,
  opfowner     oid  not null
);

alter table pg_catalog.pg_opfamily
  owner to postgres;

create unique index pg_opfamily_am_name_nsp_index
  on pg_catalog.pg_opfamily (opfmethod, opfname, opfnamespace);

create unique index pg_opfamily_oid_index
  on pg_catalog.pg_opfamily (oid);

create table pg_catalog.pg_db_role_setting
(
  setdatabase oid not null,
  setrole     oid not null,
  setconfig   text []
);

alter table pg_catalog.pg_db_role_setting
  owner to postgres;

create unique index pg_db_role_setting_databaseid_rol_index
  on pg_catalog.pg_db_role_setting (setdatabase, setrole);

create table pg_catalog.pg_largeobject_metadata
(
  lomowner oid not null,
  lomacl   aclitem []
);

alter table pg_catalog.pg_largeobject_metadata
  owner to postgres;

create unique index pg_largeobject_metadata_oid_index
  on pg_catalog.pg_largeobject_metadata (oid);

create table pg_catalog.pg_extension
(
  extname        name    not null,
  extowner       oid     not null,
  extnamespace   oid     not null,
  extrelocatable boolean not null,
  extversion     text    not null,
  extconfig      oid [],
  extcondition   text []
);

alter table pg_catalog.pg_extension
  owner to postgres;

create unique index pg_extension_oid_index
  on pg_catalog.pg_extension (oid);

create unique index pg_extension_name_index
  on pg_catalog.pg_extension (extname);

create table pg_catalog.pg_foreign_table
(
  ftrelid   oid not null,
  ftserver  oid not null,
  ftoptions text []
);

alter table pg_catalog.pg_foreign_table
  owner to postgres;

create unique index pg_foreign_table_relid_index
  on pg_catalog.pg_foreign_table (ftrelid);

create table pg_catalog.pg_policy
(
  polname       name    not null,
  polrelid      oid     not null,
  polcmd        "char"  not null,
  polpermissive boolean not null,
  polroles      oid [],
  polqual       pg_node_tree,
  polwithcheck  pg_node_tree
);

alter table pg_catalog.pg_policy
  owner to postgres;

create unique index pg_policy_oid_index
  on pg_catalog.pg_policy (oid);

create unique index pg_policy_polrelid_polname_index
  on pg_catalog.pg_policy (polrelid, polname);

create table pg_catalog.pg_partitioned_table
(
  partrelid     oid        not null,
  partstrat     "char"     not null,
  partnatts     smallint   not null,
  partattrs     int2vector not null,
  partclass     oidvector  not null,
  partcollation oidvector  not null,
  partexprs     pg_node_tree
);

alter table pg_catalog.pg_partitioned_table
  owner to postgres;

create unique index pg_partitioned_table_partrelid_index
  on pg_catalog.pg_partitioned_table (partrelid);

create table pg_catalog.pg_statistic_ext
(
  stxrelid        oid        not null,
  stxname         name       not null,
  stxnamespace    oid        not null,
  stxowner        oid        not null,
  stxkeys         int2vector not null,
  stxkind         "char" []  not null,
  stxndistinct    pg_ndistinct,
  stxdependencies pg_dependencies
);

alter table pg_catalog.pg_statistic_ext
  owner to postgres;

create index pg_statistic_ext_relid_index
  on pg_catalog.pg_statistic_ext (stxrelid);

create unique index pg_statistic_ext_oid_index
  on pg_catalog.pg_statistic_ext (oid);

create unique index pg_statistic_ext_name_index
  on pg_catalog.pg_statistic_ext (stxname, stxnamespace);

create table pg_catalog.pg_init_privs
(
  objoid    oid        not null,
  classoid  oid        not null,
  objsubid  integer    not null,
  privtype  "char"     not null,
  initprivs aclitem [] not null
);

alter table pg_catalog.pg_init_privs
  owner to postgres;

create unique index pg_init_privs_o_c_o_index
  on pg_catalog.pg_init_privs (objoid, classoid, objsubid);

create table pg_catalog.pg_collation
(
  collname      name    not null,
  collnamespace oid     not null,
  collowner     oid     not null,
  collprovider  "char"  not null,
  collencoding  integer not null,
  collcollate   name    not null,
  collctype     name    not null,
  collversion   text
);

alter table pg_catalog.pg_collation
  owner to postgres;

create unique index pg_collation_oid_index
  on pg_catalog.pg_collation (oid);

create unique index pg_collation_name_enc_nsp_index
  on pg_catalog.pg_collation (collname, collencoding, collnamespace);

create table pg_catalog.pg_event_trigger
(
  evtname    name   not null,
  evtevent   name   not null,
  evtowner   oid    not null,
  evtfoid    oid    not null,
  evtenabled "char" not null,
  evttags    text []
);

alter table pg_catalog.pg_event_trigger
  owner to postgres;

create unique index pg_event_trigger_evtname_index
  on pg_catalog.pg_event_trigger (evtname);

create unique index pg_event_trigger_oid_index
  on pg_catalog.pg_event_trigger (oid);

create table pg_catalog.pg_enum
(
  enumtypid     oid  not null,
  enumsortorder real not null,
  enumlabel     name not null
);

alter table pg_catalog.pg_enum
  owner to postgres;

create unique index pg_enum_oid_index
  on pg_catalog.pg_enum (oid);

create unique index pg_enum_typid_label_index
  on pg_catalog.pg_enum (enumtypid, enumlabel);

create unique index pg_enum_typid_sortorder_index
  on pg_catalog.pg_enum (enumtypid, enumsortorder);

create table pg_catalog.pg_range
(
  rngtypid     oid     not null,
  rngsubtype   oid     not null,
  rngcollation oid     not null,
  rngsubopc    oid     not null,
  rngcanonical regproc not null,
  rngsubdiff   regproc not null
);

alter table pg_catalog.pg_range
  owner to postgres;

create unique index pg_range_rngtypid_index
  on pg_catalog.pg_range (rngtypid);

create table pg_catalog.pg_transform
(
  trftype    oid     not null,
  trflang    oid     not null,
  trffromsql regproc not null,
  trftosql   regproc not null
);

alter table pg_catalog.pg_transform
  owner to postgres;

create unique index pg_transform_oid_index
  on pg_catalog.pg_transform (oid);

create unique index pg_transform_type_lang_index
  on pg_catalog.pg_transform (trftype, trflang);

create table pg_catalog.pg_shseclabel
(
  objoid   oid  not null,
  classoid oid  not null,
  provider text not null,
  label    text not null
);

alter table pg_catalog.pg_shseclabel
  owner to postgres;

create unique index pg_shseclabel_object_index
  on pg_catalog.pg_shseclabel (objoid, classoid, provider);

create table pg_catalog.pg_seclabel
(
  objoid   oid     not null,
  classoid oid     not null,
  objsubid integer not null,
  provider text    not null,
  label    text    not null
);

alter table pg_catalog.pg_seclabel
  owner to postgres;

create unique index pg_seclabel_object_index
  on pg_catalog.pg_seclabel (objoid, classoid, objsubid, provider);

create table pg_catalog.pg_ts_dict
(
  dictname       name not null,
  dictnamespace  oid  not null,
  dictowner      oid  not null,
  dicttemplate   oid  not null,
  dictinitoption text
);

alter table pg_catalog.pg_ts_dict
  owner to postgres;

create unique index pg_ts_dict_dictname_index
  on pg_catalog.pg_ts_dict (dictname, dictnamespace);

create unique index pg_ts_dict_oid_index
  on pg_catalog.pg_ts_dict (oid);

create table pg_catalog.pg_ts_parser
(
  prsname      name    not null,
  prsnamespace oid     not null,
  prsstart     regproc not null,
  prstoken     regproc not null,
  prsend       regproc not null,
  prsheadline  regproc not null,
  prslextype   regproc not null
);

alter table pg_catalog.pg_ts_parser
  owner to postgres;

create unique index pg_ts_parser_prsname_index
  on pg_catalog.pg_ts_parser (prsname, prsnamespace);

create unique index pg_ts_parser_oid_index
  on pg_catalog.pg_ts_parser (oid);

create table pg_catalog.pg_ts_config
(
  cfgname      name not null,
  cfgnamespace oid  not null,
  cfgowner     oid  not null,
  cfgparser    oid  not null
);

alter table pg_catalog.pg_ts_config
  owner to postgres;

create unique index pg_ts_config_cfgname_index
  on pg_catalog.pg_ts_config (cfgname, cfgnamespace);

create unique index pg_ts_config_oid_index
  on pg_catalog.pg_ts_config (oid);

create table pg_catalog.pg_ts_config_map
(
  mapcfg       oid     not null,
  maptokentype integer not null,
  mapseqno     integer not null,
  mapdict      oid     not null
);

alter table pg_catalog.pg_ts_config_map
  owner to postgres;

create unique index pg_ts_config_map_index
  on pg_catalog.pg_ts_config_map (mapcfg, maptokentype, mapseqno);

create table pg_catalog.pg_ts_template
(
  tmplname      name    not null,
  tmplnamespace oid     not null,
  tmplinit      regproc not null,
  tmpllexize    regproc not null
);

alter table pg_catalog.pg_ts_template
  owner to postgres;

create unique index pg_ts_template_tmplname_index
  on pg_catalog.pg_ts_template (tmplname, tmplnamespace);

create unique index pg_ts_template_oid_index
  on pg_catalog.pg_ts_template (oid);

create table pg_catalog.pg_replication_origin
(
  roident oid  not null,
  roname  text not null
);

alter table pg_catalog.pg_replication_origin
  owner to postgres;

create unique index pg_replication_origin_roiident_index
  on pg_catalog.pg_replication_origin (roident);

create unique index pg_replication_origin_roname_index
  on pg_catalog.pg_replication_origin (roname);

create table pg_catalog.pg_subscription
(
  subdbid         oid     not null,
  subname         name    not null,
  subowner        oid     not null,
  subenabled      boolean not null,
  subconninfo     text    not null,
  subslotname     name    not null,
  subsynccommit   text    not null,
  subpublications text [] not null
);

alter table pg_catalog.pg_subscription
  owner to postgres;

create unique index pg_subscription_oid_index
  on pg_catalog.pg_subscription (oid);

create unique index pg_subscription_subname_index
  on pg_catalog.pg_subscription (subdbid, subname);

create table pg_catalog.pg_subscription_rel
(
  srsubid    oid    not null,
  srrelid    oid    not null,
  srsubstate "char" not null,
  srsublsn   pg_lsn not null
);

alter table pg_catalog.pg_subscription_rel
  owner to postgres;

create unique index pg_subscription_rel_srrelid_srsubid_index
  on pg_catalog.pg_subscription_rel (srrelid, srsubid);

create table pg_catalog.pg_publication
(
  pubname      name    not null,
  pubowner     oid     not null,
  puballtables boolean not null,
  pubinsert    boolean not null,
  pubupdate    boolean not null,
  pubdelete    boolean not null
);

alter table pg_catalog.pg_publication
  owner to postgres;

create unique index pg_publication_oid_index
  on pg_catalog.pg_publication (oid);

create unique index pg_publication_pubname_index
  on pg_catalog.pg_publication (pubname);

create table pg_catalog.pg_publication_rel
(
  prpubid oid not null,
  prrelid oid not null
);

alter table pg_catalog.pg_publication_rel
  owner to postgres;

create unique index pg_publication_rel_oid_index
  on pg_catalog.pg_publication_rel (oid);

create unique index pg_publication_rel_prrelid_prpubid_index
  on pg_catalog.pg_publication_rel (prrelid, prpubid);

create table information_schema.sql_features
(
  feature_id       information_schema.character_data,
  feature_name     information_schema.character_data,
  sub_feature_id   information_schema.character_data,
  sub_feature_name information_schema.character_data,
  is_supported     information_schema.yes_or_no,
  is_verified_by   information_schema.character_data,
  comments         information_schema.character_data
);

alter table information_schema.sql_features
  owner to postgres;

create table information_schema.sql_implementation_info
(
  implementation_info_id   information_schema.character_data,
  implementation_info_name information_schema.character_data,
  integer_value            information_schema.cardinal_number,
  character_value          information_schema.character_data,
  comments                 information_schema.character_data
);

alter table information_schema.sql_implementation_info
  owner to postgres;

create table information_schema.sql_languages
(
  sql_language_source               information_schema.character_data,
  sql_language_year                 information_schema.character_data,
  sql_language_conformance          information_schema.character_data,
  sql_language_integrity            information_schema.character_data,
  sql_language_implementation       information_schema.character_data,
  sql_language_binding_style        information_schema.character_data,
  sql_language_programming_language information_schema.character_data
);

alter table information_schema.sql_languages
  owner to postgres;

create table information_schema.sql_packages
(
  feature_id     information_schema.character_data,
  feature_name   information_schema.character_data,
  is_supported   information_schema.yes_or_no,
  is_verified_by information_schema.character_data,
  comments       information_schema.character_data
);

alter table information_schema.sql_packages
  owner to postgres;

create table information_schema.sql_parts
(
  feature_id     information_schema.character_data,
  feature_name   information_schema.character_data,
  is_supported   information_schema.yes_or_no,
  is_verified_by information_schema.character_data,
  comments       information_schema.character_data
);

alter table information_schema.sql_parts
  owner to postgres;

create table information_schema.sql_sizing
(
  sizing_id       information_schema.cardinal_number,
  sizing_name     information_schema.character_data,
  supported_value information_schema.cardinal_number,
  comments        information_schema.character_data
);

alter table information_schema.sql_sizing
  owner to postgres;

create table information_schema.sql_sizing_profiles
(
  sizing_id      information_schema.cardinal_number,
  sizing_name    information_schema.character_data,
  profile_id     information_schema.character_data,
  required_value information_schema.cardinal_number,
  comments       information_schema.character_data
);

alter table information_schema.sql_sizing_profiles
  owner to postgres;

create table genres
(
  id     bigserial   not null
    constraint genre_pkey
    primary key,
  name   varchar(30) not null,
  idtmdb bigserial
);

alter table genres
  owner to postgres;

create table "user"
(
  id        bigserial    not null
    constraint user_pkey
    primary key,
  surname   varchar(40),
  givenname varchar(30),
  login     varchar(20)  not null,
  password  varchar(120) not null
);

alter table "user"
  owner to postgres;

create unique index user_login_uindex
  on "user" (login);

create table persons
(
  id         bigserial not null
    constraint persons_pkey
    primary key,
  surname    varchar(60),
  givenname  varchar(40),
  image_path varchar(80),
  birthday   date,
  name       varchar(100),
  idtmdb     bigint
);

alter table persons
  owner to postgres;

create unique index persons_idtmdb_uindex
  on persons (idtmdb);

create table films
(
  id               bigserial not null
    constraint films_pkey
    primary key,
  title            varchar(200),
  rating           numeric(10, 5),
  image_path       varchar(120),
  summary          text,
  film_director    bigint
    constraint films_persons_id_fk
    references persons,
  release_date     date,
  idtmbd           bigint,
  vote_utilisateur numeric(2, 1)
);

alter table films
  owner to postgres;

create unique index films_idtmbd_uindex
  on films (idtmbd);

create table review
(
  id      bigserial               not null
    constraint review_pkey
    primary key,
  film_id bigint                  not null
    constraint review_films_id_fk
    references films,
  user_id bigint                  not null
    constraint review_user_id_fk
    references "user",
  article text,
  datte   timestamp default now() not null
);

alter table review
  owner to postgres;

create table play
(
  id        bigserial not null
    constraint play_pkey
    primary key,
  film_id   bigint    not null
    constraint play_films_id_fk
    references films
    on delete cascade,
  person_id bigint    not null
    constraint play___fk_person
    references persons
    on update cascade on delete cascade,
  rank      integer   not null,
  name      varchar   not null
);

alter table play
  owner to postgres;

create table film_genre
(
  genre_id bigint  not null
    constraint film_genre_genre_id_fk
    references genres
    on delete cascade,
  film_id  integer not null
    constraint film_genre_films_id_fk
    references films
    on delete cascade,
  constraint film_genre_pk
  primary key (film_id, genre_id)
);

alter table film_genre
  owner to postgres;

create table tmdb_films
(
  id             bigserial not null
    constraint tmdb_films_pkey
    primary key,
  original_title varchar,
  popularity     double precision,
  adult          boolean,
  video          boolean
);

alter table tmdb_films
  owner to postgres;

create table tmdb_persondetail
(
  id             bigserial not null
    constraint tmdb_persondetail_pkey
    primary key,
  name           varchar(255),
  biography      text,
  adult          boolean,
  birthday       varchar,
  deathday       varchar(30),
  place_of_birth varchar,
  profile_path   varchar
);

alter table tmdb_persondetail
  owner to postgres;

create view pg_catalog.pg_roles as
  SELECT pg_authid.rolname,
         pg_authid.rolsuper,
         pg_authid.rolinherit,
         pg_authid.rolcreaterole,
         pg_authid.rolcreatedb,
         pg_authid.rolcanlogin,
         pg_authid.rolreplication,
         pg_authid.rolconnlimit,
         '********' :: text AS rolpassword,
         pg_authid.rolvaliduntil,
         pg_authid.rolbypassrls,
         s.setconfig        AS rolconfig,
         pg_authid.oid
  FROM (pg_authid
      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0) :: oid))));

alter table pg_catalog.pg_roles
  owner to postgres;

create view pg_catalog.pg_shadow as
  SELECT pg_authid.rolname                    AS usename,
         pg_authid.oid                        AS usesysid,
         pg_authid.rolcreatedb                AS usecreatedb,
         pg_authid.rolsuper                   AS usesuper,
         pg_authid.rolreplication             AS userepl,
         pg_authid.rolbypassrls               AS usebypassrls,
         pg_authid.rolpassword                AS passwd,
         (pg_authid.rolvaliduntil) :: abstime AS valuntil,
         s.setconfig                          AS useconfig
  FROM (pg_authid
      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0) :: oid))))
  WHERE pg_authid.rolcanlogin;

alter table pg_catalog.pg_shadow
  owner to postgres;

create view pg_catalog.pg_group as
  SELECT pg_authid.rolname                                                                                        AS groname,
         pg_authid.oid                                                                                            AS grosysid,
         ARRAY(SELECT pg_auth_members.member
               FROM pg_auth_members
               WHERE (pg_auth_members.roleid = pg_authid.oid))                                                    AS grolist
  FROM pg_authid
  WHERE (NOT pg_authid.rolcanlogin);

alter table pg_catalog.pg_group
  owner to postgres;

create view pg_catalog.pg_user as
  SELECT pg_shadow.usename,
         pg_shadow.usesysid,
         pg_shadow.usecreatedb,
         pg_shadow.usesuper,
         pg_shadow.userepl,
         pg_shadow.usebypassrls,
         '********' :: text AS passwd,
         pg_shadow.valuntil,
         pg_shadow.useconfig
  FROM pg_shadow;

alter table pg_catalog.pg_user
  owner to postgres;

create view pg_catalog.pg_policies as
  SELECT n.nspname                                   AS schemaname,
         c.relname                                   AS tablename,
         pol.polname                                 AS policyname,
         CASE
           WHEN pol.polpermissive THEN 'PERMISSIVE' :: text
           ELSE 'RESTRICTIVE' :: text
             END                                     AS permissive,
         CASE
           WHEN (pol.polroles = '{0}' :: oid []) THEN (string_to_array('public' :: text, '' :: text)) :: name []
           ELSE ARRAY(SELECT pg_authid.rolname
                      FROM pg_authid
                      WHERE (pg_authid.oid = ANY (pol.polroles))
                      ORDER BY pg_authid.rolname)
             END                                     AS roles,
         CASE pol.polcmd
           WHEN 'r' :: "char" THEN 'SELECT' :: text
           WHEN 'a' :: "char" THEN 'INSERT' :: text
           WHEN 'w' :: "char" THEN 'UPDATE' :: text
           WHEN 'd' :: "char" THEN 'DELETE' :: text
           WHEN '*' :: "char" THEN 'ALL' :: text
           ELSE NULL :: text
             END                                     AS cmd,
         pg_get_expr(pol.polqual, pol.polrelid)      AS qual,
         pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check
  FROM ((pg_policy pol
      JOIN pg_class c ON ((c.oid = pol.polrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)));

alter table pg_catalog.pg_policies
  owner to postgres;

create view pg_catalog.pg_rules as
  SELECT n.nspname AS schemaname, c.relname AS tablename, r.rulename, pg_get_ruledef(r.oid) AS definition
  FROM ((pg_rewrite r
      JOIN pg_class c ON ((c.oid = r.ev_class)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (r.rulename <> '_RETURN' :: name);

alter table pg_catalog.pg_rules
  owner to postgres;

create view pg_catalog.pg_views as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS viewname,
         pg_get_userbyid(c.relowner) AS viewowner,
         pg_get_viewdef(c.oid)       AS definition
  FROM (pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = 'v' :: "char");

alter table pg_catalog.pg_views
  owner to postgres;

create view pg_catalog.pg_tables as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS tablename,
         pg_get_userbyid(c.relowner) AS tableowner,
         t.spcname                   AS tablespace,
         c.relhasindex               AS hasindexes,
         c.relhasrules               AS hasrules,
         c.relhastriggers            AS hastriggers,
         c.relrowsecurity            AS rowsecurity
  FROM ((pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"]));

alter table pg_catalog.pg_tables
  owner to postgres;

create view pg_catalog.pg_matviews as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS matviewname,
         pg_get_userbyid(c.relowner) AS matviewowner,
         t.spcname                   AS tablespace,
         c.relhasindex               AS hasindexes,
         c.relispopulated            AS ispopulated,
         pg_get_viewdef(c.oid)       AS definition
  FROM ((pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
  WHERE (c.relkind = 'm' :: "char");

alter table pg_catalog.pg_matviews
  owner to postgres;

create view pg_catalog.pg_indexes as
  SELECT n.nspname              AS schemaname,
         c.relname              AS tablename,
         i.relname              AS indexname,
         t.spcname              AS tablespace,
         pg_get_indexdef(i.oid) AS indexdef
  FROM ((((pg_index x
      JOIN pg_class c ON ((c.oid = x.indrelid)))
      JOIN pg_class i ON ((i.oid = x.indexrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
      LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'm'::"char"])) AND (i.relkind = 'i' :: "char"));

alter table pg_catalog.pg_indexes
  owner to postgres;

create view pg_catalog.pg_sequences as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS sequencename,
         pg_get_userbyid(c.relowner) AS sequenceowner,
         (s.seqtypid) :: regtype     AS data_type,
         s.seqstart                  AS start_value,
         s.seqmin                    AS min_value,
         s.seqmax                    AS max_value,
         s.seqincrement              AS increment_by,
         s.seqcycle                  AS cycle,
         s.seqcache                  AS cache_size,
         CASE
           WHEN has_sequence_privilege(c.oid, 'SELECT,USAGE' :: text) THEN pg_sequence_last_value((c.oid) :: regclass)
           ELSE NULL :: bigint
             END                     AS last_value
  FROM ((pg_sequence s
      JOIN pg_class c ON ((c.oid = s.seqrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE ((NOT pg_is_other_temp_schema(n.oid)) AND (c.relkind = 'S' :: "char"));

alter table pg_catalog.pg_sequences
  owner to postgres;

create view pg_catalog.pg_stats as
  SELECT n.nspname     AS schemaname,
         c.relname     AS tablename,
         a.attname,
         s.stainherit  AS inherited,
         s.stanullfrac AS null_frac,
         s.stawidth    AS avg_width,
         s.stadistinct AS n_distinct,
         CASE
           WHEN (s.stakind1 = 1) THEN s.stavalues1
           WHEN (s.stakind2 = 1) THEN s.stavalues2
           WHEN (s.stakind3 = 1) THEN s.stavalues3
           WHEN (s.stakind4 = 1) THEN s.stavalues4
           WHEN (s.stakind5 = 1) THEN s.stavalues5
           ELSE NULL :: anyarray
             END       AS most_common_vals,
         CASE
           WHEN (s.stakind1 = 1) THEN s.stanumbers1
           WHEN (s.stakind2 = 1) THEN s.stanumbers2
           WHEN (s.stakind3 = 1) THEN s.stanumbers3
           WHEN (s.stakind4 = 1) THEN s.stanumbers4
           WHEN (s.stakind5 = 1) THEN s.stanumbers5
           ELSE NULL :: real []
             END       AS most_common_freqs,
         CASE
           WHEN (s.stakind1 = 2) THEN s.stavalues1
           WHEN (s.stakind2 = 2) THEN s.stavalues2
           WHEN (s.stakind3 = 2) THEN s.stavalues3
           WHEN (s.stakind4 = 2) THEN s.stavalues4
           WHEN (s.stakind5 = 2) THEN s.stavalues5
           ELSE NULL :: anyarray
             END       AS histogram_bounds,
         CASE
           WHEN (s.stakind1 = 3) THEN s.stanumbers1 [ 1 ]
           WHEN (s.stakind2 = 3) THEN s.stanumbers2 [ 1 ]
           WHEN (s.stakind3 = 3) THEN s.stanumbers3 [ 1 ]
           WHEN (s.stakind4 = 3) THEN s.stanumbers4 [ 1 ]
           WHEN (s.stakind5 = 3) THEN s.stanumbers5 [ 1 ]
           ELSE NULL :: real
             END       AS correlation,
         CASE
           WHEN (s.stakind1 = 4) THEN s.stavalues1
           WHEN (s.stakind2 = 4) THEN s.stavalues2
           WHEN (s.stakind3 = 4) THEN s.stavalues3
           WHEN (s.stakind4 = 4) THEN s.stavalues4
           WHEN (s.stakind5 = 4) THEN s.stavalues5
           ELSE NULL :: anyarray
             END       AS most_common_elems,
         CASE
           WHEN (s.stakind1 = 4) THEN s.stanumbers1
           WHEN (s.stakind2 = 4) THEN s.stanumbers2
           WHEN (s.stakind3 = 4) THEN s.stanumbers3
           WHEN (s.stakind4 = 4) THEN s.stanumbers4
           WHEN (s.stakind5 = 4) THEN s.stanumbers5
           ELSE NULL :: real []
             END       AS most_common_elem_freqs,
         CASE
           WHEN (s.stakind1 = 5) THEN s.stanumbers1
           WHEN (s.stakind2 = 5) THEN s.stanumbers2
           WHEN (s.stakind3 = 5) THEN s.stanumbers3
           WHEN (s.stakind4 = 5) THEN s.stanumbers4
           WHEN (s.stakind5 = 5) THEN s.stanumbers5
           ELSE NULL :: real []
             END       AS elem_count_histogram
  FROM (((pg_statistic s
      JOIN pg_class c ON ((c.oid = s.starelid)))
      JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select' :: text) AND
         ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));

alter table pg_catalog.pg_stats
  owner to postgres;

create view pg_catalog.pg_publication_tables as
  SELECT p.pubname, n.nspname AS schemaname, c.relname AS tablename
  FROM pg_publication p,
       (pg_class c
           JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.oid IN (SELECT pg_get_publication_tables.relid
                   FROM pg_get_publication_tables((p.pubname) :: text) pg_get_publication_tables (relid)));

alter table pg_catalog.pg_publication_tables
  owner to postgres;

create view pg_catalog.pg_locks as
  SELECT l.locktype,
         l.database,
         l.relation,
         l.page,
         l.tuple,
         l.virtualxid,
         l.transactionid,
         l.classid,
         l.objid,
         l.objsubid,
         l.virtualtransaction,
         l.pid,
         l.mode,
         l.granted,
         l.fastpath
  FROM pg_lock_status() l (locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath);

alter table pg_catalog.pg_locks
  owner to postgres;

create view pg_catalog.pg_cursors as
  SELECT c.name, c.statement, c.is_holdable, c.is_binary, c.is_scrollable, c.creation_time
  FROM pg_cursor() c (name, statement, is_holdable, is_binary, is_scrollable, creation_time);

alter table pg_catalog.pg_cursors
  owner to postgres;

create view pg_catalog.pg_available_extensions as
  SELECT e.name, e.default_version, x.extversion AS installed_version, e.comment
  FROM (pg_available_extensions() e(name, default_version, comment)
      LEFT JOIN pg_extension x ON ((e.name = x.extname)));

alter table pg_catalog.pg_available_extensions
  owner to postgres;

create view pg_catalog.pg_available_extension_versions as
  SELECT e.name,
         e.version,
         (x.extname IS NOT NULL) AS installed,
         e.superuser,
         e.relocatable,
         e.schema,
         e.requires,
         e.comment
  FROM (pg_available_extension_versions() e(name, version, superuser, relocatable, schema, requires, comment)
      LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));

alter table pg_catalog.pg_available_extension_versions
  owner to postgres;

create view pg_catalog.pg_prepared_xacts as
  SELECT p.transaction, p.gid, p.prepared, u.rolname AS owner, d.datname AS database
  FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)
      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));

alter table pg_catalog.pg_prepared_xacts
  owner to postgres;

create view pg_catalog.pg_prepared_statements as
  SELECT p.name, p.statement, p.prepare_time, p.parameter_types, p.from_sql
  FROM pg_prepared_statement() p (name, statement, prepare_time, parameter_types, from_sql);

alter table pg_catalog.pg_prepared_statements
  owner to postgres;

create view pg_catalog.pg_seclabels as
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         CASE
           WHEN (rel.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) THEN 'table' :: text
           WHEN (rel.relkind = 'v' :: "char") THEN 'view' :: text
           WHEN (rel.relkind = 'm' :: "char") THEN 'materialized view' :: text
           WHEN (rel.relkind = 'S' :: "char") THEN 'sequence' :: text
           WHEN (rel.relkind = 'f' :: "char") THEN 'foreign table' :: text
           ELSE NULL :: text
             END          AS objtype,
         rel.relnamespace AS objnamespace,
         CASE
           WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname) :: text)
           ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((rel.relname) :: text))
             END          AS objname,
         l.provider,
         l.label
  FROM ((pg_seclabel l
      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'column' :: text                                       AS objtype,
         rel.relnamespace                                       AS objnamespace,
         ((
              CASE
                WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname) :: text)
                ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((rel.relname) :: text))
                  END || '.' :: text) || (att.attname) :: text) AS objname,
         l.provider,
         l.label
  FROM (((pg_seclabel l
      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
      JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum))))
      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
  WHERE (l.objsubid <> 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         CASE
           WHEN (pro.proisagg = true) THEN 'aggregate' :: text
           WHEN (pro.proisagg = false) THEN 'function' :: text
           ELSE NULL :: text
             END                                                                              AS objtype,
         pro.pronamespace                                                                     AS objnamespace,
         (((
               CASE
                 WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname) :: text)
                 ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((pro.proname) :: text))
                   END || '(' :: text) || pg_get_function_arguments(pro.oid)) || ')' :: text) AS objname,
         l.provider,
         l.label
  FROM ((pg_seclabel l
      JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid))))
      JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid)))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         CASE
           WHEN (typ.typtype = 'd' :: "char") THEN 'domain' :: text
           ELSE 'type' :: text
             END          AS objtype,
         typ.typnamespace AS objnamespace,
         CASE
           WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname) :: text)
           ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((typ.typname) :: text))
             END          AS objname,
         l.provider,
         l.label
  FROM ((pg_seclabel l
      JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid))))
      JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid)))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'large object' :: text AS objtype,
         NULL :: oid            AS objnamespace,
         (l.objoid) :: text     AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid)))
  WHERE ((l.classoid = ('pg_largeobject' :: regclass) :: oid) AND (l.objsubid = 0))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'language' :: text                 AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((lan.lanname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'schema' :: text                   AS objtype,
         nsp.oid                            AS objnamespace,
         quote_ident((nsp.nspname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'event trigger' :: text            AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((evt.evtname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_event_trigger evt ON (((l.classoid = evt.tableoid) AND (l.objoid = evt.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'publication' :: text            AS objtype,
         NULL :: oid                      AS objnamespace,
         quote_ident((p.pubname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                AS objsubid,
         'subscription' :: text           AS objtype,
         NULL :: oid                      AS objnamespace,
         quote_ident((s.subname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                  AS objsubid,
         'database' :: text                 AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((dat.datname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                  AS objsubid,
         'tablespace' :: text               AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((spc.spcname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                  AS objsubid,
         'role' :: text                     AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((rol.rolname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));

alter table pg_catalog.pg_seclabels
  owner to postgres;

create view pg_catalog.pg_settings as
  SELECT a.name,
         a.setting,
         a.unit,
         a.category,
         a.short_desc,
         a.extra_desc,
         a.context,
         a.vartype,
         a.source,
         a.min_val,
         a.max_val,
         a.enumvals,
         a.boot_val,
         a.reset_val,
         a.sourcefile,
         a.sourceline,
         a.pending_restart
  FROM pg_show_all_settings() a (name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);

alter table pg_catalog.pg_settings
  owner to postgres;

CREATE RULE pg_settings_u AS
  ON UPDATE
  TO pg_catalog.pg_settings
  WHERE (new.name = old.name) DO SELECT set_config(old.name, new.setting, false) AS set_config;

CREATE RULE pg_settings_n AS
  ON UPDATE
  TO pg_catalog.pg_settings DO INSTEAD NOTHING;

create view pg_catalog.pg_file_settings as
  SELECT a.sourcefile, a.sourceline, a.seqno, a.name, a.setting, a.applied, a.error
  FROM pg_show_all_file_settings() a (sourcefile, sourceline, seqno, name, setting, applied, error);

alter table pg_catalog.pg_file_settings
  owner to postgres;

create view pg_catalog.pg_hba_file_rules as
  SELECT a.line_number,
         a.type,
         a.database,
         a.user_name,
         a.address,
         a.netmask,
         a.auth_method,
         a.options,
         a.error
  FROM pg_hba_file_rules() a (line_number, type, database, user_name, address, netmask, auth_method, options, error);

alter table pg_catalog.pg_hba_file_rules
  owner to postgres;

create view pg_catalog.pg_timezone_abbrevs as
  SELECT pg_timezone_abbrevs.abbrev, pg_timezone_abbrevs.utc_offset, pg_timezone_abbrevs.is_dst
  FROM pg_timezone_abbrevs() pg_timezone_abbrevs (abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_abbrevs
  owner to postgres;

create view pg_catalog.pg_timezone_names as
  SELECT pg_timezone_names.name, pg_timezone_names.abbrev, pg_timezone_names.utc_offset, pg_timezone_names.is_dst
  FROM pg_timezone_names() pg_timezone_names (name, abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_names
  owner to postgres;

create view pg_catalog.pg_config as
  SELECT pg_config.name, pg_config.setting
  FROM pg_config() pg_config (name, setting);

alter table pg_catalog.pg_config
  owner to postgres;

create view pg_catalog.pg_stat_all_tables as
  SELECT c.oid                                               AS relid,
         n.nspname                                           AS schemaname,
         c.relname,
         pg_stat_get_numscans(c.oid)                         AS seq_scan,
         pg_stat_get_tuples_returned(c.oid)                  AS seq_tup_read,
         (sum(pg_stat_get_numscans(i.indexrelid))) :: bigint AS idx_scan,
         ((sum(pg_stat_get_tuples_fetched(i.indexrelid))) :: bigint +
          pg_stat_get_tuples_fetched(c.oid))                 AS idx_tup_fetch,
         pg_stat_get_tuples_inserted(c.oid)                  AS n_tup_ins,
         pg_stat_get_tuples_updated(c.oid)                   AS n_tup_upd,
         pg_stat_get_tuples_deleted(c.oid)                   AS n_tup_del,
         pg_stat_get_tuples_hot_updated(c.oid)               AS n_tup_hot_upd,
         pg_stat_get_live_tuples(c.oid)                      AS n_live_tup,
         pg_stat_get_dead_tuples(c.oid)                      AS n_dead_tup,
         pg_stat_get_mod_since_analyze(c.oid)                AS n_mod_since_analyze,
         pg_stat_get_last_vacuum_time(c.oid)                 AS last_vacuum,
         pg_stat_get_last_autovacuum_time(c.oid)             AS last_autovacuum,
         pg_stat_get_last_analyze_time(c.oid)                AS last_analyze,
         pg_stat_get_last_autoanalyze_time(c.oid)            AS last_autoanalyze,
         pg_stat_get_vacuum_count(c.oid)                     AS vacuum_count,
         pg_stat_get_autovacuum_count(c.oid)                 AS autovacuum_count,
         pg_stat_get_analyze_count(c.oid)                    AS analyze_count,
         pg_stat_get_autoanalyze_count(c.oid)                AS autoanalyze_count
  FROM ((pg_class c
      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
  GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_all_tables
  owner to postgres;

create view pg_catalog.pg_stat_xact_all_tables as
  SELECT c.oid                                                    AS relid,
         n.nspname                                                AS schemaname,
         c.relname,
         pg_stat_get_xact_numscans(c.oid)                         AS seq_scan,
         pg_stat_get_xact_tuples_returned(c.oid)                  AS seq_tup_read,
         (sum(pg_stat_get_xact_numscans(i.indexrelid))) :: bigint AS idx_scan,
         ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid))) :: bigint +
          pg_stat_get_xact_tuples_fetched(c.oid))                 AS idx_tup_fetch,
         pg_stat_get_xact_tuples_inserted(c.oid)                  AS n_tup_ins,
         pg_stat_get_xact_tuples_updated(c.oid)                   AS n_tup_upd,
         pg_stat_get_xact_tuples_deleted(c.oid)                   AS n_tup_del,
         pg_stat_get_xact_tuples_hot_updated(c.oid)               AS n_tup_hot_upd
  FROM ((pg_class c
      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
  GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_xact_all_tables
  owner to postgres;

create view pg_catalog.pg_stat_sys_tables as
  SELECT pg_stat_all_tables.relid,
         pg_stat_all_tables.schemaname,
         pg_stat_all_tables.relname,
         pg_stat_all_tables.seq_scan,
         pg_stat_all_tables.seq_tup_read,
         pg_stat_all_tables.idx_scan,
         pg_stat_all_tables.idx_tup_fetch,
         pg_stat_all_tables.n_tup_ins,
         pg_stat_all_tables.n_tup_upd,
         pg_stat_all_tables.n_tup_del,
         pg_stat_all_tables.n_tup_hot_upd,
         pg_stat_all_tables.n_live_tup,
         pg_stat_all_tables.n_dead_tup,
         pg_stat_all_tables.n_mod_since_analyze,
         pg_stat_all_tables.last_vacuum,
         pg_stat_all_tables.last_autovacuum,
         pg_stat_all_tables.last_analyze,
         pg_stat_all_tables.last_autoanalyze,
         pg_stat_all_tables.vacuum_count,
         pg_stat_all_tables.autovacuum_count,
         pg_stat_all_tables.analyze_count,
         pg_stat_all_tables.autoanalyze_count
  FROM pg_stat_all_tables
  WHERE ((pg_stat_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_stat_all_tables.schemaname ~ '^pg_toast' :: text));

alter table pg_catalog.pg_stat_sys_tables
  owner to postgres;

create view pg_catalog.pg_stat_xact_sys_tables as
  SELECT pg_stat_xact_all_tables.relid,
         pg_stat_xact_all_tables.schemaname,
         pg_stat_xact_all_tables.relname,
         pg_stat_xact_all_tables.seq_scan,
         pg_stat_xact_all_tables.seq_tup_read,
         pg_stat_xact_all_tables.idx_scan,
         pg_stat_xact_all_tables.idx_tup_fetch,
         pg_stat_xact_all_tables.n_tup_ins,
         pg_stat_xact_all_tables.n_tup_upd,
         pg_stat_xact_all_tables.n_tup_del,
         pg_stat_xact_all_tables.n_tup_hot_upd
  FROM pg_stat_xact_all_tables
  WHERE ((pg_stat_xact_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_stat_xact_all_tables.schemaname ~ '^pg_toast' :: text));

alter table pg_catalog.pg_stat_xact_sys_tables
  owner to postgres;

create view pg_catalog.pg_stat_user_tables as
  SELECT pg_stat_all_tables.relid,
         pg_stat_all_tables.schemaname,
         pg_stat_all_tables.relname,
         pg_stat_all_tables.seq_scan,
         pg_stat_all_tables.seq_tup_read,
         pg_stat_all_tables.idx_scan,
         pg_stat_all_tables.idx_tup_fetch,
         pg_stat_all_tables.n_tup_ins,
         pg_stat_all_tables.n_tup_upd,
         pg_stat_all_tables.n_tup_del,
         pg_stat_all_tables.n_tup_hot_upd,
         pg_stat_all_tables.n_live_tup,
         pg_stat_all_tables.n_dead_tup,
         pg_stat_all_tables.n_mod_since_analyze,
         pg_stat_all_tables.last_vacuum,
         pg_stat_all_tables.last_autovacuum,
         pg_stat_all_tables.last_analyze,
         pg_stat_all_tables.last_autoanalyze,
         pg_stat_all_tables.vacuum_count,
         pg_stat_all_tables.autovacuum_count,
         pg_stat_all_tables.analyze_count,
         pg_stat_all_tables.autoanalyze_count
  FROM pg_stat_all_tables
  WHERE ((pg_stat_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_stat_all_tables.schemaname !~ '^pg_toast' :: text));

alter table pg_catalog.pg_stat_user_tables
  owner to postgres;

create view pg_catalog.pg_stat_xact_user_tables as
  SELECT pg_stat_xact_all_tables.relid,
         pg_stat_xact_all_tables.schemaname,
         pg_stat_xact_all_tables.relname,
         pg_stat_xact_all_tables.seq_scan,
         pg_stat_xact_all_tables.seq_tup_read,
         pg_stat_xact_all_tables.idx_scan,
         pg_stat_xact_all_tables.idx_tup_fetch,
         pg_stat_xact_all_tables.n_tup_ins,
         pg_stat_xact_all_tables.n_tup_upd,
         pg_stat_xact_all_tables.n_tup_del,
         pg_stat_xact_all_tables.n_tup_hot_upd
  FROM pg_stat_xact_all_tables
  WHERE ((pg_stat_xact_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_stat_xact_all_tables.schemaname !~ '^pg_toast' :: text));

alter table pg_catalog.pg_stat_xact_user_tables
  owner to postgres;

create view pg_catalog.pg_statio_all_tables as
  SELECT c.oid                                                               AS relid,
         n.nspname                                                           AS schemaname,
         c.relname,
         (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read,
         pg_stat_get_blocks_hit(c.oid)                                       AS heap_blks_hit,
         (sum((pg_stat_get_blocks_fetched(i.indexrelid) -
               pg_stat_get_blocks_hit(i.indexrelid)))) :: bigint             AS idx_blks_read,
         (sum(pg_stat_get_blocks_hit(i.indexrelid))) :: bigint               AS idx_blks_hit,
         (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read,
         pg_stat_get_blocks_hit(t.oid)                                       AS toast_blks_hit,
         (sum((pg_stat_get_blocks_fetched(x.indexrelid) -
               pg_stat_get_blocks_hit(x.indexrelid)))) :: bigint             AS tidx_blks_read,
         (sum(pg_stat_get_blocks_hit(x.indexrelid))) :: bigint               AS tidx_blks_hit
  FROM ((((pg_class c
      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
      LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid)))
      LEFT JOIN pg_index x ON ((t.oid = x.indrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
  GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indrelid;

alter table pg_catalog.pg_statio_all_tables
  owner to postgres;

create view pg_catalog.pg_statio_sys_tables as
  SELECT pg_statio_all_tables.relid,
         pg_statio_all_tables.schemaname,
         pg_statio_all_tables.relname,
         pg_statio_all_tables.heap_blks_read,
         pg_statio_all_tables.heap_blks_hit,
         pg_statio_all_tables.idx_blks_read,
         pg_statio_all_tables.idx_blks_hit,
         pg_statio_all_tables.toast_blks_read,
         pg_statio_all_tables.toast_blks_hit,
         pg_statio_all_tables.tidx_blks_read,
         pg_statio_all_tables.tidx_blks_hit
  FROM pg_statio_all_tables
  WHERE ((pg_statio_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_statio_all_tables.schemaname ~ '^pg_toast' :: text));

alter table pg_catalog.pg_statio_sys_tables
  owner to postgres;

create view pg_catalog.pg_statio_user_tables as
  SELECT pg_statio_all_tables.relid,
         pg_statio_all_tables.schemaname,
         pg_statio_all_tables.relname,
         pg_statio_all_tables.heap_blks_read,
         pg_statio_all_tables.heap_blks_hit,
         pg_statio_all_tables.idx_blks_read,
         pg_statio_all_tables.idx_blks_hit,
         pg_statio_all_tables.toast_blks_read,
         pg_statio_all_tables.toast_blks_hit,
         pg_statio_all_tables.tidx_blks_read,
         pg_statio_all_tables.tidx_blks_hit
  FROM pg_statio_all_tables
  WHERE ((pg_statio_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_statio_all_tables.schemaname !~ '^pg_toast' :: text));

alter table pg_catalog.pg_statio_user_tables
  owner to postgres;

create view pg_catalog.pg_stat_all_indexes as
  SELECT c.oid                              AS relid,
         i.oid                              AS indexrelid,
         n.nspname                          AS schemaname,
         c.relname,
         i.relname                          AS indexrelname,
         pg_stat_get_numscans(i.oid)        AS idx_scan,
         pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,
         pg_stat_get_tuples_fetched(i.oid)  AS idx_tup_fetch
  FROM (((pg_class c
      JOIN pg_index x ON ((c.oid = x.indrelid)))
      JOIN pg_class i ON ((i.oid = x.indexrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));

alter table pg_catalog.pg_stat_all_indexes
  owner to postgres;

create view pg_catalog.pg_stat_sys_indexes as
  SELECT pg_stat_all_indexes.relid,
         pg_stat_all_indexes.indexrelid,
         pg_stat_all_indexes.schemaname,
         pg_stat_all_indexes.relname,
         pg_stat_all_indexes.indexrelname,
         pg_stat_all_indexes.idx_scan,
         pg_stat_all_indexes.idx_tup_read,
         pg_stat_all_indexes.idx_tup_fetch
  FROM pg_stat_all_indexes
  WHERE ((pg_stat_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_stat_all_indexes.schemaname ~ '^pg_toast' :: text));

alter table pg_catalog.pg_stat_sys_indexes
  owner to postgres;

create view pg_catalog.pg_stat_user_indexes as
  SELECT pg_stat_all_indexes.relid,
         pg_stat_all_indexes.indexrelid,
         pg_stat_all_indexes.schemaname,
         pg_stat_all_indexes.relname,
         pg_stat_all_indexes.indexrelname,
         pg_stat_all_indexes.idx_scan,
         pg_stat_all_indexes.idx_tup_read,
         pg_stat_all_indexes.idx_tup_fetch
  FROM pg_stat_all_indexes
  WHERE ((pg_stat_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_stat_all_indexes.schemaname !~ '^pg_toast' :: text));

alter table pg_catalog.pg_stat_user_indexes
  owner to postgres;

create view pg_catalog.pg_statio_all_indexes as
  SELECT c.oid                                                               AS relid,
         i.oid                                                               AS indexrelid,
         n.nspname                                                           AS schemaname,
         c.relname,
         i.relname                                                           AS indexrelname,
         (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read,
         pg_stat_get_blocks_hit(i.oid)                                       AS idx_blks_hit
  FROM (((pg_class c
      JOIN pg_index x ON ((c.oid = x.indrelid)))
      JOIN pg_class i ON ((i.oid = x.indexrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));

alter table pg_catalog.pg_statio_all_indexes
  owner to postgres;

create view pg_catalog.pg_statio_sys_indexes as
  SELECT pg_statio_all_indexes.relid,
         pg_statio_all_indexes.indexrelid,
         pg_statio_all_indexes.schemaname,
         pg_statio_all_indexes.relname,
         pg_statio_all_indexes.indexrelname,
         pg_statio_all_indexes.idx_blks_read,
         pg_statio_all_indexes.idx_blks_hit
  FROM pg_statio_all_indexes
  WHERE ((pg_statio_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_statio_all_indexes.schemaname ~ '^pg_toast' :: text));

alter table pg_catalog.pg_statio_sys_indexes
  owner to postgres;

create view pg_catalog.pg_statio_user_indexes as
  SELECT pg_statio_all_indexes.relid,
         pg_statio_all_indexes.indexrelid,
         pg_statio_all_indexes.schemaname,
         pg_statio_all_indexes.relname,
         pg_statio_all_indexes.indexrelname,
         pg_statio_all_indexes.idx_blks_read,
         pg_statio_all_indexes.idx_blks_hit
  FROM pg_statio_all_indexes
  WHERE ((pg_statio_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_statio_all_indexes.schemaname !~ '^pg_toast' :: text));

alter table pg_catalog.pg_statio_user_indexes
  owner to postgres;

create view pg_catalog.pg_statio_all_sequences as
  SELECT c.oid                                                               AS relid,
         n.nspname                                                           AS schemaname,
         c.relname,
         (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read,
         pg_stat_get_blocks_hit(c.oid)                                       AS blks_hit
  FROM (pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = 'S' :: "char");

alter table pg_catalog.pg_statio_all_sequences
  owner to postgres;

create view pg_catalog.pg_statio_sys_sequences as
  SELECT pg_statio_all_sequences.relid,
         pg_statio_all_sequences.schemaname,
         pg_statio_all_sequences.relname,
         pg_statio_all_sequences.blks_read,
         pg_statio_all_sequences.blks_hit
  FROM pg_statio_all_sequences
  WHERE ((pg_statio_all_sequences.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_statio_all_sequences.schemaname ~ '^pg_toast' :: text));

alter table pg_catalog.pg_statio_sys_sequences
  owner to postgres;

create view pg_catalog.pg_statio_user_sequences as
  SELECT pg_statio_all_sequences.relid,
         pg_statio_all_sequences.schemaname,
         pg_statio_all_sequences.relname,
         pg_statio_all_sequences.blks_read,
         pg_statio_all_sequences.blks_hit
  FROM pg_statio_all_sequences
  WHERE ((pg_statio_all_sequences.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_statio_all_sequences.schemaname !~ '^pg_toast' :: text));

alter table pg_catalog.pg_statio_user_sequences
  owner to postgres;

create view pg_catalog.pg_stat_activity as
  SELECT s.datid,
         d.datname,
         s.pid,
         s.usesysid,
         u.rolname AS usename,
         s.application_name,
         s.client_addr,
         s.client_hostname,
         s.client_port,
         s.backend_start,
         s.xact_start,
         s.query_start,
         s.state_change,
         s.wait_event_type,
         s.wait_event,
         s.state,
         s.backend_xid,
         s.backend_xmin,
         s.query,
         s.backend_type
  FROM ((pg_stat_get_activity(NULL :: integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression, sslclientdn)
      LEFT JOIN pg_database d ON ((s.datid = d.oid)))
      LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));

alter table pg_catalog.pg_stat_activity
  owner to postgres;

create view pg_catalog.pg_stat_replication as
  SELECT s.pid,
         s.usesysid,
         u.rolname AS usename,
         s.application_name,
         s.client_addr,
         s.client_hostname,
         s.client_port,
         s.backend_start,
         s.backend_xmin,
         w.state,
         w.sent_lsn,
         w.write_lsn,
         w.flush_lsn,
         w.replay_lsn,
         w.write_lag,
         w.flush_lag,
         w.replay_lag,
         w.sync_priority,
         w.sync_state
  FROM ((pg_stat_get_activity(NULL :: integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression, sslclientdn)
      JOIN pg_stat_get_wal_senders() w(pid, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag, sync_priority, sync_state) ON ((
    s.pid = w.pid)))
      LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));

alter table pg_catalog.pg_stat_replication
  owner to postgres;

create view pg_catalog.pg_stat_wal_receiver as
  SELECT s.pid,
         s.status,
         s.receive_start_lsn,
         s.receive_start_tli,
         s.received_lsn,
         s.received_tli,
         s.last_msg_send_time,
         s.last_msg_receipt_time,
         s.latest_end_lsn,
         s.latest_end_time,
         s.slot_name,
         s.conninfo
  FROM pg_stat_get_wal_receiver() s (pid, status, receive_start_lsn, receive_start_tli, received_lsn, received_tli, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, conninfo)
  WHERE (s.pid IS NOT NULL);

alter table pg_catalog.pg_stat_wal_receiver
  owner to postgres;

create view pg_catalog.pg_stat_subscription as
  SELECT su.oid AS subid,
         su.subname,
         st.pid,
         st.relid,
         st.received_lsn,
         st.last_msg_send_time,
         st.last_msg_receipt_time,
         st.latest_end_lsn,
         st.latest_end_time
  FROM (pg_subscription su
      LEFT JOIN pg_stat_get_subscription(NULL :: oid) st(subid, relid, pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time) ON ((
    st.subid = su.oid)));

alter table pg_catalog.pg_stat_subscription
  owner to postgres;

create view pg_catalog.pg_stat_ssl as
  SELECT s.pid,
         s.ssl,
         s.sslversion     AS version,
         s.sslcipher      AS cipher,
         s.sslbits        AS bits,
         s.sslcompression AS compression,
         s.sslclientdn    AS clientdn
  FROM pg_stat_get_activity(NULL :: integer) s (datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression, sslclientdn);

alter table pg_catalog.pg_stat_ssl
  owner to postgres;

create view pg_catalog.pg_replication_slots as
  SELECT l.slot_name,
         l.plugin,
         l.slot_type,
         l.datoid,
         d.datname AS database,
         l.temporary,
         l.active,
         l.active_pid,
         l.xmin,
         l.catalog_xmin,
         l.restart_lsn,
         l.confirmed_flush_lsn
  FROM (pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, temporary, active, active_pid, xmin, catalog_xmin, restart_lsn, confirmed_flush_lsn)
      LEFT JOIN pg_database d ON ((l.datoid = d.oid)));

alter table pg_catalog.pg_replication_slots
  owner to postgres;

create view pg_catalog.pg_stat_database as
  SELECT d.oid                                                                     AS datid,
         d.datname,
         pg_stat_get_db_numbackends(d.oid)                                         AS numbackends,
         pg_stat_get_db_xact_commit(d.oid)                                         AS xact_commit,
         pg_stat_get_db_xact_rollback(d.oid)                                       AS xact_rollback,
         (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read,
         pg_stat_get_db_blocks_hit(d.oid)                                          AS blks_hit,
         pg_stat_get_db_tuples_returned(d.oid)                                     AS tup_returned,
         pg_stat_get_db_tuples_fetched(d.oid)                                      AS tup_fetched,
         pg_stat_get_db_tuples_inserted(d.oid)                                     AS tup_inserted,
         pg_stat_get_db_tuples_updated(d.oid)                                      AS tup_updated,
         pg_stat_get_db_tuples_deleted(d.oid)                                      AS tup_deleted,
         pg_stat_get_db_conflict_all(d.oid)                                        AS conflicts,
         pg_stat_get_db_temp_files(d.oid)                                          AS temp_files,
         pg_stat_get_db_temp_bytes(d.oid)                                          AS temp_bytes,
         pg_stat_get_db_deadlocks(d.oid)                                           AS deadlocks,
         pg_stat_get_db_blk_read_time(d.oid)                                       AS blk_read_time,
         pg_stat_get_db_blk_write_time(d.oid)                                      AS blk_write_time,
         pg_stat_get_db_stat_reset_time(d.oid)                                     AS stats_reset
  FROM pg_database d;

alter table pg_catalog.pg_stat_database
  owner to postgres;

create view pg_catalog.pg_stat_database_conflicts as
  SELECT d.oid                                           AS datid,
         d.datname,
         pg_stat_get_db_conflict_tablespace(d.oid)       AS confl_tablespace,
         pg_stat_get_db_conflict_lock(d.oid)             AS confl_lock,
         pg_stat_get_db_conflict_snapshot(d.oid)         AS confl_snapshot,
         pg_stat_get_db_conflict_bufferpin(d.oid)        AS confl_bufferpin,
         pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock
  FROM pg_database d;

alter table pg_catalog.pg_stat_database_conflicts
  owner to postgres;

create view pg_catalog.pg_stat_user_functions as
  SELECT p.oid                                  AS funcid,
         n.nspname                              AS schemaname,
         p.proname                              AS funcname,
         pg_stat_get_function_calls(p.oid)      AS calls,
         pg_stat_get_function_total_time(p.oid) AS total_time,
         pg_stat_get_function_self_time(p.oid)  AS self_time
  FROM (pg_proc p
      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
  WHERE ((p.prolang <> (12) :: oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));

alter table pg_catalog.pg_stat_user_functions
  owner to postgres;

create view pg_catalog.pg_stat_xact_user_functions as
  SELECT p.oid                                       AS funcid,
         n.nspname                                   AS schemaname,
         p.proname                                   AS funcname,
         pg_stat_get_xact_function_calls(p.oid)      AS calls,
         pg_stat_get_xact_function_total_time(p.oid) AS total_time,
         pg_stat_get_xact_function_self_time(p.oid)  AS self_time
  FROM (pg_proc p
      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
  WHERE ((p.prolang <> (12) :: oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));

alter table pg_catalog.pg_stat_xact_user_functions
  owner to postgres;

create view pg_catalog.pg_stat_archiver as
  SELECT s.archived_count,
         s.last_archived_wal,
         s.last_archived_time,
         s.failed_count,
         s.last_failed_wal,
         s.last_failed_time,
         s.stats_reset
  FROM pg_stat_get_archiver() s (archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time, stats_reset);

alter table pg_catalog.pg_stat_archiver
  owner to postgres;

create view pg_catalog.pg_stat_bgwriter as
  SELECT pg_stat_get_bgwriter_timed_checkpoints()       AS checkpoints_timed,
         pg_stat_get_bgwriter_requested_checkpoints()   AS checkpoints_req,
         pg_stat_get_checkpoint_write_time()            AS checkpoint_write_time,
         pg_stat_get_checkpoint_sync_time()             AS checkpoint_sync_time,
         pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,
         pg_stat_get_bgwriter_buf_written_clean()       AS buffers_clean,
         pg_stat_get_bgwriter_maxwritten_clean()        AS maxwritten_clean,
         pg_stat_get_buf_written_backend()              AS buffers_backend,
         pg_stat_get_buf_fsync_backend()                AS buffers_backend_fsync,
         pg_stat_get_buf_alloc()                        AS buffers_alloc,
         pg_stat_get_bgwriter_stat_reset_time()         AS stats_reset;

alter table pg_catalog.pg_stat_bgwriter
  owner to postgres;

create view pg_catalog.pg_stat_progress_vacuum as
  SELECT s.pid,
         s.datid,
         d.datname,
         s.relid,
         CASE s.param1
           WHEN 0 THEN 'initializing' :: text
           WHEN 1 THEN 'scanning heap' :: text
           WHEN 2 THEN 'vacuuming indexes' :: text
           WHEN 3 THEN 'vacuuming heap' :: text
           WHEN 4 THEN 'cleaning up indexes' :: text
           WHEN 5 THEN 'truncating heap' :: text
           WHEN 6 THEN 'performing final cleanup' :: text
           ELSE NULL :: text
             END  AS phase,
         s.param2 AS heap_blks_total,
         s.param3 AS heap_blks_scanned,
         s.param4 AS heap_blks_vacuumed,
         s.param5 AS index_vacuum_count,
         s.param6 AS max_dead_tuples,
         s.param7 AS num_dead_tuples
  FROM (pg_stat_get_progress_info('VACUUM' :: text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)
      LEFT JOIN pg_database d ON ((s.datid = d.oid)));

alter table pg_catalog.pg_stat_progress_vacuum
  owner to postgres;

create view pg_catalog.pg_user_mappings as
  SELECT u.oid   AS umid,
         s.oid   AS srvid,
         s.srvname,
         u.umuser,
         CASE
           WHEN (u.umuser = (0) :: oid) THEN 'public' :: name
           ELSE a.rolname
             END AS usename,
         CASE
           WHEN (((u.umuser <> (0) :: oid) AND (a.rolname = CURRENT_USER) AND
                  (pg_has_role(s.srvowner, 'USAGE' :: text) OR has_server_privilege(s.oid, 'USAGE' :: text))) OR
                 ((u.umuser = (0) :: oid) AND pg_has_role(s.srvowner, 'USAGE' :: text)) OR
                 (SELECT pg_authid.rolsuper FROM pg_authid WHERE (pg_authid.rolname = CURRENT_USER))) THEN u.umoptions
           ELSE NULL :: text []
             END AS umoptions
  FROM ((pg_user_mapping u
      JOIN pg_foreign_server s ON ((u.umserver = s.oid)))
      LEFT JOIN pg_authid a ON ((a.oid = u.umuser)));

alter table pg_catalog.pg_user_mappings
  owner to postgres;

create view pg_catalog.pg_replication_origin_status as
  SELECT pg_show_replication_origin_status.local_id,
         pg_show_replication_origin_status.external_id,
         pg_show_replication_origin_status.remote_lsn,
         pg_show_replication_origin_status.local_lsn
  FROM pg_show_replication_origin_status() pg_show_replication_origin_status (local_id, external_id, remote_lsn, local_lsn);

alter table pg_catalog.pg_replication_origin_status
  owner to postgres;

create view information_schema.information_schema_catalog_name as
  SELECT (current_database()) :: information_schema.sql_identifier AS catalog_name;

alter table information_schema.information_schema_catalog_name
  owner to postgres;

create view information_schema.applicable_roles as
  SELECT (a.rolname) :: information_schema.sql_identifier AS grantee,
         (b.rolname) :: information_schema.sql_identifier AS role_name,
         (
             CASE
               WHEN m.admin_option THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no     AS is_grantable
  FROM ((pg_auth_members m
      JOIN pg_authid a ON ((m.member = a.oid)))
      JOIN pg_authid b ON ((m.roleid = b.oid)))
  WHERE pg_has_role(a.oid, 'USAGE' :: text);

alter table information_schema.applicable_roles
  owner to postgres;

create view information_schema.administrable_role_authorizations as
  SELECT applicable_roles.grantee, applicable_roles.role_name, applicable_roles.is_grantable
  FROM information_schema.applicable_roles
  WHERE ((applicable_roles.is_grantable) :: text = 'YES' :: text);

alter table information_schema.administrable_role_authorizations
  owner to postgres;

create view information_schema.attributes as
  SELECT (current_database()) :: information_schema.sql_identifier                                                                           AS udt_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                                                   AS udt_schema,
         (c.relname) :: information_schema.sql_identifier                                                                                    AS udt_name,
         (a.attname) :: information_schema.sql_identifier                                                                                    AS attribute_name,
         (a.attnum) :: information_schema.cardinal_number                                                                                    AS ordinal_position,
         (pg_get_expr(ad.adbin, ad.adrelid)) :: information_schema.character_data                                                            AS attribute_default,
         (
             CASE
               WHEN (a.attnotnull OR ((t.typtype = 'd' :: "char") AND t.typnotnull)) THEN 'NO' :: text
               ELSE 'YES' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_nullable,
         (
             CASE
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(a.atttypid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                                                   AS data_type,
         (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number         AS character_maximum_length,
         (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                                                                                  AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                                                                                  AS collation_name,
         (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS numeric_precision,
         (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                         information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number AS numeric_precision_radix,
         (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number           AS numeric_scale,
         (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                    information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number      AS datetime_precision,
         (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.character_data            AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS interval_precision,
         (current_database()) :: information_schema.sql_identifier                                                                           AS attribute_udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                                                   AS attribute_udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                                                    AS attribute_udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS maximum_cardinality,
         (a.attnum) :: information_schema.sql_identifier                                                                                     AS dtd_identifier,
         ('NO' :: character varying) :: information_schema.yes_or_no                                                                         AS is_derived_reference_attribute
  FROM ((((pg_attribute a
      LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
      JOIN (pg_class c
      JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
      JOIN (pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
      LEFT JOIN (pg_collation co
      JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND
                                                                    ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                     (co.collname <> 'default' :: name)))))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = 'c' :: "char") AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR has_type_privilege(c.reltype, 'USAGE' :: text)));

alter table information_schema.attributes
  owner to postgres;

create view information_schema.character_sets as
  SELECT (NULL :: character varying) :: information_schema.sql_identifier AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier AS character_set_schema,
         (getdatabaseencoding()) :: information_schema.sql_identifier     AS character_set_name,
         (
             CASE
               WHEN (getdatabaseencoding() = 'UTF8' :: name) THEN 'UCS' :: name
               ELSE getdatabaseencoding()
                 END) :: information_schema.sql_identifier                AS character_repertoire,
         (getdatabaseencoding()) :: information_schema.sql_identifier     AS form_of_use,
         (current_database()) :: information_schema.sql_identifier        AS default_collate_catalog,
         (nc.nspname) :: information_schema.sql_identifier                AS default_collate_schema,
         (c.collname) :: information_schema.sql_identifier                AS default_collate_name
  FROM (pg_database d
      LEFT JOIN (pg_collation c
      JOIN pg_namespace nc ON ((c.collnamespace = nc.oid))) ON (((d.datcollate = c.collcollate) AND
                                                                 (d.datctype = c.collctype))))
  WHERE (d.datname = current_database())
  ORDER BY (char_length((c.collname) :: text)) DESC, c.collname
  LIMIT 1;

alter table information_schema.character_sets
  owner to postgres;

create view information_schema.check_constraint_routine_usage as
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS constraint_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                AS constraint_schema,
         (c.conname) :: information_schema.sql_identifier                                                 AS constraint_name,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name
  FROM pg_namespace nc,
       pg_constraint c,
       pg_depend d,
       pg_proc p,
       pg_namespace np
  WHERE ((nc.oid = c.connamespace) AND (c.contype = 'c' :: "char") AND (c.oid = d.objid) AND
         (d.classid = ('pg_constraint' :: regclass) :: oid) AND (d.refobjid = p.oid) AND
         (d.refclassid = ('pg_proc' :: regclass) :: oid) AND (p.pronamespace = np.oid) AND
         pg_has_role(p.proowner, 'USAGE' :: text));

alter table information_schema.check_constraint_routine_usage
  owner to postgres;

create view information_schema.check_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier                            AS constraint_catalog,
         (rs.nspname) :: information_schema.sql_identifier                                    AS constraint_schema,
         (con.conname) :: information_schema.sql_identifier                                   AS constraint_name,
         ("substring"(pg_get_constraintdef(con.oid), 7)) :: information_schema.character_data AS check_clause
  FROM (((pg_constraint con
      LEFT JOIN pg_namespace rs ON ((rs.oid = con.connamespace)))
      LEFT JOIN pg_class c ON ((c.oid = con.conrelid)))
      LEFT JOIN pg_type t ON ((t.oid = con.contypid)))
  WHERE (pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE' :: text) AND (con.contype = 'c' :: "char"))
  UNION
  SELECT (current_database()) :: information_schema.sql_identifier                              AS constraint_catalog,
         (n.nspname) :: information_schema.sql_identifier                                       AS constraint_schema,
         (((((((n.oid) :: text || '_' :: text) || (r.oid) :: text) || '_' :: text) || (a.attnum) :: text) ||
           '_not_null' :: text)) :: information_schema.sql_identifier                           AS constraint_name,
         (((a.attname) :: text || ' IS NOT NULL' :: text)) :: information_schema.character_data AS check_clause
  FROM pg_namespace n,
       pg_class r,
       pg_attribute a
  WHERE ((n.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (a.attnum > 0) AND (NOT a.attisdropped) AND
         a.attnotnull AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND
         pg_has_role(r.relowner, 'USAGE' :: text));

alter table information_schema.check_constraints
  owner to postgres;

create view information_schema.collations as
  SELECT (current_database()) :: information_schema.sql_identifier            AS collation_catalog,
         (nc.nspname) :: information_schema.sql_identifier                    AS collation_schema,
         (c.collname) :: information_schema.sql_identifier                    AS collation_name,
         ('NO PAD' :: character varying) :: information_schema.character_data AS pad_attribute
  FROM pg_collation c,
       pg_namespace nc
  WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])));

alter table information_schema.collations
  owner to postgres;

create view information_schema.collation_character_set_applicability as
  SELECT (current_database()) :: information_schema.sql_identifier        AS collation_catalog,
         (nc.nspname) :: information_schema.sql_identifier                AS collation_schema,
         (c.collname) :: information_schema.sql_identifier                AS collation_name,
         (NULL :: character varying) :: information_schema.sql_identifier AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier AS character_set_schema,
         (getdatabaseencoding()) :: information_schema.sql_identifier     AS character_set_name
  FROM pg_collation c,
       pg_namespace nc
  WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])));

alter table information_schema.collation_character_set_applicability
  owner to postgres;

create view information_schema.column_domain_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS domain_catalog,
         (nt.nspname) :: information_schema.sql_identifier         AS domain_schema,
         (t.typname) :: information_schema.sql_identifier          AS domain_name,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (c.relname) :: information_schema.sql_identifier          AS table_name,
         (a.attname) :: information_schema.sql_identifier          AS column_name
  FROM pg_type t,
       pg_namespace nt,
       pg_class c,
       pg_namespace nc,
       pg_attribute a
  WHERE ((t.typnamespace = nt.oid) AND (c.relnamespace = nc.oid) AND (a.attrelid = c.oid) AND (a.atttypid = t.oid) AND
         (t.typtype = 'd' :: "char") AND
         (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (a.attnum > 0) AND
         (NOT a.attisdropped) AND pg_has_role(t.typowner, 'USAGE' :: text));

alter table information_schema.column_domain_usage
  owner to postgres;

create view information_schema.column_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier  AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier    AS grantee,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (x.relname) :: information_schema.sql_identifier          AS table_name,
         (x.attname) :: information_schema.sql_identifier          AS column_name,
         (x.prtype) :: information_schema.character_data           AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(x.grantee, x.relowner, 'USAGE' :: text) OR x.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_grantable
  FROM (SELECT pr_c.grantor,
               pr_c.grantee,
               a.attname,
               pr_c.relname,
               pr_c.relnamespace,
               pr_c.prtype,
               pr_c.grantable,
               pr_c.relowner
        FROM (SELECT pg_class.oid,
                     pg_class.relname,
                     pg_class.relnamespace,
                     pg_class.relowner,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantor        AS grantor,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantee        AS grantee,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).privilege_type AS privilege_type,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).is_grantable   AS is_grantable
              FROM pg_class
              WHERE (pg_class.relkind = ANY
                     (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))) pr_c (oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),
             pg_attribute a
        WHERE ((a.attrelid = pr_c.oid) AND (a.attnum > 0) AND (NOT a.attisdropped))
        UNION
        SELECT pr_a.grantor,
               pr_a.grantee,
               pr_a.attname,
               c.relname,
               c.relnamespace,
               pr_a.prtype,
               pr_a.grantable,
               c.relowner
        FROM (SELECT a.attrelid,
                     a.attname,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).grantor        AS grantor,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).grantee        AS grantee,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).privilege_type AS privilege_type,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).is_grantable   AS is_grantable
              FROM (pg_attribute a
                  JOIN pg_class cc ON ((a.attrelid = cc.oid)))
              WHERE ((a.attnum > 0) AND (NOT a.attisdropped))) pr_a (attrelid, attname, grantor, grantee, prtype, grantable),
             pg_class c
        WHERE ((pr_a.attrelid = c.oid) AND
               (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])))) x,
       pg_namespace nc,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((x.relnamespace = nc.oid) AND (x.grantee = grantee.oid) AND (x.grantor = u_grantor.oid) AND
         (x.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text])) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

alter table information_schema.column_privileges
  owner to postgres;

create view information_schema.column_udt_usage as
  SELECT (current_database()) :: information_schema.sql_identifier                AS udt_catalog,
         (COALESCE(nbt.nspname, nt.nspname)) :: information_schema.sql_identifier AS udt_schema,
         (COALESCE(bt.typname, t.typname)) :: information_schema.sql_identifier   AS udt_name,
         (current_database()) :: information_schema.sql_identifier                AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier                        AS table_schema,
         (c.relname) :: information_schema.sql_identifier                         AS table_name,
         (a.attname) :: information_schema.sql_identifier                         AS column_name
  FROM pg_attribute a,
       pg_class c,
       pg_namespace nc,
       ((pg_type t
           JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
           LEFT JOIN (pg_type bt
           JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd' :: "char") AND
                                                                        (t.typbasetype = bt.oid))))
  WHERE ((a.attrelid = c.oid) AND (a.atttypid = t.oid) AND (nc.oid = c.relnamespace) AND (a.attnum > 0) AND
         (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE' :: text));

alter table information_schema.column_udt_usage
  owner to postgres;

create view information_schema.columns as
  SELECT (current_database()) :: information_schema.sql_identifier                                                                           AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                                                   AS table_schema,
         (c.relname) :: information_schema.sql_identifier                                                                                    AS table_name,
         (a.attname) :: information_schema.sql_identifier                                                                                    AS column_name,
         (a.attnum) :: information_schema.cardinal_number                                                                                    AS ordinal_position,
         (pg_get_expr(ad.adbin, ad.adrelid)) :: information_schema.character_data                                                            AS column_default,
         (
             CASE
               WHEN (a.attnotnull OR ((t.typtype = 'd' :: "char") AND t.typnotnull)) THEN 'NO' :: text
               ELSE 'YES' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_nullable,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN CASE
                                                       WHEN ((bt.typelem <> (0) :: oid) AND (bt.typlen = '-1' :: integer))
                                                               THEN 'ARRAY' :: text
                                                       WHEN (nbt.nspname = 'pg_catalog' :: name)
                                                               THEN format_type(t.typbasetype, NULL :: integer)
                                                       ELSE 'USER-DEFINED' :: text
                 END
               ELSE CASE
                      WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
                      WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(a.atttypid, NULL :: integer)
                      ELSE 'USER-DEFINED' :: text
                 END
                 END) :: information_schema.character_data                                                                                   AS data_type,
         (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number         AS character_maximum_length,
         (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS character_octet_length,
         (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS numeric_precision,
         (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                         information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number AS numeric_precision_radix,
         (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number           AS numeric_scale,
         (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                    information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number      AS datetime_precision,
         (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.character_data            AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS interval_precision,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                                                                                  AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                                                                                  AS collation_name,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS domain_catalog,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN nt.nspname
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS domain_schema,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN t.typname
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS domain_name,
         (current_database()) :: information_schema.sql_identifier                                                                           AS udt_catalog,
         (COALESCE(nbt.nspname, nt.nspname)) :: information_schema.sql_identifier                                                            AS udt_schema,
         (COALESCE(bt.typname, t.typname)) :: information_schema.sql_identifier                                                              AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS maximum_cardinality,
         (a.attnum) :: information_schema.sql_identifier                                                                                     AS dtd_identifier,
         ('NO' :: character varying) :: information_schema.yes_or_no                                                                         AS is_self_referencing,
         (
             CASE
               WHEN (a.attidentity = ANY (ARRAY['a'::"char", 'd'::"char"])) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_identity,
         (
             CASE a.attidentity
               WHEN 'a' :: "char" THEN 'ALWAYS' :: text
               WHEN 'd' :: "char" THEN 'BY DEFAULT' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                                                   AS identity_generation,
         (seq.seqstart) :: information_schema.character_data                                                                                 AS identity_start,
         (seq.seqincrement) :: information_schema.character_data                                                                             AS identity_increment,
         (seq.seqmax) :: information_schema.character_data                                                                                   AS identity_maximum,
         (seq.seqmin) :: information_schema.character_data                                                                                   AS identity_minimum,
         (
             CASE
               WHEN seq.seqcycle THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS identity_cycle,
         ('NEVER' :: character varying) :: information_schema.character_data                                                                 AS is_generated,
         (NULL :: character varying) :: information_schema.character_data                                                                    AS generation_expression,
         (
             CASE
               WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR
                     ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND
                      pg_column_is_updatable((c.oid) :: regclass, a.attnum, false))) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_updatable
  FROM ((((((pg_attribute a
      LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
      JOIN (pg_class c
      JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
      JOIN (pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
      LEFT JOIN (pg_type bt
      JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd' :: "char") AND
                                                                   (t.typbasetype = bt.oid))))
      LEFT JOIN (pg_collation co
      JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND
                                                                    ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                     (co.collname <> 'default' :: name)))))
      LEFT JOIN (pg_depend dep
      JOIN pg_sequence seq ON (((dep.classid = ('pg_class' :: regclass) :: oid) AND (dep.objid = seq.seqrelid) AND
                                (dep.deptype = 'i' :: "char")))) ON ((
    (dep.refclassid = ('pg_class' :: regclass) :: oid) AND (dep.refobjid = c.oid) AND (dep.refobjsubid = a.attnum))))
  WHERE ((NOT pg_is_other_temp_schema(nc.oid)) AND (a.attnum > 0) AND (NOT a.attisdropped) AND
         (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR
          has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

alter table information_schema.columns
  owner to postgres;

create view information_schema.constraint_column_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (x.tblschema) :: information_schema.sql_identifier        AS table_schema,
         (x.tblname) :: information_schema.sql_identifier          AS table_name,
         (x.colname) :: information_schema.sql_identifier          AS column_name,
         (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (x.cstrschema) :: information_schema.sql_identifier       AS constraint_schema,
         (x.cstrname) :: information_schema.sql_identifier         AS constraint_name
  FROM (SELECT DISTINCT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname
        FROM pg_namespace nr,
             pg_class r,
             pg_attribute a,
             pg_depend d,
             pg_namespace nc,
             pg_constraint c
        WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND
               (d.refclassid = ('pg_class' :: regclass) :: oid) AND (d.refobjid = r.oid) AND
               (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint' :: regclass) :: oid) AND
               (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c' :: "char") AND
               (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
        UNION ALL
        SELECT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname
        FROM pg_namespace nr,
             pg_class r,
             pg_attribute a,
             pg_namespace nc,
             pg_constraint c
        WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                                                                                                     CASE c.contype
                                                                                                       WHEN 'f' :: "char"
                                                                                                               THEN c.confrelid
                                                                                                       ELSE c.conrelid
                                                                                                         END) AND
               (a.attnum = ANY (
                   CASE c.contype
                     WHEN 'f' :: "char" THEN c.confkey
                     ELSE c.conkey
                       END)) AND (NOT a.attisdropped) AND
               (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND
               (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x (tblschema, tblname, tblowner, colname, cstrschema, cstrname)
  WHERE pg_has_role(x.tblowner, 'USAGE' :: text);

alter table information_schema.constraint_column_usage
  owner to postgres;

create view information_schema.constraint_table_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nr.nspname) :: information_schema.sql_identifier         AS table_schema,
         (r.relname) :: information_schema.sql_identifier          AS table_name,
         (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS constraint_schema,
         (c.conname) :: information_schema.sql_identifier          AS constraint_name
  FROM pg_constraint c,
       pg_namespace nc,
       pg_class r,
       pg_namespace nr
  WHERE ((c.connamespace = nc.oid) AND (r.relnamespace = nr.oid) AND
         (((c.contype = 'f' :: "char") AND (c.confrelid = r.oid)) OR
          ((c.contype = ANY (ARRAY['p'::"char", 'u'::"char"])) AND (c.conrelid = r.oid))) AND
         (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND pg_has_role(r.relowner, 'USAGE' :: text));

alter table information_schema.constraint_table_usage
  owner to postgres;

create view information_schema.domain_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (rs.nspname) :: information_schema.sql_identifier         AS constraint_schema,
         (con.conname) :: information_schema.sql_identifier        AS constraint_name,
         (current_database()) :: information_schema.sql_identifier AS domain_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS domain_schema,
         (t.typname) :: information_schema.sql_identifier          AS domain_name,
         (
             CASE
               WHEN con.condeferrable THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_deferrable,
         (
             CASE
               WHEN con.condeferred THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS initially_deferred
  FROM pg_namespace rs,
       pg_namespace n,
       pg_constraint con,
       pg_type t
  WHERE ((rs.oid = con.connamespace) AND (n.oid = t.typnamespace) AND (t.oid = con.contypid) AND
         (pg_has_role(t.typowner, 'USAGE' :: text) OR has_type_privilege(t.oid, 'USAGE' :: text)));

alter table information_schema.domain_constraints
  owner to postgres;

create view information_schema.domain_udt_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS udt_catalog,
         (nbt.nspname) :: information_schema.sql_identifier        AS udt_schema,
         (bt.typname) :: information_schema.sql_identifier         AS udt_name,
         (current_database()) :: information_schema.sql_identifier AS domain_catalog,
         (nt.nspname) :: information_schema.sql_identifier         AS domain_schema,
         (t.typname) :: information_schema.sql_identifier          AS domain_name
  FROM pg_type t,
       pg_namespace nt,
       pg_type bt,
       pg_namespace nbt
  WHERE ((t.typnamespace = nt.oid) AND (t.typbasetype = bt.oid) AND (bt.typnamespace = nbt.oid) AND
         (t.typtype = 'd' :: "char") AND pg_has_role(bt.typowner, 'USAGE' :: text));

alter table information_schema.domain_udt_usage
  owner to postgres;

create view information_schema.domains as
  SELECT (current_database()) :: information_schema.sql_identifier                                                     AS domain_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                             AS domain_schema,
         (t.typname) :: information_schema.sql_identifier                                                              AS domain_name,
         (
             CASE
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nbt.nspname = 'pg_catalog' :: name) THEN format_type(t.typbasetype, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                             AS data_type,
         (information_schema._pg_char_max_length(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number    AS character_maximum_length,
         (information_schema._pg_char_octet_length(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number  AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                             AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                                                            AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                                                            AS collation_name,
         (information_schema._pg_numeric_precision(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number  AS numeric_precision,
         (information_schema._pg_numeric_precision_radix(t.typbasetype,
                                                         t.typtypmod)) :: information_schema.cardinal_number           AS numeric_precision_radix,
         (information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number      AS numeric_scale,
         (information_schema._pg_datetime_precision(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number AS datetime_precision,
         (information_schema._pg_interval_type(t.typbasetype, t.typtypmod)) :: information_schema.character_data       AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                                       AS interval_precision,
         (t.typdefault) :: information_schema.character_data                                                           AS domain_default,
         (current_database()) :: information_schema.sql_identifier                                                     AS udt_catalog,
         (nbt.nspname) :: information_schema.sql_identifier                                                            AS udt_schema,
         (bt.typname) :: information_schema.sql_identifier                                                             AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                                       AS maximum_cardinality,
         (1) :: information_schema.sql_identifier                                                                      AS dtd_identifier
  FROM (((pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
      JOIN (pg_type bt
      JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typbasetype = bt.oid) AND
                                                                   (t.typtype = 'd' :: "char"))))
      LEFT JOIN (pg_collation co
      JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((t.typcollation = co.oid) AND
                                                                    ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                     (co.collname <> 'default' :: name)))))
  WHERE (pg_has_role(t.typowner, 'USAGE' :: text) OR has_type_privilege(t.oid, 'USAGE' :: text));

alter table information_schema.domains
  owner to postgres;

create view information_schema.enabled_roles as
  SELECT (a.rolname) :: information_schema.sql_identifier AS role_name
  FROM pg_authid a
  WHERE pg_has_role(a.oid, 'USAGE' :: text);

alter table information_schema.enabled_roles
  owner to postgres;

create view information_schema.key_column_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (ss.nc_nspname) :: information_schema.sql_identifier      AS constraint_schema,
         (ss.conname) :: information_schema.sql_identifier         AS constraint_name,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (ss.nr_nspname) :: information_schema.sql_identifier      AS table_schema,
         (ss.relname) :: information_schema.sql_identifier         AS table_name,
         (a.attname) :: information_schema.sql_identifier          AS column_name,
         ((ss.x).n) :: information_schema.cardinal_number          AS ordinal_position,
         (
             CASE
               WHEN (ss.contype = 'f' :: "char")
                       THEN information_schema._pg_index_position(ss.conindid, ss.confkey [ (ss.x).n ])
               ELSE NULL :: integer
                 END) :: information_schema.cardinal_number        AS position_in_unique_constraint
  FROM pg_attribute a,
       (SELECT r.oid                                        AS roid,
               r.relname,
               r.relowner,
               nc.nspname                                   AS nc_nspname,
               nr.nspname                                   AS nr_nspname,
               c.oid                                        AS coid,
               c.conname,
               c.contype,
               c.conindid,
               c.confkey,
               c.confrelid,
               information_schema._pg_expandarray(c.conkey) AS x
        FROM pg_namespace nr,
             pg_class r,
             pg_namespace nc,
             pg_constraint c
        WHERE ((nr.oid = r.relnamespace) AND (r.oid = c.conrelid) AND (nc.oid = c.connamespace) AND
               (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND
               (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)))) ss
  WHERE ((ss.roid = a.attrelid) AND (a.attnum = (ss.x).x) AND (NOT a.attisdropped) AND
         (pg_has_role(ss.relowner, 'USAGE' :: text) OR
          has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

alter table information_schema.key_column_usage
  owner to postgres;

create view information_schema.parameters as
  SELECT (current_database()) :: information_schema.sql_identifier                                            AS specific_catalog,
         (ss.n_nspname) :: information_schema.sql_identifier                                                  AS specific_schema,
         ((((ss.proname) :: text || '_' :: text) || (ss.p_oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         ((ss.x).n) :: information_schema.cardinal_number                                                     AS ordinal_position,
         (
             CASE
               WHEN (ss.proargmodes IS NULL) THEN 'IN' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'i' :: "char") THEN 'IN' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'o' :: "char") THEN 'OUT' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'b' :: "char") THEN 'INOUT' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'v' :: "char") THEN 'IN' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 't' :: "char") THEN 'OUT' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                    AS parameter_mode,
         ('NO' :: character varying) :: information_schema.yes_or_no                                          AS is_result,
         ('NO' :: character varying) :: information_schema.yes_or_no                                          AS as_locator,
         (NULLIF(ss.proargnames [ (ss.x).n ], '' :: text)) :: information_schema.sql_identifier               AS parameter_name,
         (
             CASE
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(t.oid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                    AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS character_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data                                     AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS interval_precision,
         (current_database()) :: information_schema.sql_identifier                                            AS udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                    AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                     AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS maximum_cardinality,
         ((ss.x).n) :: information_schema.sql_identifier                                                      AS dtd_identifier,
         (
             CASE
               WHEN pg_has_role(ss.proowner, 'USAGE' :: text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                    AS parameter_default
  FROM pg_type t,
       pg_namespace nt,
       (SELECT n.nspname                                                                                 AS n_nspname,
               p.proname,
               p.oid                                                                                     AS p_oid,
               p.proowner,
               p.proargnames,
               p.proargmodes,
               information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes) :: oid [])) AS x
        FROM pg_namespace n,
             pg_proc p
        WHERE ((n.oid = p.pronamespace) AND
               (pg_has_role(p.proowner, 'USAGE' :: text) OR has_function_privilege(p.oid, 'EXECUTE' :: text)))) ss
  WHERE ((t.oid = (ss.x).x) AND (t.typnamespace = nt.oid));

alter table information_schema.parameters
  owner to postgres;

create view information_schema.referential_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (ncon.nspname) :: information_schema.sql_identifier       AS constraint_schema,
         (con.conname) :: information_schema.sql_identifier        AS constraint_name,
         (
             CASE
               WHEN (npkc.nspname IS NULL) THEN NULL :: name
               ELSE current_database()
                 END) :: information_schema.sql_identifier         AS unique_constraint_catalog,
         (npkc.nspname) :: information_schema.sql_identifier       AS unique_constraint_schema,
         (pkc.conname) :: information_schema.sql_identifier        AS unique_constraint_name,
         (
             CASE con.confmatchtype
               WHEN 'f' :: "char" THEN 'FULL' :: text
               WHEN 'p' :: "char" THEN 'PARTIAL' :: text
               WHEN 's' :: "char" THEN 'NONE' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS match_option,
         (
             CASE con.confupdtype
               WHEN 'c' :: "char" THEN 'CASCADE' :: text
               WHEN 'n' :: "char" THEN 'SET NULL' :: text
               WHEN 'd' :: "char" THEN 'SET DEFAULT' :: text
               WHEN 'r' :: "char" THEN 'RESTRICT' :: text
               WHEN 'a' :: "char" THEN 'NO ACTION' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS update_rule,
         (
             CASE con.confdeltype
               WHEN 'c' :: "char" THEN 'CASCADE' :: text
               WHEN 'n' :: "char" THEN 'SET NULL' :: text
               WHEN 'd' :: "char" THEN 'SET DEFAULT' :: text
               WHEN 'r' :: "char" THEN 'RESTRICT' :: text
               WHEN 'a' :: "char" THEN 'NO ACTION' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS delete_rule
  FROM ((((((pg_namespace ncon
      JOIN pg_constraint con ON ((ncon.oid = con.connamespace)))
      JOIN pg_class c ON (((con.conrelid = c.oid) AND (con.contype = 'f' :: "char"))))
      LEFT JOIN pg_depend d1 ON (((d1.objid = con.oid) AND (d1.classid = ('pg_constraint' :: regclass) :: oid) AND
                                  (d1.refclassid = ('pg_class' :: regclass) :: oid) AND (d1.refobjsubid = 0))))
      LEFT JOIN pg_depend d2 ON ((
    (d2.refclassid = ('pg_constraint' :: regclass) :: oid) AND (d2.classid = ('pg_class' :: regclass) :: oid) AND
    (d2.objid = d1.refobjid) AND (d2.objsubid = 0) AND (d2.deptype = 'i' :: "char"))))
      LEFT JOIN pg_constraint pkc ON ((
    (pkc.oid = d2.refobjid) AND (pkc.contype = ANY (ARRAY ['p' :: "char", 'u' :: "char"])) AND
    (pkc.conrelid = con.confrelid))))
      LEFT JOIN pg_namespace npkc ON ((pkc.connamespace = npkc.oid)))
  WHERE (pg_has_role(c.relowner, 'USAGE' :: text) OR
         has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
         has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES' :: text));

alter table information_schema.referential_constraints
  owner to postgres;

create view information_schema.role_column_grants as
  SELECT column_privileges.grantor,
         column_privileges.grantee,
         column_privileges.table_catalog,
         column_privileges.table_schema,
         column_privileges.table_name,
         column_privileges.column_name,
         column_privileges.privilege_type,
         column_privileges.is_grantable
  FROM information_schema.column_privileges
  WHERE (((column_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((column_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

alter table information_schema.role_column_grants
  owner to postgres;

create view information_schema.routine_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                                         AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                                           AS grantee,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (current_database()) :: information_schema.sql_identifier                                        AS routine_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS routine_schema,
         (p.proname) :: information_schema.sql_identifier                                                 AS routine_name,
         ('EXECUTE' :: character varying) :: information_schema.character_data                            AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, p.proowner, 'USAGE' :: text) OR p.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                     AS is_grantable
  FROM (SELECT pg_proc.oid,
               pg_proc.proname,
               pg_proc.proowner,
               pg_proc.pronamespace,
               (aclexplode(COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).is_grantable     AS is_grantable
        FROM pg_proc) p (oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((p.pronamespace = n.oid) AND (grantee.oid = p.grantee) AND (u_grantor.oid = p.grantor) AND
         (p.prtype = 'EXECUTE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

alter table information_schema.routine_privileges
  owner to postgres;

create view information_schema.role_routine_grants as
  SELECT routine_privileges.grantor,
         routine_privileges.grantee,
         routine_privileges.specific_catalog,
         routine_privileges.specific_schema,
         routine_privileges.specific_name,
         routine_privileges.routine_catalog,
         routine_privileges.routine_schema,
         routine_privileges.routine_name,
         routine_privileges.privilege_type,
         routine_privileges.is_grantable
  FROM information_schema.routine_privileges
  WHERE (((routine_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((routine_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

alter table information_schema.role_routine_grants
  owner to postgres;

create view information_schema.routines as
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (current_database()) :: information_schema.sql_identifier                                        AS routine_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS routine_schema,
         (p.proname) :: information_schema.sql_identifier                                                 AS routine_name,
         ('FUNCTION' :: character varying) :: information_schema.character_data                           AS routine_type,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS module_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS module_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS module_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS udt_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS udt_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS udt_name,
         (
             CASE
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(t.oid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS character_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data                                 AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS interval_precision,
         (current_database()) :: information_schema.sql_identifier                                        AS type_udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                AS type_udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                 AS type_udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS maximum_cardinality,
         (0) :: information_schema.sql_identifier                                                         AS dtd_identifier,
         (
             CASE
               WHEN (l.lanname = 'sql' :: name) THEN 'SQL' :: text
               ELSE 'EXTERNAL' :: text
                 END) :: information_schema.character_data                                                AS routine_body,
         (
             CASE
               WHEN pg_has_role(p.proowner, 'USAGE' :: text) THEN p.prosrc
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                AS routine_definition,
         (
             CASE
               WHEN (l.lanname = 'c' :: name) THEN p.prosrc
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                AS external_name,
         (upper((l.lanname) :: text)) :: information_schema.character_data                                AS external_language,
         ('GENERAL' :: character varying) :: information_schema.character_data                            AS parameter_style,
         (
             CASE
               WHEN (p.provolatile = 'i' :: "char") THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                     AS is_deterministic,
         ('MODIFIES' :: character varying) :: information_schema.character_data                           AS sql_data_access,
         (
             CASE
               WHEN p.proisstrict THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                     AS is_null_call,
         (NULL :: character varying) :: information_schema.character_data                                 AS sql_path,
         ('YES' :: character varying) :: information_schema.yes_or_no                                     AS schema_level_routine,
         (0) :: information_schema.cardinal_number                                                        AS max_dynamic_result_sets,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS is_user_defined_cast,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS is_implicitly_invocable,
         (
             CASE
               WHEN p.prosecdef THEN 'DEFINER' :: text
               ELSE 'INVOKER' :: text
                 END) :: information_schema.character_data                                                AS security_type,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS to_sql_specific_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS to_sql_specific_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS to_sql_specific_name,
         ('NO' :: character varying) :: information_schema.yes_or_no                                      AS as_locator,
         (NULL :: timestamp with time zone) :: information_schema.time_stamp                              AS created,
         (NULL :: timestamp with time zone) :: information_schema.time_stamp                              AS last_altered,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS new_savepoint_level,
         ('NO' :: character varying) :: information_schema.yes_or_no                                      AS is_udt_dependent,
         (NULL :: character varying) :: information_schema.character_data                                 AS result_cast_from_data_type,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS result_cast_as_locator,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_char_max_length,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_char_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_char_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_char_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_char_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_datetime_precision,
         (NULL :: character varying) :: information_schema.character_data                                 AS result_cast_interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_interval_precision,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_type_udt_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_type_udt_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_type_udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_maximum_cardinality,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_dtd_identifier
  FROM pg_namespace n,
       pg_proc p,
       pg_language l,
       pg_type t,
       pg_namespace nt
  WHERE ((n.oid = p.pronamespace) AND (p.prolang = l.oid) AND (p.prorettype = t.oid) AND (t.typnamespace = nt.oid) AND
         (pg_has_role(p.proowner, 'USAGE' :: text) OR has_function_privilege(p.oid, 'EXECUTE' :: text)));

alter table information_schema.routines
  owner to postgres;

create view information_schema.schemata as
  SELECT (current_database()) :: information_schema.sql_identifier        AS catalog_name,
         (n.nspname) :: information_schema.sql_identifier                 AS schema_name,
         (u.rolname) :: information_schema.sql_identifier                 AS schema_owner,
         (NULL :: character varying) :: information_schema.sql_identifier AS default_character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier AS default_character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier AS default_character_set_name,
         (NULL :: character varying) :: information_schema.character_data AS sql_path
  FROM pg_namespace n,
       pg_authid u
  WHERE ((n.nspowner = u.oid) AND
         (pg_has_role(n.nspowner, 'USAGE' :: text) OR has_schema_privilege(n.oid, 'CREATE, USAGE' :: text)));

alter table information_schema.schemata
  owner to postgres;

create view information_schema.sequences as
  SELECT (current_database()) :: information_schema.sql_identifier                                                     AS sequence_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                             AS sequence_schema,
         (c.relname) :: information_schema.sql_identifier                                                              AS sequence_name,
         (format_type(s.seqtypid, NULL :: integer)) :: information_schema.character_data                               AS data_type,
         (information_schema._pg_numeric_precision(s.seqtypid, '-1' :: integer)) :: information_schema.cardinal_number AS numeric_precision,
         (2) :: information_schema.cardinal_number                                                                     AS numeric_precision_radix,
         (0) :: information_schema.cardinal_number                                                                     AS numeric_scale,
         (s.seqstart) :: information_schema.character_data                                                             AS start_value,
         (s.seqmin) :: information_schema.character_data                                                               AS minimum_value,
         (s.seqmax) :: information_schema.character_data                                                               AS maximum_value,
         (s.seqincrement) :: information_schema.character_data                                                         AS increment,
         (
             CASE
               WHEN s.seqcycle THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                  AS cycle_option
  FROM pg_namespace nc,
       pg_class c,
       pg_sequence s
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'S' :: "char") AND (NOT (EXISTS(SELECT 1
                                                                                    FROM pg_depend
                                                                                    WHERE ((pg_depend.classid = ('pg_class' :: regclass) :: oid) AND
                                                                                           (pg_depend.objid = c.oid) AND
                                                                                           (pg_depend.deptype = 'i' :: "char"))))) AND
         (NOT pg_is_other_temp_schema(nc.oid)) AND (c.oid = s.seqrelid) AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE' :: text)));

alter table information_schema.sequences
  owner to postgres;

create view information_schema.table_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS constraint_schema,
         (c.conname) :: information_schema.sql_identifier          AS constraint_name,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nr.nspname) :: information_schema.sql_identifier         AS table_schema,
         (r.relname) :: information_schema.sql_identifier          AS table_name,
         (
             CASE c.contype
               WHEN 'c' :: "char" THEN 'CHECK' :: text
               WHEN 'f' :: "char" THEN 'FOREIGN KEY' :: text
               WHEN 'p' :: "char" THEN 'PRIMARY KEY' :: text
               WHEN 'u' :: "char" THEN 'UNIQUE' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS constraint_type,
         (
             CASE
               WHEN c.condeferrable THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_deferrable,
         (
             CASE
               WHEN c.condeferred THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS initially_deferred
  FROM pg_namespace nc,
       pg_namespace nr,
       pg_constraint c,
       pg_class r
  WHERE ((nc.oid = c.connamespace) AND (nr.oid = r.relnamespace) AND (c.conrelid = r.oid) AND
         (c.contype <> ALL (ARRAY['t'::"char", 'x'::"char"])) AND
         (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)) AND
         (pg_has_role(r.relowner, 'USAGE' :: text) OR
          has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
          has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES' :: text)))
  UNION ALL
  SELECT (current_database()) :: information_schema.sql_identifier           AS constraint_catalog,
         (nr.nspname) :: information_schema.sql_identifier                   AS constraint_schema,
         (((((((nr.oid) :: text || '_' :: text) || (r.oid) :: text) || '_' :: text) || (a.attnum) :: text) ||
           '_not_null' :: text)) :: information_schema.sql_identifier        AS constraint_name,
         (current_database()) :: information_schema.sql_identifier           AS table_catalog,
         (nr.nspname) :: information_schema.sql_identifier                   AS table_schema,
         (r.relname) :: information_schema.sql_identifier                    AS table_name,
         ('CHECK' :: character varying) :: information_schema.character_data AS constraint_type,
         ('NO' :: character varying) :: information_schema.yes_or_no         AS is_deferrable,
         ('NO' :: character varying) :: information_schema.yes_or_no         AS initially_deferred
  FROM pg_namespace nr,
       pg_class r,
       pg_attribute a
  WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND a.attnotnull AND (a.attnum > 0) AND
         (NOT a.attisdropped) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND
         (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE' :: text) OR
                                                    has_table_privilege(r.oid,
                                                                        'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                    has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES' :: text)));

alter table information_schema.table_constraints
  owner to postgres;

create view information_schema.table_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier  AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier    AS grantee,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (c.relname) :: information_schema.sql_identifier          AS table_name,
         (c.prtype) :: information_schema.character_data           AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE' :: text) OR c.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_grantable,
         (
             CASE
               WHEN (c.prtype = 'SELECT' :: text) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS with_hierarchy
  FROM (SELECT pg_class.oid,
               pg_class.relname,
               pg_class.relnamespace,
               pg_class.relkind,
               pg_class.relowner,
               (aclexplode(COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).is_grantable     AS is_grantable
        FROM pg_class) c (oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
       pg_namespace nc,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         (c.grantee = grantee.oid) AND (c.grantor = u_grantor.oid) AND (c.prtype = ANY
                                                                        (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text])) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

alter table information_schema.table_privileges
  owner to postgres;

create view information_schema.role_table_grants as
  SELECT table_privileges.grantor,
         table_privileges.grantee,
         table_privileges.table_catalog,
         table_privileges.table_schema,
         table_privileges.table_name,
         table_privileges.privilege_type,
         table_privileges.is_grantable,
         table_privileges.with_hierarchy
  FROM information_schema.table_privileges
  WHERE (((table_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((table_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

alter table information_schema.role_table_grants
  owner to postgres;

create view information_schema.tables as
  SELECT (current_database()) :: information_schema.sql_identifier        AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier                AS table_schema,
         (c.relname) :: information_schema.sql_identifier                 AS table_name,
         (
             CASE
               WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY' :: text
               WHEN (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) THEN 'BASE TABLE' :: text
               WHEN (c.relkind = 'v' :: "char") THEN 'VIEW' :: text
               WHEN (c.relkind = 'f' :: "char") THEN 'FOREIGN TABLE' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data                AS table_type,
         (NULL :: character varying) :: information_schema.sql_identifier AS self_referencing_column_name,
         (NULL :: character varying) :: information_schema.character_data AS reference_generation,
         (
             CASE
               WHEN (t.typname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                AS user_defined_type_catalog,
         (nt.nspname) :: information_schema.sql_identifier                AS user_defined_type_schema,
         (t.typname) :: information_schema.sql_identifier                 AS user_defined_type_name,
         (
             CASE
               WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR
                     ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND
                      ((pg_relation_is_updatable((c.oid) :: regclass, false) & 8) = 8))) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                     AS is_insertable_into,
         (
             CASE
               WHEN (t.typname IS NOT NULL) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                     AS is_typed,
         (NULL :: character varying) :: information_schema.character_data AS commit_action
  FROM ((pg_namespace nc
      JOIN pg_class c ON ((nc.oid = c.relnamespace)))
      LEFT JOIN (pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                    has_table_privilege(c.oid,
                                                                        'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                    has_any_column_privilege(c.oid,
                                                                             'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

alter table information_schema.tables
  owner to postgres;

create view information_schema.transforms as
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                 AS udt_name,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (l.lanname) :: information_schema.sql_identifier                                                 AS group_name,
         ('FROM SQL' :: character varying) :: information_schema.character_data                           AS transform_type
  FROM (((((pg_type t
      JOIN pg_transform x ON ((t.oid = x.trftype)))
      JOIN pg_language l ON ((x.trflang = l.oid)))
      JOIN pg_proc p ON (((x.trffromsql) :: oid = p.oid)))
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
      JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
  UNION
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                 AS udt_name,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (l.lanname) :: information_schema.sql_identifier                                                 AS group_name,
         ('TO SQL' :: character varying) :: information_schema.character_data                             AS transform_type
  FROM (((((pg_type t
      JOIN pg_transform x ON ((t.oid = x.trftype)))
      JOIN pg_language l ON ((x.trflang = l.oid)))
      JOIN pg_proc p ON (((x.trftosql) :: oid = p.oid)))
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
      JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
  ORDER BY 1, 2, 3, 7, 8;

alter table information_schema.transforms
  owner to postgres;

create view information_schema.triggered_update_columns as
  SELECT (current_database()) :: information_schema.sql_identifier AS trigger_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS trigger_schema,
         (t.tgname) :: information_schema.sql_identifier           AS trigger_name,
         (current_database()) :: information_schema.sql_identifier AS event_object_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS event_object_schema,
         (c.relname) :: information_schema.sql_identifier          AS event_object_table,
         (a.attname) :: information_schema.sql_identifier          AS event_object_column
  FROM pg_namespace n,
       pg_class c,
       pg_trigger t,
       (SELECT ta0.tgoid, (ta0.tgat).x AS tgattnum, (ta0.tgat).n AS tgattpos
        FROM (SELECT pg_trigger.oid AS tgoid, information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat
              FROM pg_trigger) ta0) ta,
       pg_attribute a
  WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (t.oid = ta.tgoid) AND
         ((a.attrelid = t.tgrelid) AND (a.attnum = ta.tgattnum)) AND (NOT t.tgisinternal) AND
         (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                   has_column_privilege(c.oid, a.attnum,
                                                                        'INSERT, UPDATE, REFERENCES' :: text)));

alter table information_schema.triggered_update_columns
  owner to postgres;

create view information_schema.triggers as
  SELECT (current_database()) :: information_schema.sql_identifier           AS trigger_catalog,
         (n.nspname) :: information_schema.sql_identifier                    AS trigger_schema,
         (t.tgname) :: information_schema.sql_identifier                     AS trigger_name,
         (em.text) :: information_schema.character_data                      AS event_manipulation,
         (current_database()) :: information_schema.sql_identifier           AS event_object_catalog,
         (n.nspname) :: information_schema.sql_identifier                    AS event_object_schema,
         (c.relname) :: information_schema.sql_identifier                    AS event_object_table,
         (NULL :: integer) :: information_schema.cardinal_number             AS action_order,
         (
             CASE
               WHEN pg_has_role(c.relowner, 'USAGE' :: text) THEN
                 (regexp_match(pg_get_triggerdef(t.oid), '.{35,} WHEN \((.+)\) EXECUTE PROCEDURE' :: text)) [ 1 ]
               ELSE NULL :: text
                 END) :: information_schema.character_data                   AS action_condition,
         ("substring"(pg_get_triggerdef(t.oid),
                      ("position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE' :: text) +
                       47))) :: information_schema.character_data            AS action_statement,
         (
             CASE ((t.tgtype) :: integer & 1)
               WHEN 1 THEN 'ROW' :: text
               ELSE 'STATEMENT' :: text
                 END) :: information_schema.character_data                   AS action_orientation,
         (
             CASE ((t.tgtype) :: integer & 66)
               WHEN 2 THEN 'BEFORE' :: text
               WHEN 64 THEN 'INSTEAD OF' :: text
               ELSE 'AFTER' :: text
                 END) :: information_schema.character_data                   AS action_timing,
         (NULL :: character varying) :: information_schema.sql_identifier    AS action_reference_old_table,
         (NULL :: character varying) :: information_schema.sql_identifier    AS action_reference_new_table,
         (NULL :: character varying) :: information_schema.sql_identifier    AS action_reference_old_row,
         (NULL :: character varying) :: information_schema.sql_identifier    AS action_reference_new_row,
         (NULL :: timestamp with time zone) :: information_schema.time_stamp AS created
  FROM pg_namespace n,
       pg_class c,
       pg_trigger t,
       (VALUES (4, 'INSERT' :: text),
               (8, 'DELETE' :: text),
               (16, 'UPDATE' :: text)) em (num, text)
  WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (((t.tgtype) :: integer & em.num) <> 0) AND
         (NOT t.tgisinternal) AND (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                                            has_table_privilege(c.oid,
                                                                                                'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                                            has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES' :: text)));

alter table information_schema.triggers
  owner to postgres;

create view information_schema.udt_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                 AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                   AS grantee,
         (current_database()) :: information_schema.sql_identifier                AS udt_catalog,
         (n.nspname) :: information_schema.sql_identifier                         AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                         AS udt_name,
         ('TYPE USAGE' :: character varying) :: information_schema.character_data AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE' :: text) OR t.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                             AS is_grantable
  FROM (SELECT pg_type.oid,
               pg_type.typname,
               pg_type.typnamespace,
               pg_type.typtype,
               pg_type.typowner,
               (aclexplode(COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).is_grantable     AS is_grantable
        FROM pg_type) t (oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'c' :: "char") AND (t.grantee = grantee.oid) AND
         (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

alter table information_schema.udt_privileges
  owner to postgres;

create view information_schema.role_udt_grants as
  SELECT udt_privileges.grantor,
         udt_privileges.grantee,
         udt_privileges.udt_catalog,
         udt_privileges.udt_schema,
         udt_privileges.udt_name,
         udt_privileges.privilege_type,
         udt_privileges.is_grantable
  FROM information_schema.udt_privileges
  WHERE (((udt_privileges.grantor) :: text IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((udt_privileges.grantee) :: text IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

alter table information_schema.role_udt_grants
  owner to postgres;

create view information_schema.usage_privileges as
  SELECT (u.rolname) :: information_schema.sql_identifier                        AS grantor,
         ('PUBLIC' :: character varying) :: information_schema.sql_identifier    AS grantee,
         (current_database()) :: information_schema.sql_identifier               AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                        AS object_schema,
         (c.collname) :: information_schema.sql_identifier                       AS object_name,
         ('COLLATION' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data     AS privilege_type,
         ('NO' :: character varying) :: information_schema.yes_or_no             AS is_grantable
  FROM pg_authid u,
       pg_namespace n,
       pg_collation c
  WHERE ((u.oid = c.collowner) AND (c.collnamespace = n.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier             AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier               AS grantee,
         (current_database()) :: information_schema.sql_identifier            AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                     AS object_schema,
         (t.typname) :: information_schema.sql_identifier                     AS object_name,
         ('DOMAIN' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data  AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE' :: text) OR t.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                         AS is_grantable
  FROM (SELECT pg_type.oid,
               pg_type.typname,
               pg_type.typnamespace,
               pg_type.typtype,
               pg_type.typowner,
               (aclexplode(COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).is_grantable     AS is_grantable
        FROM pg_type) t (oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'd' :: "char") AND (t.grantee = grantee.oid) AND
         (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                           AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                             AS grantee,
         (current_database()) :: information_schema.sql_identifier                          AS object_catalog,
         ('' :: character varying) :: information_schema.sql_identifier                     AS object_schema,
         (fdw.fdwname) :: information_schema.sql_identifier                                 AS object_name,
         ('FOREIGN DATA WRAPPER' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data                AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE' :: text) OR fdw.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                       AS is_grantable
  FROM (SELECT pg_foreign_data_wrapper.fdwname,
               pg_foreign_data_wrapper.fdwowner,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).grantor        AS grantor,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).grantee        AS grantee,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).is_grantable   AS is_grantable
        FROM pg_foreign_data_wrapper) fdw (fdwname, fdwowner, grantor, grantee, prtype, grantable),
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((u_grantor.oid = fdw.grantor) AND (grantee.oid = fdw.grantee) AND (fdw.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                     AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                       AS grantee,
         (current_database()) :: information_schema.sql_identifier                    AS object_catalog,
         ('' :: character varying) :: information_schema.sql_identifier               AS object_schema,
         (srv.srvname) :: information_schema.sql_identifier                           AS object_name,
         ('FOREIGN SERVER' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data          AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, srv.srvowner, 'USAGE' :: text) OR srv.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                 AS is_grantable
  FROM (SELECT pg_foreign_server.srvname,
               pg_foreign_server.srvowner,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).grantor        AS grantor,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).grantee        AS grantee,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).is_grantable   AS is_grantable
        FROM pg_foreign_server) srv (srvname, srvowner, grantor, grantee, prtype, grantable),
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((u_grantor.oid = srv.grantor) AND (grantee.oid = srv.grantee) AND (srv.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier               AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                 AS grantee,
         (current_database()) :: information_schema.sql_identifier              AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                       AS object_schema,
         (c.relname) :: information_schema.sql_identifier                       AS object_name,
         ('SEQUENCE' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data    AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE' :: text) OR c.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                           AS is_grantable
  FROM (SELECT pg_class.oid,
               pg_class.relname,
               pg_class.relnamespace,
               pg_class.relkind,
               pg_class.relowner,
               (aclexplode(COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).is_grantable     AS is_grantable
        FROM pg_class) c (oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((c.relnamespace = n.oid) AND (c.relkind = 'S' :: "char") AND (c.grantee = grantee.oid) AND
         (c.grantor = u_grantor.oid) AND (c.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

alter table information_schema.usage_privileges
  owner to postgres;

create view information_schema.role_usage_grants as
  SELECT usage_privileges.grantor,
         usage_privileges.grantee,
         usage_privileges.object_catalog,
         usage_privileges.object_schema,
         usage_privileges.object_name,
         usage_privileges.object_type,
         usage_privileges.privilege_type,
         usage_privileges.is_grantable
  FROM information_schema.usage_privileges
  WHERE (((usage_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((usage_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

alter table information_schema.role_usage_grants
  owner to postgres;

create view information_schema.user_defined_types as
  SELECT (current_database()) :: information_schema.sql_identifier                AS user_defined_type_catalog,
         (n.nspname) :: information_schema.sql_identifier                         AS user_defined_type_schema,
         (c.relname) :: information_schema.sql_identifier                         AS user_defined_type_name,
         ('STRUCTURED' :: character varying) :: information_schema.character_data AS user_defined_type_category,
         ('YES' :: character varying) :: information_schema.yes_or_no             AS is_instantiable,
         (NULL :: character varying) :: information_schema.yes_or_no              AS is_final,
         (NULL :: character varying) :: information_schema.character_data         AS ordering_form,
         (NULL :: character varying) :: information_schema.character_data         AS ordering_category,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ordering_routine_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ordering_routine_schema,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ordering_routine_name,
         (NULL :: character varying) :: information_schema.character_data         AS reference_type,
         (NULL :: character varying) :: information_schema.character_data         AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                  AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                  AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier         AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier         AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier         AS character_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier         AS collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier         AS collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier         AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                  AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                  AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                  AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                  AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data         AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                  AS interval_precision,
         (NULL :: character varying) :: information_schema.sql_identifier         AS source_dtd_identifier,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ref_dtd_identifier
  FROM pg_namespace n,
       pg_class c,
       pg_type t
  WHERE ((n.oid = c.relnamespace) AND (t.typrelid = c.oid) AND (c.relkind = 'c' :: "char") AND
         (pg_has_role(t.typowner, 'USAGE' :: text) OR has_type_privilege(t.oid, 'USAGE' :: text)));

alter table information_schema.user_defined_types
  owner to postgres;

create view information_schema.view_column_usage as
  SELECT DISTINCT (current_database()) :: information_schema.sql_identifier AS view_catalog,
                  (nv.nspname) :: information_schema.sql_identifier         AS view_schema,
                  (v.relname) :: information_schema.sql_identifier          AS view_name,
                  (current_database()) :: information_schema.sql_identifier AS table_catalog,
                  (nt.nspname) :: information_schema.sql_identifier         AS table_schema,
                  (t.relname) :: information_schema.sql_identifier          AS table_name,
                  (a.attname) :: information_schema.sql_identifier          AS column_name
  FROM pg_namespace nv,
       pg_class v,
       pg_depend dv,
       pg_depend dt,
       pg_class t,
       pg_namespace nt,
       pg_attribute a
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v' :: "char") AND (v.oid = dv.refobjid) AND
         (dv.refclassid = ('pg_class' :: regclass) :: oid) AND (dv.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dv.deptype = 'i' :: "char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND
         (dt.classid = ('pg_rewrite' :: regclass) :: oid) AND (dt.refclassid = ('pg_class' :: regclass) :: oid) AND
         (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND
         (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (t.oid = a.attrelid) AND
         (dt.refobjsubid = a.attnum) AND pg_has_role(t.relowner, 'USAGE' :: text));

alter table information_schema.view_column_usage
  owner to postgres;

create view information_schema.view_routine_usage as
  SELECT DISTINCT (current_database()) :: information_schema.sql_identifier                                        AS table_catalog,
                  (nv.nspname) :: information_schema.sql_identifier                                                AS table_schema,
                  (v.relname) :: information_schema.sql_identifier                                                 AS table_name,
                  (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
                  (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
                  ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name
  FROM pg_namespace nv,
       pg_class v,
       pg_depend dv,
       pg_depend dp,
       pg_proc p,
       pg_namespace np
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v' :: "char") AND (v.oid = dv.refobjid) AND
         (dv.refclassid = ('pg_class' :: regclass) :: oid) AND (dv.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dv.deptype = 'i' :: "char") AND (dv.objid = dp.objid) AND (dp.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dp.refclassid = ('pg_proc' :: regclass) :: oid) AND (dp.refobjid = p.oid) AND (p.pronamespace = np.oid) AND
         pg_has_role(p.proowner, 'USAGE' :: text));

alter table information_schema.view_routine_usage
  owner to postgres;

create view information_schema.view_table_usage as
  SELECT DISTINCT (current_database()) :: information_schema.sql_identifier AS view_catalog,
                  (nv.nspname) :: information_schema.sql_identifier         AS view_schema,
                  (v.relname) :: information_schema.sql_identifier          AS view_name,
                  (current_database()) :: information_schema.sql_identifier AS table_catalog,
                  (nt.nspname) :: information_schema.sql_identifier         AS table_schema,
                  (t.relname) :: information_schema.sql_identifier          AS table_name
  FROM pg_namespace nv,
       pg_class v,
       pg_depend dv,
       pg_depend dt,
       pg_class t,
       pg_namespace nt
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v' :: "char") AND (v.oid = dv.refobjid) AND
         (dv.refclassid = ('pg_class' :: regclass) :: oid) AND (dv.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dv.deptype = 'i' :: "char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND
         (dt.classid = ('pg_rewrite' :: regclass) :: oid) AND (dt.refclassid = ('pg_class' :: regclass) :: oid) AND
         (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND
         (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         pg_has_role(t.relowner, 'USAGE' :: text));

alter table information_schema.view_table_usage
  owner to postgres;

create view information_schema.views as
  SELECT (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (c.relname) :: information_schema.sql_identifier          AS table_name,
         (
             CASE
               WHEN pg_has_role(c.relowner, 'USAGE' :: text) THEN pg_get_viewdef(c.oid)
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS view_definition,
         (
             CASE
               WHEN ('check_option=cascaded' :: text = ANY (c.reloptions)) THEN 'CASCADED' :: text
               WHEN ('check_option=local' :: text = ANY (c.reloptions)) THEN 'LOCAL' :: text
               ELSE 'NONE' :: text
                 END) :: information_schema.character_data         AS check_option,
         (
             CASE
               WHEN ((pg_relation_is_updatable((c.oid) :: regclass, false) & 20) = 20) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_updatable,
         (
             CASE
               WHEN ((pg_relation_is_updatable((c.oid) :: regclass, false) & 8) = 8) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_insertable_into,
         (
             CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype) :: integer & 81) = 81))))
                       THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_trigger_updatable,
         (
             CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype) :: integer & 73) = 73))))
                       THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_trigger_deletable,
         (
             CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype) :: integer & 69) = 69))))
                       THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_trigger_insertable_into
  FROM pg_namespace nc,
       pg_class c
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'v' :: "char") AND (NOT pg_is_other_temp_schema(nc.oid)) AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR
          has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
          has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

alter table information_schema.views
  owner to postgres;

create view information_schema.data_type_privileges as
  SELECT (current_database()) :: information_schema.sql_identifier AS object_catalog,
         x.objschema                                               AS object_schema,
         x.objname                                                 AS object_name,
         (x.objtype) :: information_schema.character_data          AS object_type,
         x.objdtdid                                                AS dtd_identifier
  FROM (SELECT attributes.udt_schema,
               attributes.udt_name,
               'USER-DEFINED TYPE' :: text AS text,
               attributes.dtd_identifier
        FROM information_schema.attributes
        UNION ALL
        SELECT columns.table_schema, columns.table_name, 'TABLE' :: text AS text, columns.dtd_identifier
        FROM information_schema.columns
        UNION ALL
        SELECT domains.domain_schema, domains.domain_name, 'DOMAIN' :: text AS text, domains.dtd_identifier
        FROM information_schema.domains
        UNION ALL
        SELECT parameters.specific_schema,
               parameters.specific_name,
               'ROUTINE' :: text AS text,
               parameters.dtd_identifier
        FROM information_schema.parameters
        UNION ALL
        SELECT routines.specific_schema, routines.specific_name, 'ROUTINE' :: text AS text, routines.dtd_identifier
        FROM information_schema.routines) x (objschema, objname, objtype, objdtdid);

alter table information_schema.data_type_privileges
  owner to postgres;

create view information_schema.element_types as
  SELECT (current_database()) :: information_schema.sql_identifier                    AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                             AS object_schema,
         x.objname                                                                    AS object_name,
         (x.objtype) :: information_schema.character_data                             AS object_type,
         (x.objdtdid) :: information_schema.sql_identifier                            AS collection_type_identifier,
         (
             CASE
               WHEN (nbt.nspname = 'pg_catalog' :: name) THEN format_type(bt.oid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                            AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                      AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                      AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier             AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier             AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier             AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                            AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                           AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                           AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                      AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                      AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                      AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                      AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data             AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                      AS interval_precision,
         (NULL :: character varying) :: information_schema.character_data             AS domain_default,
         (current_database()) :: information_schema.sql_identifier                    AS udt_catalog,
         (nbt.nspname) :: information_schema.sql_identifier                           AS udt_schema,
         (bt.typname) :: information_schema.sql_identifier                            AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier             AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier             AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier             AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                      AS maximum_cardinality,
         (('a' :: text || (x.objdtdid) :: text)) :: information_schema.sql_identifier AS dtd_identifier
  FROM pg_namespace n,
       pg_type at,
       pg_namespace nbt,
       pg_type bt,
       ((SELECT c.relnamespace,
                (c.relname) :: information_schema.sql_identifier AS relname,
                CASE
                  WHEN (c.relkind = 'c' :: "char") THEN 'USER-DEFINED TYPE' :: text
                  ELSE 'TABLE' :: text
                    END                                          AS "case",
                a.attnum,
                a.atttypid,
                a.attcollation
         FROM pg_class c,
              pg_attribute a
         WHERE ((c.oid = a.attrelid) AND
                (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char", 'p'::"char"])) AND
                (a.attnum > 0) AND (NOT a.attisdropped))
         UNION ALL
         SELECT t.typnamespace,
                (t.typname) :: information_schema.sql_identifier AS typname,
                'DOMAIN' :: text                                 AS text,
                1,
                t.typbasetype,
                t.typcollation
         FROM pg_type t
         WHERE (t.typtype = 'd' :: "char")
         UNION ALL
         SELECT ss.pronamespace,
                ((((ss.proname) :: text || '_' :: text) || (ss.oid) :: text)) :: information_schema.sql_identifier AS sql_identifier,
                'ROUTINE' :: text                                                                                  AS text,
                (ss.x).n                                                                                           AS n,
                (ss.x).x                                                                                           AS x,
                0
         FROM (SELECT p.pronamespace,
                      p.proname,
                      p.oid,
                      information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes) :: oid [])) AS x
               FROM pg_proc p) ss
         UNION ALL
         SELECT p.pronamespace,
                ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS sql_identifier,
                'ROUTINE' :: text                                                                                AS text,
                0,
                p.prorettype,
                0
         FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)
           LEFT JOIN (pg_collation co
           JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((x.objcollation = co.oid) AND
                                                                         ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                          (co.collname <> 'default' :: name)))))
  WHERE ((n.oid = x.objschema) AND (at.oid = x.objtypeid) AND
         ((at.typelem <> (0) :: oid) AND (at.typlen = '-1' :: integer)) AND (at.typelem = bt.oid) AND
         (nbt.oid = bt.typnamespace) AND
         ((n.nspname, (x.objname) :: text, x.objtype, ((x.objdtdid) :: information_schema.sql_identifier) :: text) IN
          (SELECT data_type_privileges.object_schema,
                  data_type_privileges.object_name,
                  data_type_privileges.object_type,
                  data_type_privileges.dtd_identifier
           FROM information_schema.data_type_privileges)));

alter table information_schema.element_types
  owner to postgres;

create view information_schema."_pg_foreign_table_columns" as
  SELECT n.nspname, c.relname, a.attname, a.attfdwoptions
  FROM pg_foreign_table t,
       pg_authid u,
       pg_namespace n,
       pg_class c,
       pg_attribute a
  WHERE ((u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR has_column_privilege(c.oid, a.attnum,
                                                                                                    'SELECT, INSERT, UPDATE, REFERENCES' :: text)) AND
         (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f' :: "char") AND (a.attrelid = c.oid) AND
         (a.attnum > 0));

alter table information_schema."_pg_foreign_table_columns"
  owner to postgres;

create view information_schema.column_options as
  SELECT (current_database()) :: information_schema.sql_identifier                                  AS table_catalog,
         (c.nspname) :: information_schema.sql_identifier                                           AS table_schema,
         (c.relname) :: information_schema.sql_identifier                                           AS table_name,
         (c.attname) :: information_schema.sql_identifier                                           AS column_name,
         ((pg_options_to_table(c.attfdwoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(c.attfdwoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_table_columns c;

alter table information_schema.column_options
  owner to postgres;

create view information_schema."_pg_foreign_data_wrappers" as
  SELECT w.oid,
         w.fdwowner,
         w.fdwoptions,
         (current_database()) :: information_schema.sql_identifier       AS foreign_data_wrapper_catalog,
         (w.fdwname) :: information_schema.sql_identifier                AS foreign_data_wrapper_name,
         (u.rolname) :: information_schema.sql_identifier                AS authorization_identifier,
         ('c' :: character varying) :: information_schema.character_data AS foreign_data_wrapper_language
  FROM pg_foreign_data_wrapper w,
       pg_authid u
  WHERE ((u.oid = w.fdwowner) AND
         (pg_has_role(w.fdwowner, 'USAGE' :: text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE' :: text)));

alter table information_schema."_pg_foreign_data_wrappers"
  owner to postgres;

create view information_schema.foreign_data_wrapper_options as
  SELECT w.foreign_data_wrapper_catalog,
         w.foreign_data_wrapper_name,
         ((pg_options_to_table(w.fdwoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(w.fdwoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrapper_options
  owner to postgres;

create view information_schema.foreign_data_wrappers as
  SELECT w.foreign_data_wrapper_catalog,
         w.foreign_data_wrapper_name,
         w.authorization_identifier,
         (NULL :: character varying) :: information_schema.character_data AS library_name,
         w.foreign_data_wrapper_language
  FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrappers
  owner to postgres;

create view information_schema."_pg_foreign_servers" as
  SELECT s.oid,
         s.srvoptions,
         (current_database()) :: information_schema.sql_identifier AS foreign_server_catalog,
         (s.srvname) :: information_schema.sql_identifier          AS foreign_server_name,
         (current_database()) :: information_schema.sql_identifier AS foreign_data_wrapper_catalog,
         (w.fdwname) :: information_schema.sql_identifier          AS foreign_data_wrapper_name,
         (s.srvtype) :: information_schema.character_data          AS foreign_server_type,
         (s.srvversion) :: information_schema.character_data       AS foreign_server_version,
         (u.rolname) :: information_schema.sql_identifier          AS authorization_identifier
  FROM pg_foreign_server s,
       pg_foreign_data_wrapper w,
       pg_authid u
  WHERE ((w.oid = s.srvfdw) AND (u.oid = s.srvowner) AND
         (pg_has_role(s.srvowner, 'USAGE' :: text) OR has_server_privilege(s.oid, 'USAGE' :: text)));

alter table information_schema."_pg_foreign_servers"
  owner to postgres;

create view information_schema.foreign_server_options as
  SELECT s.foreign_server_catalog,
         s.foreign_server_name,
         ((pg_options_to_table(s.srvoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(s.srvoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_servers s;

alter table information_schema.foreign_server_options
  owner to postgres;

create view information_schema.foreign_servers as
  SELECT _pg_foreign_servers.foreign_server_catalog,
         _pg_foreign_servers.foreign_server_name,
         _pg_foreign_servers.foreign_data_wrapper_catalog,
         _pg_foreign_servers.foreign_data_wrapper_name,
         _pg_foreign_servers.foreign_server_type,
         _pg_foreign_servers.foreign_server_version,
         _pg_foreign_servers.authorization_identifier
  FROM information_schema._pg_foreign_servers;

alter table information_schema.foreign_servers
  owner to postgres;

create view information_schema."_pg_foreign_tables" as
  SELECT (current_database()) :: information_schema.sql_identifier AS foreign_table_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS foreign_table_schema,
         (c.relname) :: information_schema.sql_identifier          AS foreign_table_name,
         t.ftoptions,
         (current_database()) :: information_schema.sql_identifier AS foreign_server_catalog,
         (s.srvname) :: information_schema.sql_identifier          AS foreign_server_name,
         (u.rolname) :: information_schema.sql_identifier          AS authorization_identifier
  FROM pg_foreign_table t,
       pg_foreign_server s,
       pg_foreign_data_wrapper w,
       pg_authid u,
       pg_namespace n,
       pg_class c
  WHERE ((w.oid = s.srvfdw) AND (u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                          has_table_privilege(c.oid,
                                                                              'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                          has_any_column_privilege(c.oid,
                                                                                   'SELECT, INSERT, UPDATE, REFERENCES' :: text)) AND
         (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f' :: "char") AND (s.oid = t.ftserver));

alter table information_schema."_pg_foreign_tables"
  owner to postgres;

create view information_schema.foreign_table_options as
  SELECT t.foreign_table_catalog,
         t.foreign_table_schema,
         t.foreign_table_name,
         ((pg_options_to_table(t.ftoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(t.ftoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_tables t;

alter table information_schema.foreign_table_options
  owner to postgres;

create view information_schema.foreign_tables as
  SELECT _pg_foreign_tables.foreign_table_catalog,
         _pg_foreign_tables.foreign_table_schema,
         _pg_foreign_tables.foreign_table_name,
         _pg_foreign_tables.foreign_server_catalog,
         _pg_foreign_tables.foreign_server_name
  FROM information_schema._pg_foreign_tables;

alter table information_schema.foreign_tables
  owner to postgres;

create view information_schema."_pg_user_mappings" as
  SELECT um.oid,
         um.umoptions,
         um.umuser,
         (COALESCE(u.rolname, 'PUBLIC' :: name)) :: information_schema.sql_identifier AS authorization_identifier,
         s.foreign_server_catalog,
         s.foreign_server_name,
         s.authorization_identifier                                                   AS srvowner
  FROM (pg_user_mapping um
      LEFT JOIN pg_authid u ON ((u.oid = um.umuser))),
       information_schema._pg_foreign_servers s
  WHERE (s.oid = um.umserver);

alter table information_schema."_pg_user_mappings"
  owner to postgres;

create view information_schema.user_mapping_options as
  SELECT um.authorization_identifier,
         um.foreign_server_catalog,
         um.foreign_server_name,
         (opts.option_name) :: information_schema.sql_identifier AS option_name,
         (
             CASE
               WHEN (((um.umuser <> (0) :: oid) AND ((um.authorization_identifier) :: name = CURRENT_USER)) OR
                     ((um.umuser = (0) :: oid) AND pg_has_role((um.srvowner) :: name, 'USAGE' :: text)) OR
                     (SELECT pg_authid.rolsuper FROM pg_authid WHERE (pg_authid.rolname = CURRENT_USER)))
                       THEN opts.option_value
               ELSE NULL :: text
                 END) :: information_schema.character_data       AS option_value
  FROM information_schema._pg_user_mappings um,
       LATERAL pg_options_to_table(um.umoptions) opts (option_name, option_value);

alter table information_schema.user_mapping_options
  owner to postgres;

create view information_schema.user_mappings as
  SELECT _pg_user_mappings.authorization_identifier,
         _pg_user_mappings.foreign_server_catalog,
         _pg_user_mappings.foreign_server_name
  FROM information_schema._pg_user_mappings;

alter table information_schema.user_mappings
  owner to postgres;

create function pg_catalog.byteaout(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteaout
;

comment on function pg_catalog.byteaout(bytea)
is 'I/O';

alter function pg_catalog.byteaout(bytea)
  owner to postgres;

create function pg_catalog.charout("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charout
;

comment on function pg_catalog.charout("char")
is 'I/O';

alter function pg_catalog.charout("char")
  owner to postgres;

create function pg_catalog.namein(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namein
;

comment on function pg_catalog.namein(cstring)
is 'I/O';

alter function pg_catalog.namein(cstring)
  owner to postgres;

create function pg_catalog.nameout(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameout
;

comment on function pg_catalog.nameout(name)
is 'I/O';

alter function pg_catalog.nameout(name)
  owner to postgres;

create function pg_catalog.int2in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2in
;

comment on function pg_catalog.int2in(cstring)
is 'I/O';

alter function pg_catalog.int2in(cstring)
  owner to postgres;

create function pg_catalog.int2out(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2out
;

comment on function pg_catalog.int2out(smallint)
is 'I/O';

alter function pg_catalog.int2out(smallint)
  owner to postgres;

create function pg_catalog.int2vectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorin
;

comment on function pg_catalog.int2vectorin(cstring)
is 'I/O';

alter function pg_catalog.int2vectorin(cstring)
  owner to postgres;

create function pg_catalog.int2vectorout(int2vector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorout
;

comment on function pg_catalog.int2vectorout(int2vector)
is 'I/O';

alter function pg_catalog.int2vectorout(int2vector)
  owner to postgres;

create function pg_catalog.int4in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4in
;

comment on function pg_catalog.int4in(cstring)
is 'I/O';

alter function pg_catalog.int4in(cstring)
  owner to postgres;

create function pg_catalog.int4out(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4out
;

comment on function pg_catalog.int4out(integer)
is 'I/O';

alter function pg_catalog.int4out(integer)
  owner to postgres;

create function pg_catalog.regprocin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocin
;

comment on function pg_catalog.regprocin(cstring)
is 'I/O';

alter function pg_catalog.regprocin(cstring)
  owner to postgres;

create function pg_catalog.regprocout(regproc)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocout
;

comment on function pg_catalog.regprocout(regproc)
is 'I/O';

alter function pg_catalog.regprocout(regproc)
  owner to postgres;

create function pg_catalog.textin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textin
;

comment on function pg_catalog.textin(cstring)
is 'I/O';

alter function pg_catalog.textin(cstring)
  owner to postgres;

create function pg_catalog.textout(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textout
;

comment on function pg_catalog.textout(text)
is 'I/O';

alter function pg_catalog.textout(text)
  owner to postgres;

create function pg_catalog.tidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidin
;

comment on function pg_catalog.tidin(cstring)
is 'I/O';

alter function pg_catalog.tidin(cstring)
  owner to postgres;

create function pg_catalog.tidout(tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidout
;

comment on function pg_catalog.tidout(tid)
is 'I/O';

alter function pg_catalog.tidout(tid)
  owner to postgres;

create function pg_catalog.xidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidin
;

comment on function pg_catalog.xidin(cstring)
is 'I/O';

alter function pg_catalog.xidin(cstring)
  owner to postgres;

create function pg_catalog.xidout(xid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidout
;

comment on function pg_catalog.xidout(xid)
is 'I/O';

alter function pg_catalog.xidout(xid)
  owner to postgres;

create function pg_catalog.cidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidin
;

comment on function pg_catalog.cidin(cstring)
is 'I/O';

alter function pg_catalog.cidin(cstring)
  owner to postgres;

create function pg_catalog.cidout(cid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidout
;

comment on function pg_catalog.cidout(cid)
is 'I/O';

alter function pg_catalog.cidout(cid)
  owner to postgres;

create function pg_catalog.oidvectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorin
;

comment on function pg_catalog.oidvectorin(cstring)
is 'I/O';

alter function pg_catalog.oidvectorin(cstring)
  owner to postgres;

create function pg_catalog.oidvectorout(oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorout
;

comment on function pg_catalog.oidvectorout(oidvector)
is 'I/O';

alter function pg_catalog.oidvectorout(oidvector)
  owner to postgres;

create function pg_catalog.boollt(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boollt
;

comment on function pg_catalog.boollt(boolean, boolean)
is 'implementation of < operator';

alter function pg_catalog.boollt(boolean, boolean)
  owner to postgres;

create function pg_catalog.boolgt(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolgt
;

comment on function pg_catalog.boolgt(boolean, boolean)
is 'implementation of > operator';

alter function pg_catalog.boolgt(boolean, boolean)
  owner to postgres;

create function pg_catalog.booleq(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.booleq
;

comment on function pg_catalog.booleq(boolean, boolean)
is 'implementation of = operator';

alter function pg_catalog.booleq(boolean, boolean)
  owner to postgres;

create function pg_catalog.chareq("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.chareq
;

comment on function pg_catalog.chareq("char", "char")
is 'implementation of = operator';

alter function pg_catalog.chareq("char", "char")
  owner to postgres;

create function pg_catalog.nameeq(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameeq
;

comment on function pg_catalog.nameeq(name, name)
is 'implementation of = operator';

alter function pg_catalog.nameeq(name, name)
  owner to postgres;

create function pg_catalog.int2eq(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2eq
;

comment on function pg_catalog.int2eq(smallint, smallint)
is 'implementation of = operator';

alter function pg_catalog.int2eq(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2lt(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2lt
;

comment on function pg_catalog.int2lt(smallint, smallint)
is 'implementation of < operator';

alter function pg_catalog.int2lt(smallint, smallint)
  owner to postgres;

create function pg_catalog.int4eq(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4eq
;

comment on function pg_catalog.int4eq(integer, integer)
is 'implementation of = operator';

alter function pg_catalog.int4eq(integer, integer)
  owner to postgres;

create function pg_catalog.int4lt(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4lt
;

comment on function pg_catalog.int4lt(integer, integer)
is 'implementation of < operator';

alter function pg_catalog.int4lt(integer, integer)
  owner to postgres;

create function pg_catalog.texteq(text, text)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texteq
;

comment on function pg_catalog.texteq(text, text)
is 'implementation of = operator';

alter function pg_catalog.texteq(text, text)
  owner to postgres;

create function pg_catalog.xideq(xid, xid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xideq
;

comment on function pg_catalog.xideq(xid, xid)
is 'implementation of = operator';

alter function pg_catalog.xideq(xid, xid)
  owner to postgres;

create function pg_catalog.cideq(cid, cid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cideq
;

comment on function pg_catalog.cideq(cid, cid)
is 'implementation of = operator';

alter function pg_catalog.cideq(cid, cid)
  owner to postgres;

create function pg_catalog.charne("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charne
;

comment on function pg_catalog.charne("char", "char")
is 'implementation of <> operator';

alter function pg_catalog.charne("char", "char")
  owner to postgres;

create function pg_catalog.charle("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charle
;

comment on function pg_catalog.charle("char", "char")
is 'implementation of <= operator';

alter function pg_catalog.charle("char", "char")
  owner to postgres;

create function pg_catalog.chargt("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.chargt
;

comment on function pg_catalog.chargt("char", "char")
is 'implementation of > operator';

alter function pg_catalog.chargt("char", "char")
  owner to postgres;

create function pg_catalog.charge("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charge
;

comment on function pg_catalog.charge("char", "char")
is 'implementation of >= operator';

alter function pg_catalog.charge("char", "char")
  owner to postgres;

create function pg_catalog.int4("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4("char")
is 'convert char to int4';

alter function pg_catalog.int4("char")
  owner to postgres;

create function pg_catalog.char(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char
;

comment on function pg_catalog.char(integer)
is 'convert int4 to char';

alter function pg_catalog.char(integer)
  owner to postgres;

create function pg_catalog.nameregexeq(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameregexeq
;

comment on function pg_catalog.nameregexeq(name, text)
is 'implementation of ~ operator';

alter function pg_catalog.nameregexeq(name, text)
  owner to postgres;

create function pg_catalog.boolne(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolne
;

comment on function pg_catalog.boolne(boolean, boolean)
is 'implementation of <> operator';

alter function pg_catalog.boolne(boolean, boolean)
  owner to postgres;

create function pg_catalog.pg_ddl_command_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_in
;

comment on function pg_catalog.pg_ddl_command_in(cstring)
is 'I/O';

alter function pg_catalog.pg_ddl_command_in(cstring)
  owner to postgres;

create function pg_catalog.pg_ddl_command_out(pg_ddl_command)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_out
;

comment on function pg_catalog.pg_ddl_command_out(pg_ddl_command)
is 'I/O';

alter function pg_catalog.pg_ddl_command_out(pg_ddl_command)
  owner to postgres;

create function pg_catalog.pg_ddl_command_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_recv
;

comment on function pg_catalog.pg_ddl_command_recv(internal)
is 'I/O';

alter function pg_catalog.pg_ddl_command_recv(internal)
  owner to postgres;

create function pg_catalog.version()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.version
;

comment on function pg_catalog.version()
is 'PostgreSQL version string';

alter function pg_catalog.version()
  owner to postgres;

create function pg_catalog.pg_ddl_command_send(pg_ddl_command)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_send
;

comment on function pg_catalog.pg_ddl_command_send(pg_ddl_command)
is 'I/O';

alter function pg_catalog.pg_ddl_command_send(pg_ddl_command)
  owner to postgres;

create function pg_catalog.eqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.eqsel
;

comment on function pg_catalog.eqsel(internal, oid, internal, integer)
is 'restriction selectivity of = and related operators';

alter function pg_catalog.eqsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.neqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.neqsel
;

comment on function pg_catalog.neqsel(internal, oid, internal, integer)
is 'restriction selectivity of <> and related operators';

alter function pg_catalog.neqsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.scalarltsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalarltsel
;

comment on function pg_catalog.scalarltsel(internal, oid, internal, integer)
is 'restriction selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.scalargtsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalargtsel
;

comment on function pg_catalog.scalargtsel(internal, oid, internal, integer)
is 'restriction selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.eqjoinsel
;

comment on function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of = and related operators';

alter function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.neqjoinsel
;

comment on function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of <> and related operators';

alter function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalarltjoinsel
;

comment on function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalargtjoinsel
;

comment on function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.unknownin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownin
;

comment on function pg_catalog.unknownin(cstring)
is 'I/O';

alter function pg_catalog.unknownin(cstring)
  owner to postgres;

create function pg_catalog.unknownout(unknown)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownout
;

comment on function pg_catalog.unknownout(unknown)
is 'I/O';

alter function pg_catalog.unknownout(unknown)
  owner to postgres;

create function pg_catalog.numeric_fac(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_fac
;

comment on function pg_catalog.numeric_fac(bigint)
is 'implementation of ! operator';

alter function pg_catalog.numeric_fac(bigint)
  owner to postgres;

create function pg_catalog.box_above_eq(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_above_eq
;

comment on function pg_catalog.box_above_eq(box, box)
is 'implementation of >^ operator';

alter function pg_catalog.box_above_eq(box, box)
  owner to postgres;

create function pg_catalog.box_below_eq(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_below_eq
;

comment on function pg_catalog.box_below_eq(box, box)
is 'implementation of <^ operator';

alter function pg_catalog.box_below_eq(box, box)
  owner to postgres;

create function pg_catalog.point_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_in
;

comment on function pg_catalog.point_in(cstring)
is 'I/O';

alter function pg_catalog.point_in(cstring)
  owner to postgres;

create function pg_catalog.point_out(point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_out
;

comment on function pg_catalog.point_out(point)
is 'I/O';

alter function pg_catalog.point_out(point)
  owner to postgres;

create function pg_catalog.lseg_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_in
;

comment on function pg_catalog.lseg_in(cstring)
is 'I/O';

alter function pg_catalog.lseg_in(cstring)
  owner to postgres;

create function pg_catalog.lseg_out(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_out
;

comment on function pg_catalog.lseg_out(lseg)
is 'I/O';

alter function pg_catalog.lseg_out(lseg)
  owner to postgres;

create function pg_catalog.path_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_in
;

comment on function pg_catalog.path_in(cstring)
is 'I/O';

alter function pg_catalog.path_in(cstring)
  owner to postgres;

create function pg_catalog.path_out(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_out
;

comment on function pg_catalog.path_out(path)
is 'I/O';

alter function pg_catalog.path_out(path)
  owner to postgres;

create function pg_catalog.box_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_in
;

comment on function pg_catalog.box_in(cstring)
is 'I/O';

alter function pg_catalog.box_in(cstring)
  owner to postgres;

create function pg_catalog.box_out(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_out
;

comment on function pg_catalog.box_out(box)
is 'I/O';

alter function pg_catalog.box_out(box)
  owner to postgres;

create function pg_catalog.box_overlap(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overlap
;

comment on function pg_catalog.box_overlap(box, box)
is 'implementation of && operator';

alter function pg_catalog.box_overlap(box, box)
  owner to postgres;

create function pg_catalog.box_ge(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_ge
;

comment on function pg_catalog.box_ge(box, box)
is 'implementation of >= operator';

alter function pg_catalog.box_ge(box, box)
  owner to postgres;

create function pg_catalog.box_gt(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_gt
;

comment on function pg_catalog.box_gt(box, box)
is 'implementation of > operator';

alter function pg_catalog.box_gt(box, box)
  owner to postgres;

create function pg_catalog.box_eq(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_eq
;

comment on function pg_catalog.box_eq(box, box)
is 'implementation of = operator';

alter function pg_catalog.box_eq(box, box)
  owner to postgres;

create function pg_catalog.box_lt(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_lt
;

comment on function pg_catalog.box_lt(box, box)
is 'implementation of < operator';

alter function pg_catalog.box_lt(box, box)
  owner to postgres;

create function pg_catalog.box_le(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_le
;

comment on function pg_catalog.box_le(box, box)
is 'implementation of <= operator';

alter function pg_catalog.box_le(box, box)
  owner to postgres;

create function pg_catalog.point_above(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_above
;

comment on function pg_catalog.point_above(point, point)
is 'implementation of >^ operator';

alter function pg_catalog.point_above(point, point)
  owner to postgres;

create function pg_catalog.point_left(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_left
;

comment on function pg_catalog.point_left(point, point)
is 'implementation of << operator';

alter function pg_catalog.point_left(point, point)
  owner to postgres;

create function pg_catalog.point_right(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_right
;

comment on function pg_catalog.point_right(point, point)
is 'implementation of >> operator';

alter function pg_catalog.point_right(point, point)
  owner to postgres;

create function pg_catalog.point_below(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_below
;

comment on function pg_catalog.point_below(point, point)
is 'implementation of <^ operator';

alter function pg_catalog.point_below(point, point)
  owner to postgres;

create function pg_catalog.point_eq(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_eq
;

comment on function pg_catalog.point_eq(point, point)
is 'implementation of ~= operator';

alter function pg_catalog.point_eq(point, point)
  owner to postgres;

create function pg_catalog.on_pb(point, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_pb
;

comment on function pg_catalog.on_pb(point, box)
is 'implementation of <@ operator';

alter function pg_catalog.on_pb(point, box)
  owner to postgres;

create function pg_catalog.on_ppath(point, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_ppath
;

comment on function pg_catalog.on_ppath(point, path)
is 'implementation of <@ operator';

alter function pg_catalog.on_ppath(point, path)
  owner to postgres;

create function pg_catalog.box_center(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_center
;

comment on function pg_catalog.box_center(box)
is 'implementation of @@ operator';

alter function pg_catalog.box_center(box)
  owner to postgres;

create function pg_catalog.areasel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.areasel
;

comment on function pg_catalog.areasel(internal, oid, internal, integer)
is 'restriction selectivity for area-comparison operators';

alter function pg_catalog.areasel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.areajoinsel
;

comment on function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for area-comparison operators';

alter function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.int4mul(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4mul
;

comment on function pg_catalog.int4mul(integer, integer)
is 'implementation of * operator';

alter function pg_catalog.int4mul(integer, integer)
  owner to postgres;

create function pg_catalog.int4ne(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4ne
;

comment on function pg_catalog.int4ne(integer, integer)
is 'implementation of <> operator';

alter function pg_catalog.int4ne(integer, integer)
  owner to postgres;

create function pg_catalog.int2ne(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2ne
;

comment on function pg_catalog.int2ne(smallint, smallint)
is 'implementation of <> operator';

alter function pg_catalog.int2ne(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2gt(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2gt
;

comment on function pg_catalog.int2gt(smallint, smallint)
is 'implementation of > operator';

alter function pg_catalog.int2gt(smallint, smallint)
  owner to postgres;

create function pg_catalog.int4gt(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4gt
;

comment on function pg_catalog.int4gt(integer, integer)
is 'implementation of > operator';

alter function pg_catalog.int4gt(integer, integer)
  owner to postgres;

create function pg_catalog.int2le(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2le
;

comment on function pg_catalog.int2le(smallint, smallint)
is 'implementation of <= operator';

alter function pg_catalog.int2le(smallint, smallint)
  owner to postgres;

create function pg_catalog.int4le(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4le
;

comment on function pg_catalog.int4le(integer, integer)
is 'implementation of <= operator';

alter function pg_catalog.int4le(integer, integer)
  owner to postgres;

create function pg_catalog.int4ge(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4ge
;

comment on function pg_catalog.int4ge(integer, integer)
is 'implementation of >= operator';

alter function pg_catalog.int4ge(integer, integer)
  owner to postgres;

create function pg_catalog.int2ge(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2ge
;

comment on function pg_catalog.int2ge(smallint, smallint)
is 'implementation of >= operator';

alter function pg_catalog.int2ge(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2mul(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2mul
;

comment on function pg_catalog.int2mul(smallint, smallint)
is 'implementation of * operator';

alter function pg_catalog.int2mul(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2div(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2div
;

comment on function pg_catalog.int2div(smallint, smallint)
is 'implementation of / operator';

alter function pg_catalog.int2div(smallint, smallint)
  owner to postgres;

create function pg_catalog.int4div(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4div
;

comment on function pg_catalog.int4div(integer, integer)
is 'implementation of / operator';

alter function pg_catalog.int4div(integer, integer)
  owner to postgres;

create function pg_catalog.int2mod(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2mod
;

comment on function pg_catalog.int2mod(smallint, smallint)
is 'implementation of % operator';

alter function pg_catalog.int2mod(smallint, smallint)
  owner to postgres;

create function pg_catalog.int4mod(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4mod
;

comment on function pg_catalog.int4mod(integer, integer)
is 'implementation of % operator';

alter function pg_catalog.int4mod(integer, integer)
  owner to postgres;

create function pg_catalog.textne(text, text)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textne
;

comment on function pg_catalog.textne(text, text)
is 'implementation of <> operator';

alter function pg_catalog.textne(text, text)
  owner to postgres;

create function pg_catalog.int24eq(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24eq
;

comment on function pg_catalog.int24eq(smallint, integer)
is 'implementation of = operator';

alter function pg_catalog.int24eq(smallint, integer)
  owner to postgres;

create function pg_catalog.int42eq(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42eq
;

comment on function pg_catalog.int42eq(integer, smallint)
is 'implementation of = operator';

alter function pg_catalog.int42eq(integer, smallint)
  owner to postgres;

create function pg_catalog.int24lt(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24lt
;

comment on function pg_catalog.int24lt(smallint, integer)
is 'implementation of < operator';

alter function pg_catalog.int24lt(smallint, integer)
  owner to postgres;

create function pg_catalog.int42lt(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42lt
;

comment on function pg_catalog.int42lt(integer, smallint)
is 'implementation of < operator';

alter function pg_catalog.int42lt(integer, smallint)
  owner to postgres;

create function pg_catalog.int24gt(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24gt
;

comment on function pg_catalog.int24gt(smallint, integer)
is 'implementation of > operator';

alter function pg_catalog.int24gt(smallint, integer)
  owner to postgres;

create function pg_catalog.int42gt(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42gt
;

comment on function pg_catalog.int42gt(integer, smallint)
is 'implementation of > operator';

alter function pg_catalog.int42gt(integer, smallint)
  owner to postgres;

create function pg_catalog.int24ne(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24ne
;

comment on function pg_catalog.int24ne(smallint, integer)
is 'implementation of <> operator';

alter function pg_catalog.int24ne(smallint, integer)
  owner to postgres;

create function pg_catalog.int42ne(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42ne
;

comment on function pg_catalog.int42ne(integer, smallint)
is 'implementation of <> operator';

alter function pg_catalog.int42ne(integer, smallint)
  owner to postgres;

create function pg_catalog.int24le(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24le
;

comment on function pg_catalog.int24le(smallint, integer)
is 'implementation of <= operator';

alter function pg_catalog.int24le(smallint, integer)
  owner to postgres;

create function pg_catalog.int42le(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42le
;

comment on function pg_catalog.int42le(integer, smallint)
is 'implementation of <= operator';

alter function pg_catalog.int42le(integer, smallint)
  owner to postgres;

create function pg_catalog.int24ge(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24ge
;

comment on function pg_catalog.int24ge(smallint, integer)
is 'implementation of >= operator';

alter function pg_catalog.int24ge(smallint, integer)
  owner to postgres;

create function pg_catalog.int42ge(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42ge
;

comment on function pg_catalog.int42ge(integer, smallint)
is 'implementation of >= operator';

alter function pg_catalog.int42ge(integer, smallint)
  owner to postgres;

create function pg_catalog.int24mul(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24mul
;

comment on function pg_catalog.int24mul(smallint, integer)
is 'implementation of * operator';

alter function pg_catalog.int24mul(smallint, integer)
  owner to postgres;

create function pg_catalog.int42mul(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42mul
;

comment on function pg_catalog.int42mul(integer, smallint)
is 'implementation of * operator';

alter function pg_catalog.int42mul(integer, smallint)
  owner to postgres;

create function pg_catalog.int24div(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24div
;

comment on function pg_catalog.int24div(smallint, integer)
is 'implementation of / operator';

alter function pg_catalog.int24div(smallint, integer)
  owner to postgres;

create function pg_catalog.int42div(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42div
;

comment on function pg_catalog.int42div(integer, smallint)
is 'implementation of / operator';

alter function pg_catalog.int42div(integer, smallint)
  owner to postgres;

create function pg_catalog.int2pl(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2pl
;

comment on function pg_catalog.int2pl(smallint, smallint)
is 'implementation of + operator';

alter function pg_catalog.int2pl(smallint, smallint)
  owner to postgres;

create function pg_catalog.int4pl(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4pl
;

comment on function pg_catalog.int4pl(integer, integer)
is 'implementation of + operator';

alter function pg_catalog.int4pl(integer, integer)
  owner to postgres;

create function pg_catalog.int24pl(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24pl
;

comment on function pg_catalog.int24pl(smallint, integer)
is 'implementation of + operator';

alter function pg_catalog.int24pl(smallint, integer)
  owner to postgres;

create function pg_catalog.int42pl(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42pl
;

comment on function pg_catalog.int42pl(integer, smallint)
is 'implementation of + operator';

alter function pg_catalog.int42pl(integer, smallint)
  owner to postgres;

create function pg_catalog.int2mi(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2mi
;

comment on function pg_catalog.int2mi(smallint, smallint)
is 'implementation of - operator';

alter function pg_catalog.int2mi(smallint, smallint)
  owner to postgres;

create function pg_catalog.int4mi(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4mi
;

comment on function pg_catalog.int4mi(integer, integer)
is 'implementation of - operator';

alter function pg_catalog.int4mi(integer, integer)
  owner to postgres;

create function pg_catalog.int24mi(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24mi
;

comment on function pg_catalog.int24mi(smallint, integer)
is 'implementation of - operator';

alter function pg_catalog.int24mi(smallint, integer)
  owner to postgres;

create function pg_catalog.int42mi(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42mi
;

comment on function pg_catalog.int42mi(integer, smallint)
is 'implementation of - operator';

alter function pg_catalog.int42mi(integer, smallint)
  owner to postgres;

create function pg_catalog.oideq(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oideq
;

comment on function pg_catalog.oideq(oid, oid)
is 'implementation of = operator';

alter function pg_catalog.oideq(oid, oid)
  owner to postgres;

create function pg_catalog.oidne(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidne
;

comment on function pg_catalog.oidne(oid, oid)
is 'implementation of <> operator';

alter function pg_catalog.oidne(oid, oid)
  owner to postgres;

create function pg_catalog.box_same(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_same
;

comment on function pg_catalog.box_same(box, box)
is 'implementation of ~= operator';

alter function pg_catalog.box_same(box, box)
  owner to postgres;

create function pg_catalog.box_contain(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_contain
;

comment on function pg_catalog.box_contain(box, box)
is 'implementation of @> operator';

alter function pg_catalog.box_contain(box, box)
  owner to postgres;

create function pg_catalog.box_left(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_left
;

comment on function pg_catalog.box_left(box, box)
is 'implementation of << operator';

alter function pg_catalog.box_left(box, box)
  owner to postgres;

create function pg_catalog.box_overleft(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overleft
;

comment on function pg_catalog.box_overleft(box, box)
is 'implementation of &< operator';

alter function pg_catalog.box_overleft(box, box)
  owner to postgres;

create function pg_catalog.box_overright(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overright
;

comment on function pg_catalog.box_overright(box, box)
is 'implementation of &> operator';

alter function pg_catalog.box_overright(box, box)
  owner to postgres;

create function pg_catalog.box_right(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_right
;

comment on function pg_catalog.box_right(box, box)
is 'implementation of >> operator';

alter function pg_catalog.box_right(box, box)
  owner to postgres;

create function pg_catalog.box_contained(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_contained
;

comment on function pg_catalog.box_contained(box, box)
is 'implementation of <@ operator';

alter function pg_catalog.box_contained(box, box)
  owner to postgres;

create function pg_catalog.box_contain_pt(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_contain_pt
;

comment on function pg_catalog.box_contain_pt(box, point)
is 'implementation of @> operator';

alter function pg_catalog.box_contain_pt(box, point)
  owner to postgres;

create function pg_catalog.pg_node_tree_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_in
;

comment on function pg_catalog.pg_node_tree_in(cstring)
is 'I/O';

alter function pg_catalog.pg_node_tree_in(cstring)
  owner to postgres;

create function pg_catalog.pg_node_tree_out(pg_node_tree)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_out
;

comment on function pg_catalog.pg_node_tree_out(pg_node_tree)
is 'I/O';

alter function pg_catalog.pg_node_tree_out(pg_node_tree)
  owner to postgres;

create function pg_catalog.pg_node_tree_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_recv
;

comment on function pg_catalog.pg_node_tree_recv(internal)
is 'I/O';

alter function pg_catalog.pg_node_tree_recv(internal)
  owner to postgres;

create function pg_catalog.pg_node_tree_send(pg_node_tree)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_send
;

comment on function pg_catalog.pg_node_tree_send(pg_node_tree)
is 'I/O';

alter function pg_catalog.pg_node_tree_send(pg_node_tree)
  owner to postgres;

create function pg_catalog.float4in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4in
;

comment on function pg_catalog.float4in(cstring)
is 'I/O';

alter function pg_catalog.float4in(cstring)
  owner to postgres;

create function pg_catalog.float4out(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4out
;

comment on function pg_catalog.float4out(real)
is 'I/O';

alter function pg_catalog.float4out(real)
  owner to postgres;

create function pg_catalog.float4mul(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4mul
;

comment on function pg_catalog.float4mul(real, real)
is 'implementation of * operator';

alter function pg_catalog.float4mul(real, real)
  owner to postgres;

create function pg_catalog.float4div(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4div
;

comment on function pg_catalog.float4div(real, real)
is 'implementation of / operator';

alter function pg_catalog.float4div(real, real)
  owner to postgres;

create function pg_catalog.float4pl(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4pl
;

comment on function pg_catalog.float4pl(real, real)
is 'implementation of + operator';

alter function pg_catalog.float4pl(real, real)
  owner to postgres;

create function pg_catalog.float4mi(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4mi
;

comment on function pg_catalog.float4mi(real, real)
is 'implementation of - operator';

alter function pg_catalog.float4mi(real, real)
  owner to postgres;

create function pg_catalog.float4um(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4um
;

comment on function pg_catalog.float4um(real)
is 'implementation of - operator';

alter function pg_catalog.float4um(real)
  owner to postgres;

create function pg_catalog.float4abs(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4abs
;

comment on function pg_catalog.float4abs(real)
is 'implementation of @ operator';

alter function pg_catalog.float4abs(real)
  owner to postgres;

create function pg_catalog.float4_accum(double precision [], real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4_accum
;

comment on function pg_catalog.float4_accum(double precision [], real)
is 'aggregate transition function';

alter function pg_catalog.float4_accum(double precision [], real)
  owner to postgres;

create function pg_catalog.float4larger(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4larger
;

comment on function pg_catalog.float4larger(real, real)
is 'larger of two';

alter function pg_catalog.float4larger(real, real)
  owner to postgres;

create function pg_catalog.float4smaller(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4smaller
;

comment on function pg_catalog.float4smaller(real, real)
is 'smaller of two';

alter function pg_catalog.float4smaller(real, real)
  owner to postgres;

create function pg_catalog.int4um(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4um
;

comment on function pg_catalog.int4um(integer)
is 'implementation of - operator';

alter function pg_catalog.int4um(integer)
  owner to postgres;

create function pg_catalog.int2um(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2um
;

comment on function pg_catalog.int2um(smallint)
is 'implementation of - operator';

alter function pg_catalog.int2um(smallint)
  owner to postgres;

create function pg_catalog.float8in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8in
;

comment on function pg_catalog.float8in(cstring)
is 'I/O';

alter function pg_catalog.float8in(cstring)
  owner to postgres;

create function pg_catalog.float8out(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8out
;

comment on function pg_catalog.float8out(double precision)
is 'I/O';

alter function pg_catalog.float8out(double precision)
  owner to postgres;

create function pg_catalog.float8mul(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8mul
;

comment on function pg_catalog.float8mul(double precision, double precision)
is 'implementation of * operator';

alter function pg_catalog.float8mul(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8div(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8div
;

comment on function pg_catalog.float8div(double precision, double precision)
is 'implementation of / operator';

alter function pg_catalog.float8div(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8pl(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8pl
;

comment on function pg_catalog.float8pl(double precision, double precision)
is 'implementation of + operator';

alter function pg_catalog.float8pl(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8mi(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8mi
;

comment on function pg_catalog.float8mi(double precision, double precision)
is 'implementation of - operator';

alter function pg_catalog.float8mi(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8um(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8um
;

comment on function pg_catalog.float8um(double precision)
is 'implementation of - operator';

alter function pg_catalog.float8um(double precision)
  owner to postgres;

create function pg_catalog.float8abs(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8abs
;

comment on function pg_catalog.float8abs(double precision)
is 'implementation of @ operator';

alter function pg_catalog.float8abs(double precision)
  owner to postgres;

create function pg_catalog.float8_accum(double precision [], double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_accum
;

comment on function pg_catalog.float8_accum(double precision [], double precision)
is 'aggregate transition function';

alter function pg_catalog.float8_accum(double precision [], double precision)
  owner to postgres;

create function pg_catalog.float8larger(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8larger
;

comment on function pg_catalog.float8larger(double precision, double precision)
is 'larger of two';

alter function pg_catalog.float8larger(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8smaller(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8smaller
;

comment on function pg_catalog.float8smaller(double precision, double precision)
is 'smaller of two';

alter function pg_catalog.float8smaller(double precision, double precision)
  owner to postgres;

create function pg_catalog.lseg_center(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_center
;

comment on function pg_catalog.lseg_center(lseg)
is 'implementation of @@ operator';

alter function pg_catalog.lseg_center(lseg)
  owner to postgres;

create function pg_catalog.path_center(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_center
;

comment on function pg_catalog.path_center(path)
is 'implementation of @@ operator';

alter function pg_catalog.path_center(path)
  owner to postgres;

create function pg_catalog.poly_center(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_center
;

comment on function pg_catalog.poly_center(polygon)
is 'implementation of @@ operator';

alter function pg_catalog.poly_center(polygon)
  owner to postgres;

create function pg_catalog.dround(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dround
;

comment on function pg_catalog.dround(double precision)
is 'round to nearest integer';

alter function pg_catalog.dround(double precision)
  owner to postgres;

create function pg_catalog.dtrunc(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dtrunc
;

comment on function pg_catalog.dtrunc(double precision)
is 'truncate to integer';

alter function pg_catalog.dtrunc(double precision)
  owner to postgres;

create function pg_catalog.dsqrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsqrt
;

comment on function pg_catalog.dsqrt(double precision)
is 'implementation of |/ operator';

alter function pg_catalog.dsqrt(double precision)
  owner to postgres;

create function pg_catalog.dcbrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dcbrt
;

comment on function pg_catalog.dcbrt(double precision)
is 'implementation of ||/ operator';

alter function pg_catalog.dcbrt(double precision)
  owner to postgres;

create function pg_catalog.dpow(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dpow
;

comment on function pg_catalog.dpow(double precision, double precision)
is 'implementation of ^ operator';

alter function pg_catalog.dpow(double precision, double precision)
  owner to postgres;

create function pg_catalog.dexp(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dexp
;

comment on function pg_catalog.dexp(double precision)
is 'natural exponential (e^x)';

alter function pg_catalog.dexp(double precision)
  owner to postgres;

create function pg_catalog.dlog1(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dlog1
;

comment on function pg_catalog.dlog1(double precision)
is 'natural logarithm';

alter function pg_catalog.dlog1(double precision)
  owner to postgres;

create function pg_catalog.float8(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(smallint)
is 'convert int2 to float8';

alter function pg_catalog.float8(smallint)
  owner to postgres;

create function pg_catalog.float4(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(smallint)
is 'convert int2 to float4';

alter function pg_catalog.float4(smallint)
  owner to postgres;

create function pg_catalog.int2(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(double precision)
is 'convert float8 to int2';

alter function pg_catalog.int2(double precision)
  owner to postgres;

create function pg_catalog.int2(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(real)
is 'convert float4 to int2';

alter function pg_catalog.int2(real)
  owner to postgres;

create function pg_catalog.line_distance(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_distance
;

comment on function pg_catalog.line_distance(line, line)
is 'implementation of <-> operator';

alter function pg_catalog.line_distance(line, line)
  owner to postgres;

create function pg_catalog.abstimein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimein
;

comment on function pg_catalog.abstimein(cstring)
is 'I/O';

alter function pg_catalog.abstimein(cstring)
  owner to postgres;

create function pg_catalog.abstimeout(abstime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimeout
;

comment on function pg_catalog.abstimeout(abstime)
is 'I/O';

alter function pg_catalog.abstimeout(abstime)
  owner to postgres;

create function pg_catalog.reltimein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimein
;

comment on function pg_catalog.reltimein(cstring)
is 'I/O';

alter function pg_catalog.reltimein(cstring)
  owner to postgres;

create function pg_catalog.reltimeout(reltime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimeout
;

comment on function pg_catalog.reltimeout(reltime)
is 'I/O';

alter function pg_catalog.reltimeout(reltime)
  owner to postgres;

create function pg_catalog.timepl(abstime, reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timepl
;

comment on function pg_catalog.timepl(abstime, reltime)
is 'implementation of + operator';

alter function pg_catalog.timepl(abstime, reltime)
  owner to postgres;

create function pg_catalog.timemi(abstime, reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timemi
;

comment on function pg_catalog.timemi(abstime, reltime)
is 'implementation of - operator';

alter function pg_catalog.timemi(abstime, reltime)
  owner to postgres;

create function pg_catalog.tintervalin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalin
;

comment on function pg_catalog.tintervalin(cstring)
is 'I/O';

alter function pg_catalog.tintervalin(cstring)
  owner to postgres;

create function pg_catalog.tintervalout(tinterval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalout
;

comment on function pg_catalog.tintervalout(tinterval)
is 'I/O';

alter function pg_catalog.tintervalout(tinterval)
  owner to postgres;

create function pg_catalog.intinterval(abstime, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.intinterval
;

comment on function pg_catalog.intinterval(abstime, tinterval)
is 'implementation of <?> operator';

alter function pg_catalog.intinterval(abstime, tinterval)
  owner to postgres;

create function pg_catalog.tintervalrel(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalrel
;

comment on function pg_catalog.tintervalrel(tinterval)
is 'tinterval to reltime';

alter function pg_catalog.tintervalrel(tinterval)
  owner to postgres;

create function pg_catalog.timenow()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timenow
;

comment on function pg_catalog.timenow()
is 'current date and time (abstime)';

alter function pg_catalog.timenow()
  owner to postgres;

create function pg_catalog.abstimeeq(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimeeq
;

comment on function pg_catalog.abstimeeq(abstime, abstime)
is 'implementation of = operator';

alter function pg_catalog.abstimeeq(abstime, abstime)
  owner to postgres;

create function pg_catalog.abstimene(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimene
;

comment on function pg_catalog.abstimene(abstime, abstime)
is 'implementation of <> operator';

alter function pg_catalog.abstimene(abstime, abstime)
  owner to postgres;

create function pg_catalog.abstimelt(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimelt
;

comment on function pg_catalog.abstimelt(abstime, abstime)
is 'implementation of < operator';

alter function pg_catalog.abstimelt(abstime, abstime)
  owner to postgres;

create function pg_catalog.abstimegt(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimegt
;

comment on function pg_catalog.abstimegt(abstime, abstime)
is 'implementation of > operator';

alter function pg_catalog.abstimegt(abstime, abstime)
  owner to postgres;

create function pg_catalog.abstimele(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimele
;

comment on function pg_catalog.abstimele(abstime, abstime)
is 'implementation of <= operator';

alter function pg_catalog.abstimele(abstime, abstime)
  owner to postgres;

create function pg_catalog.abstimege(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimege
;

comment on function pg_catalog.abstimege(abstime, abstime)
is 'implementation of >= operator';

alter function pg_catalog.abstimege(abstime, abstime)
  owner to postgres;

create function pg_catalog.reltimeeq(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimeeq
;

comment on function pg_catalog.reltimeeq(reltime, reltime)
is 'implementation of = operator';

alter function pg_catalog.reltimeeq(reltime, reltime)
  owner to postgres;

create function pg_catalog.reltimene(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimene
;

comment on function pg_catalog.reltimene(reltime, reltime)
is 'implementation of <> operator';

alter function pg_catalog.reltimene(reltime, reltime)
  owner to postgres;

create function pg_catalog.reltimelt(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimelt
;

comment on function pg_catalog.reltimelt(reltime, reltime)
is 'implementation of < operator';

alter function pg_catalog.reltimelt(reltime, reltime)
  owner to postgres;

create function pg_catalog.reltimegt(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimegt
;

comment on function pg_catalog.reltimegt(reltime, reltime)
is 'implementation of > operator';

alter function pg_catalog.reltimegt(reltime, reltime)
  owner to postgres;

create function pg_catalog.reltimele(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimele
;

comment on function pg_catalog.reltimele(reltime, reltime)
is 'implementation of <= operator';

alter function pg_catalog.reltimele(reltime, reltime)
  owner to postgres;

create function pg_catalog.reltimege(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimege
;

comment on function pg_catalog.reltimege(reltime, reltime)
is 'implementation of >= operator';

alter function pg_catalog.reltimege(reltime, reltime)
  owner to postgres;

create function pg_catalog.tintervalsame(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalsame
;

comment on function pg_catalog.tintervalsame(tinterval, tinterval)
is 'implementation of ~= operator';

alter function pg_catalog.tintervalsame(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervalct(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalct
;

comment on function pg_catalog.tintervalct(tinterval, tinterval)
is 'implementation of << operator';

alter function pg_catalog.tintervalct(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervalov(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalov
;

comment on function pg_catalog.tintervalov(tinterval, tinterval)
is 'implementation of && operator';

alter function pg_catalog.tintervalov(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervalleneq(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalleneq
;

comment on function pg_catalog.tintervalleneq(tinterval, reltime)
is 'implementation of #= operator';

alter function pg_catalog.tintervalleneq(tinterval, reltime)
  owner to postgres;

create function pg_catalog.tintervallenne(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenne
;

comment on function pg_catalog.tintervallenne(tinterval, reltime)
is 'implementation of #<> operator';

alter function pg_catalog.tintervallenne(tinterval, reltime)
  owner to postgres;

create function pg_catalog.tintervallenlt(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenlt
;

comment on function pg_catalog.tintervallenlt(tinterval, reltime)
is 'implementation of #< operator';

alter function pg_catalog.tintervallenlt(tinterval, reltime)
  owner to postgres;

create function pg_catalog.tintervallengt(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallengt
;

comment on function pg_catalog.tintervallengt(tinterval, reltime)
is 'implementation of #> operator';

alter function pg_catalog.tintervallengt(tinterval, reltime)
  owner to postgres;

create function pg_catalog.tintervallenle(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenle
;

comment on function pg_catalog.tintervallenle(tinterval, reltime)
is 'implementation of #<= operator';

alter function pg_catalog.tintervallenle(tinterval, reltime)
  owner to postgres;

create function pg_catalog.tintervallenge(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenge
;

comment on function pg_catalog.tintervallenge(tinterval, reltime)
is 'implementation of #>= operator';

alter function pg_catalog.tintervallenge(tinterval, reltime)
  owner to postgres;

create function pg_catalog.tintervalstart(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalstart
;

comment on function pg_catalog.tintervalstart(tinterval)
is 'implementation of | operator';

alter function pg_catalog.tintervalstart(tinterval)
  owner to postgres;

create function pg_catalog.tintervalend(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalend
;

comment on function pg_catalog.tintervalend(tinterval)
is 'end of interval';

alter function pg_catalog.tintervalend(tinterval)
  owner to postgres;

create function pg_catalog.timeofday()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timeofday
;

comment on function pg_catalog.timeofday()
is 'current date and time - increments during transactions';

alter function pg_catalog.timeofday()
  owner to postgres;

create function pg_catalog.isfinite(abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(abstime)
is 'finite abstime?';

alter function pg_catalog.isfinite(abstime)
  owner to postgres;

create function pg_catalog.float8_combine(double precision [], double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_combine
;

comment on function pg_catalog.float8_combine(double precision [], double precision [])
is 'aggregate combine function';

alter function pg_catalog.float8_combine(double precision [], double precision [])
  owner to postgres;

create function pg_catalog.inter_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inter_sl
;

comment on function pg_catalog.inter_sl(lseg, line)
is 'implementation of ?# operator';

alter function pg_catalog.inter_sl(lseg, line)
  owner to postgres;

create function pg_catalog.inter_lb(line, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inter_lb
;

comment on function pg_catalog.inter_lb(line, box)
is 'implementation of ?# operator';

alter function pg_catalog.inter_lb(line, box)
  owner to postgres;

create function pg_catalog.float48mul(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48mul
;

comment on function pg_catalog.float48mul(real, double precision)
is 'implementation of * operator';

alter function pg_catalog.float48mul(real, double precision)
  owner to postgres;

create function pg_catalog.float48div(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48div
;

comment on function pg_catalog.float48div(real, double precision)
is 'implementation of / operator';

alter function pg_catalog.float48div(real, double precision)
  owner to postgres;

create function pg_catalog.float48pl(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48pl
;

comment on function pg_catalog.float48pl(real, double precision)
is 'implementation of + operator';

alter function pg_catalog.float48pl(real, double precision)
  owner to postgres;

create function pg_catalog.float48mi(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48mi
;

comment on function pg_catalog.float48mi(real, double precision)
is 'implementation of - operator';

alter function pg_catalog.float48mi(real, double precision)
  owner to postgres;

create function pg_catalog.float84mul(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84mul
;

comment on function pg_catalog.float84mul(double precision, real)
is 'implementation of * operator';

alter function pg_catalog.float84mul(double precision, real)
  owner to postgres;

create function pg_catalog.float84div(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84div
;

comment on function pg_catalog.float84div(double precision, real)
is 'implementation of / operator';

alter function pg_catalog.float84div(double precision, real)
  owner to postgres;

create function pg_catalog.float84pl(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84pl
;

comment on function pg_catalog.float84pl(double precision, real)
is 'implementation of + operator';

alter function pg_catalog.float84pl(double precision, real)
  owner to postgres;

create function pg_catalog.float84mi(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84mi
;

comment on function pg_catalog.float84mi(double precision, real)
is 'implementation of - operator';

alter function pg_catalog.float84mi(double precision, real)
  owner to postgres;

create function pg_catalog.float4eq(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4eq
;

comment on function pg_catalog.float4eq(real, real)
is 'implementation of = operator';

alter function pg_catalog.float4eq(real, real)
  owner to postgres;

create function pg_catalog.float4ne(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4ne
;

comment on function pg_catalog.float4ne(real, real)
is 'implementation of <> operator';

alter function pg_catalog.float4ne(real, real)
  owner to postgres;

create function pg_catalog.float4lt(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4lt
;

comment on function pg_catalog.float4lt(real, real)
is 'implementation of < operator';

alter function pg_catalog.float4lt(real, real)
  owner to postgres;

create function pg_catalog.float4le(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4le
;

comment on function pg_catalog.float4le(real, real)
is 'implementation of <= operator';

alter function pg_catalog.float4le(real, real)
  owner to postgres;

create function pg_catalog.float4gt(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4gt
;

comment on function pg_catalog.float4gt(real, real)
is 'implementation of > operator';

alter function pg_catalog.float4gt(real, real)
  owner to postgres;

create function pg_catalog.float4ge(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4ge
;

comment on function pg_catalog.float4ge(real, real)
is 'implementation of >= operator';

alter function pg_catalog.float4ge(real, real)
  owner to postgres;

create function pg_catalog.float8eq(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8eq
;

comment on function pg_catalog.float8eq(double precision, double precision)
is 'implementation of = operator';

alter function pg_catalog.float8eq(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8ne(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8ne
;

comment on function pg_catalog.float8ne(double precision, double precision)
is 'implementation of <> operator';

alter function pg_catalog.float8ne(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8lt(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8lt
;

comment on function pg_catalog.float8lt(double precision, double precision)
is 'implementation of < operator';

alter function pg_catalog.float8lt(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8le(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8le
;

comment on function pg_catalog.float8le(double precision, double precision)
is 'implementation of <= operator';

alter function pg_catalog.float8le(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8gt(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8gt
;

comment on function pg_catalog.float8gt(double precision, double precision)
is 'implementation of > operator';

alter function pg_catalog.float8gt(double precision, double precision)
  owner to postgres;

create function pg_catalog.float8ge(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8ge
;

comment on function pg_catalog.float8ge(double precision, double precision)
is 'implementation of >= operator';

alter function pg_catalog.float8ge(double precision, double precision)
  owner to postgres;

create function pg_catalog.float48eq(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48eq
;

comment on function pg_catalog.float48eq(real, double precision)
is 'implementation of = operator';

alter function pg_catalog.float48eq(real, double precision)
  owner to postgres;

create function pg_catalog.float48ne(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48ne
;

comment on function pg_catalog.float48ne(real, double precision)
is 'implementation of <> operator';

alter function pg_catalog.float48ne(real, double precision)
  owner to postgres;

create function pg_catalog.float48lt(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48lt
;

comment on function pg_catalog.float48lt(real, double precision)
is 'implementation of < operator';

alter function pg_catalog.float48lt(real, double precision)
  owner to postgres;

create function pg_catalog.float48le(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48le
;

comment on function pg_catalog.float48le(real, double precision)
is 'implementation of <= operator';

alter function pg_catalog.float48le(real, double precision)
  owner to postgres;

create function pg_catalog.float48gt(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48gt
;

comment on function pg_catalog.float48gt(real, double precision)
is 'implementation of > operator';

alter function pg_catalog.float48gt(real, double precision)
  owner to postgres;

create function pg_catalog.float48ge(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48ge
;

comment on function pg_catalog.float48ge(real, double precision)
is 'implementation of >= operator';

alter function pg_catalog.float48ge(real, double precision)
  owner to postgres;

create function pg_catalog.float84eq(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84eq
;

comment on function pg_catalog.float84eq(double precision, real)
is 'implementation of = operator';

alter function pg_catalog.float84eq(double precision, real)
  owner to postgres;

create function pg_catalog.float84ne(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84ne
;

comment on function pg_catalog.float84ne(double precision, real)
is 'implementation of <> operator';

alter function pg_catalog.float84ne(double precision, real)
  owner to postgres;

create function pg_catalog.float84lt(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84lt
;

comment on function pg_catalog.float84lt(double precision, real)
is 'implementation of < operator';

alter function pg_catalog.float84lt(double precision, real)
  owner to postgres;

create function pg_catalog.float84le(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84le
;

comment on function pg_catalog.float84le(double precision, real)
is 'implementation of <= operator';

alter function pg_catalog.float84le(double precision, real)
  owner to postgres;

create function pg_catalog.float84gt(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84gt
;

comment on function pg_catalog.float84gt(double precision, real)
is 'implementation of > operator';

alter function pg_catalog.float84gt(double precision, real)
  owner to postgres;

create function pg_catalog.float84ge(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84ge
;

comment on function pg_catalog.float84ge(double precision, real)
is 'implementation of >= operator';

alter function pg_catalog.float84ge(double precision, real)
  owner to postgres;

create function pg_catalog.float8(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(real)
is 'convert float4 to float8';

alter function pg_catalog.float8(real)
  owner to postgres;

create function pg_catalog.float4(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(double precision)
is 'convert float8 to float4';

alter function pg_catalog.float4(double precision)
  owner to postgres;

create function pg_catalog.int4(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(smallint)
is 'convert int2 to int4';

alter function pg_catalog.int4(smallint)
  owner to postgres;

create function pg_catalog.int2(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(integer)
is 'convert int4 to int2';

alter function pg_catalog.int2(integer)
  owner to postgres;

create function pg_catalog.float8(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(integer)
is 'convert int4 to float8';

alter function pg_catalog.float8(integer)
  owner to postgres;

create function pg_catalog.int4(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(double precision)
is 'convert float8 to int4';

alter function pg_catalog.int4(double precision)
  owner to postgres;

create function pg_catalog.float4(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(integer)
is 'convert int4 to float4';

alter function pg_catalog.float4(integer)
  owner to postgres;

create function pg_catalog.int4(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(real)
is 'convert float4 to int4';

alter function pg_catalog.int4(real)
  owner to postgres;

create function pg_catalog.width_bucket(double precision, double precision, double precision, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width_bucket
;

comment on function pg_catalog.width_bucket(double precision, double precision, double precision, integer)
is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket(double precision, double precision, double precision, integer)
  owner to postgres;

create function pg_catalog.json_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_in
;

comment on function pg_catalog.json_in(cstring)
is 'I/O';

alter function pg_catalog.json_in(cstring)
  owner to postgres;

create function pg_catalog.json_out(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_out
;

comment on function pg_catalog.json_out(json)
is 'I/O';

alter function pg_catalog.json_out(json)
  owner to postgres;

create function pg_catalog.json_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_recv
;

comment on function pg_catalog.json_recv(internal)
is 'I/O';

alter function pg_catalog.json_recv(internal)
  owner to postgres;

create function pg_catalog.json_send(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_send
;

comment on function pg_catalog.json_send(json)
is 'I/O';

alter function pg_catalog.json_send(json)
  owner to postgres;

create function pg_catalog.index_am_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.index_am_handler_in
;

comment on function pg_catalog.index_am_handler_in(cstring)
is 'I/O';

alter function pg_catalog.index_am_handler_in(cstring)
  owner to postgres;

create function pg_catalog.index_am_handler_out(index_am_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.index_am_handler_out
;

comment on function pg_catalog.index_am_handler_out(index_am_handler)
is 'I/O';

alter function pg_catalog.index_am_handler_out(index_am_handler)
  owner to postgres;

create function pg_catalog.hashmacaddr8(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashmacaddr8
;

comment on function pg_catalog.hashmacaddr8(macaddr8)
is 'hash';

alter function pg_catalog.hashmacaddr8(macaddr8)
  owner to postgres;

create function pg_catalog.hash_aclitem(aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_aclitem
;

comment on function pg_catalog.hash_aclitem(aclitem)
is 'hash';

alter function pg_catalog.hash_aclitem(aclitem)
  owner to postgres;

create function pg_catalog.bthandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bthandler
;

comment on function pg_catalog.bthandler(internal)
is 'btree index access method handler';

alter function pg_catalog.bthandler(internal)
  owner to postgres;

create function pg_catalog.hashhandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashhandler
;

comment on function pg_catalog.hashhandler(internal)
is 'hash index access method handler';

alter function pg_catalog.hashhandler(internal)
  owner to postgres;

create function pg_catalog.gisthandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gisthandler
;

comment on function pg_catalog.gisthandler(internal)
is 'gist index access method handler';

alter function pg_catalog.gisthandler(internal)
  owner to postgres;

create function pg_catalog.ginhandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginhandler
;

comment on function pg_catalog.ginhandler(internal)
is 'gin index access method handler';

alter function pg_catalog.ginhandler(internal)
  owner to postgres;

create function pg_catalog.spghandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spghandler
;

comment on function pg_catalog.spghandler(internal)
is 'spgist index access method handler';

alter function pg_catalog.spghandler(internal)
  owner to postgres;

create function pg_catalog.brinhandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brinhandler
;

comment on function pg_catalog.brinhandler(internal)
is 'brin index access method handler';

alter function pg_catalog.brinhandler(internal)
  owner to postgres;

create function pg_catalog.amvalidate(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.amvalidate
;

comment on function pg_catalog.amvalidate(oid)
is 'validate an operator class';

alter function pg_catalog.amvalidate(oid)
  owner to postgres;

create function pg_catalog.poly_same(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_same
;

comment on function pg_catalog.poly_same(polygon, polygon)
is 'implementation of ~= operator';

alter function pg_catalog.poly_same(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_contain(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_contain
;

comment on function pg_catalog.poly_contain(polygon, polygon)
is 'implementation of @> operator';

alter function pg_catalog.poly_contain(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_left(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_left
;

comment on function pg_catalog.poly_left(polygon, polygon)
is 'implementation of << operator';

alter function pg_catalog.poly_left(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_overleft(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overleft
;

comment on function pg_catalog.poly_overleft(polygon, polygon)
is 'implementation of &< operator';

alter function pg_catalog.poly_overleft(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_overright(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overright
;

comment on function pg_catalog.poly_overright(polygon, polygon)
is 'implementation of &> operator';

alter function pg_catalog.poly_overright(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_right(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_right
;

comment on function pg_catalog.poly_right(polygon, polygon)
is 'implementation of >> operator';

alter function pg_catalog.poly_right(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_contained(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_contained
;

comment on function pg_catalog.poly_contained(polygon, polygon)
is 'implementation of <@ operator';

alter function pg_catalog.poly_contained(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_overlap(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overlap
;

comment on function pg_catalog.poly_overlap(polygon, polygon)
is 'implementation of && operator';

alter function pg_catalog.poly_overlap(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_in
;

comment on function pg_catalog.poly_in(cstring)
is 'I/O';

alter function pg_catalog.poly_in(cstring)
  owner to postgres;

create function pg_catalog.poly_out(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_out
;

comment on function pg_catalog.poly_out(polygon)
is 'I/O';

alter function pg_catalog.poly_out(polygon)
  owner to postgres;

create function pg_catalog.btint2cmp(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint2cmp
;

comment on function pg_catalog.btint2cmp(smallint, smallint)
is 'less-equal-greater';

alter function pg_catalog.btint2cmp(smallint, smallint)
  owner to postgres;

create function pg_catalog.btint4cmp(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint4cmp
;

comment on function pg_catalog.btint4cmp(integer, integer)
is 'less-equal-greater';

alter function pg_catalog.btint4cmp(integer, integer)
  owner to postgres;

create function pg_catalog.btfloat4cmp(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat4cmp
;

comment on function pg_catalog.btfloat4cmp(real, real)
is 'less-equal-greater';

alter function pg_catalog.btfloat4cmp(real, real)
  owner to postgres;

create function pg_catalog.btfloat8cmp(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat8cmp
;

comment on function pg_catalog.btfloat8cmp(double precision, double precision)
is 'less-equal-greater';

alter function pg_catalog.btfloat8cmp(double precision, double precision)
  owner to postgres;

create function pg_catalog.btoidcmp(oid, oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btoidcmp
;

comment on function pg_catalog.btoidcmp(oid, oid)
is 'less-equal-greater';

alter function pg_catalog.btoidcmp(oid, oid)
  owner to postgres;

create function pg_catalog.btabstimecmp(abstime, abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btabstimecmp
;

comment on function pg_catalog.btabstimecmp(abstime, abstime)
is 'less-equal-greater';

alter function pg_catalog.btabstimecmp(abstime, abstime)
  owner to postgres;

create function pg_catalog.btcharcmp("char", "char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btcharcmp
;

comment on function pg_catalog.btcharcmp("char", "char")
is 'less-equal-greater';

alter function pg_catalog.btcharcmp("char", "char")
  owner to postgres;

create function pg_catalog.btnamecmp(name, name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btnamecmp
;

comment on function pg_catalog.btnamecmp(name, name)
is 'less-equal-greater';

alter function pg_catalog.btnamecmp(name, name)
  owner to postgres;

create function pg_catalog.bttextcmp(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttextcmp
;

comment on function pg_catalog.bttextcmp(text, text)
is 'less-equal-greater';

alter function pg_catalog.bttextcmp(text, text)
  owner to postgres;

create function pg_catalog.lseg_distance(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_distance
;

comment on function pg_catalog.lseg_distance(lseg, lseg)
is 'implementation of <-> operator';

alter function pg_catalog.lseg_distance(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_interpt(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_interpt
;

comment on function pg_catalog.lseg_interpt(lseg, lseg)
is 'implementation of # operator';

alter function pg_catalog.lseg_interpt(lseg, lseg)
  owner to postgres;

create function pg_catalog.dist_ps(point, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_ps
;

comment on function pg_catalog.dist_ps(point, lseg)
is 'implementation of <-> operator';

alter function pg_catalog.dist_ps(point, lseg)
  owner to postgres;

create function pg_catalog.dist_pb(point, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_pb
;

comment on function pg_catalog.dist_pb(point, box)
is 'implementation of <-> operator';

alter function pg_catalog.dist_pb(point, box)
  owner to postgres;

create function pg_catalog.dist_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_sb
;

comment on function pg_catalog.dist_sb(lseg, box)
is 'implementation of <-> operator';

alter function pg_catalog.dist_sb(lseg, box)
  owner to postgres;

create function pg_catalog.close_ps(point, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_ps
;

comment on function pg_catalog.close_ps(point, lseg)
is 'implementation of ## operator';

alter function pg_catalog.close_ps(point, lseg)
  owner to postgres;

create function pg_catalog.close_pb(point, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_pb
;

comment on function pg_catalog.close_pb(point, box)
is 'implementation of ## operator';

alter function pg_catalog.close_pb(point, box)
  owner to postgres;

create function pg_catalog.close_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_sb
;

comment on function pg_catalog.close_sb(lseg, box)
is 'implementation of ## operator';

alter function pg_catalog.close_sb(lseg, box)
  owner to postgres;

create function pg_catalog.on_ps(point, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_ps
;

comment on function pg_catalog.on_ps(point, lseg)
is 'implementation of <@ operator';

alter function pg_catalog.on_ps(point, lseg)
  owner to postgres;

create function pg_catalog.path_distance(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_distance
;

comment on function pg_catalog.path_distance(path, path)
is 'implementation of <-> operator';

alter function pg_catalog.path_distance(path, path)
  owner to postgres;

create function pg_catalog.dist_ppath(point, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_ppath
;

comment on function pg_catalog.dist_ppath(point, path)
is 'implementation of <-> operator';

alter function pg_catalog.dist_ppath(point, path)
  owner to postgres;

create function pg_catalog.on_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_sb
;

comment on function pg_catalog.on_sb(lseg, box)
is 'implementation of <@ operator';

alter function pg_catalog.on_sb(lseg, box)
  owner to postgres;

create function pg_catalog.inter_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inter_sb
;

comment on function pg_catalog.inter_sb(lseg, box)
is 'implementation of ?# operator';

alter function pg_catalog.inter_sb(lseg, box)
  owner to postgres;

create function pg_catalog.string_to_array(text, text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_to_array
;

comment on function pg_catalog.string_to_array(text, text, text)
is 'split delimited text into text[], with null string';

alter function pg_catalog.string_to_array(text, text, text)
  owner to postgres;

create function pg_catalog.cash_cmp(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_cmp
;

comment on function pg_catalog.cash_cmp(money, money)
is 'less-equal-greater';

alter function pg_catalog.cash_cmp(money, money)
  owner to postgres;

create function pg_catalog.array_append(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_append
;

comment on function pg_catalog.array_append(anyarray, anyelement)
is 'append element onto end of array';

alter function pg_catalog.array_append(anyarray, anyelement)
  owner to postgres;

create function pg_catalog.array_prepend(anyelement, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_prepend
;

comment on function pg_catalog.array_prepend(anyelement, anyarray)
is 'prepend element onto front of array';

alter function pg_catalog.array_prepend(anyelement, anyarray)
  owner to postgres;

create function pg_catalog.btreltimecmp(reltime, reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btreltimecmp
;

comment on function pg_catalog.btreltimecmp(reltime, reltime)
is 'less-equal-greater';

alter function pg_catalog.btreltimecmp(reltime, reltime)
  owner to postgres;

create function pg_catalog.bttintervalcmp(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttintervalcmp
;

comment on function pg_catalog.bttintervalcmp(tinterval, tinterval)
is 'less-equal-greater';

alter function pg_catalog.bttintervalcmp(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.btarraycmp(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btarraycmp
;

comment on function pg_catalog.btarraycmp(anyarray, anyarray)
is 'less-equal-greater';

alter function pg_catalog.btarraycmp(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.array_cat(anyarray, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_cat
;

comment on function pg_catalog.array_cat(anyarray, anyarray)
is 'implementation of || operator';

alter function pg_catalog.array_cat(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.array_to_string(anyarray, text, text)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_string
;

comment on function pg_catalog.array_to_string(anyarray, text, text)
is 'concatenate array elements, using delimiter and null string, into text';

alter function pg_catalog.array_to_string(anyarray, text, text)
  owner to postgres;

create function pg_catalog.array_ne(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_ne
;

comment on function pg_catalog.array_ne(anyarray, anyarray)
is 'implementation of <> operator';

alter function pg_catalog.array_ne(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.array_lt(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_lt
;

comment on function pg_catalog.array_lt(anyarray, anyarray)
is 'implementation of < operator';

alter function pg_catalog.array_lt(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.array_gt(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_gt
;

comment on function pg_catalog.array_gt(anyarray, anyarray)
is 'implementation of > operator';

alter function pg_catalog.array_gt(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.array_le(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_le
;

comment on function pg_catalog.array_le(anyarray, anyarray)
is 'implementation of <= operator';

alter function pg_catalog.array_le(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.string_to_array(text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_to_array
;

comment on function pg_catalog.string_to_array(text, text)
is 'split delimited text into text[]';

alter function pg_catalog.string_to_array(text, text)
  owner to postgres;

create function pg_catalog.array_to_string(anyarray, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_string
;

comment on function pg_catalog.array_to_string(anyarray, text)
is 'concatenate array elements, using delimiter, into text';

alter function pg_catalog.array_to_string(anyarray, text)
  owner to postgres;

create function pg_catalog.array_ge(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_ge
;

comment on function pg_catalog.array_ge(anyarray, anyarray)
is 'implementation of >= operator';

alter function pg_catalog.array_ge(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.hashmacaddr(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashmacaddr
;

comment on function pg_catalog.hashmacaddr(macaddr)
is 'hash';

alter function pg_catalog.hashmacaddr(macaddr)
  owner to postgres;

create function pg_catalog.hashtext(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashtext
;

comment on function pg_catalog.hashtext(text)
is 'hash';

alter function pg_catalog.hashtext(text)
  owner to postgres;

create function pg_catalog.text(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(char)
is 'convert char(n) to text';

alter function pg_catalog.text(char)
  owner to postgres;

create function pg_catalog.btoidvectorcmp(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btoidvectorcmp
;

comment on function pg_catalog.btoidvectorcmp(oidvector, oidvector)
is 'less-equal-greater';

alter function pg_catalog.btoidvectorcmp(oidvector, oidvector)
  owner to postgres;

create function pg_catalog.text(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(name)
is 'convert name to text';

alter function pg_catalog.text(name)
  owner to postgres;

create function pg_catalog.name(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.name
;

comment on function pg_catalog.name(text)
is 'convert text to name';

alter function pg_catalog.name(text)
  owner to postgres;

create function pg_catalog.bpchar(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar
;

comment on function pg_catalog.bpchar(name)
is 'convert name to char(n)';

alter function pg_catalog.bpchar(name)
  owner to postgres;

create function pg_catalog.name(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.name
;

comment on function pg_catalog.name(char)
is 'convert char(n) to name';

alter function pg_catalog.name(char)
  owner to postgres;

create function pg_catalog.hashinet(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashinet
;

comment on function pg_catalog.hashinet(inet)
is 'hash';

alter function pg_catalog.hashinet(inet)
  owner to postgres;

create function pg_catalog.hash_numeric(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_numeric
;

comment on function pg_catalog.hash_numeric(numeric)
is 'hash';

alter function pg_catalog.hash_numeric(numeric)
  owner to postgres;

create function pg_catalog.macaddr_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_in
;

comment on function pg_catalog.macaddr_in(cstring)
is 'I/O';

alter function pg_catalog.macaddr_in(cstring)
  owner to postgres;

create function pg_catalog.macaddr_out(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_out
;

comment on function pg_catalog.macaddr_out(macaddr)
is 'I/O';

alter function pg_catalog.macaddr_out(macaddr)
  owner to postgres;

create function pg_catalog.num_nulls("any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.num_nulls
;

comment on function pg_catalog.num_nulls("any")
is 'count the number of NULL arguments';

alter function pg_catalog.num_nulls("any")
  owner to postgres;

create function pg_catalog.num_nonnulls("any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.num_nonnulls
;

comment on function pg_catalog.num_nonnulls("any")
is 'count the number of non-NULL arguments';

alter function pg_catalog.num_nonnulls("any")
  owner to postgres;

create function pg_catalog.hashint2(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint2
;

comment on function pg_catalog.hashint2(smallint)
is 'hash';

alter function pg_catalog.hashint2(smallint)
  owner to postgres;

create function pg_catalog.hashint4(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint4
;

comment on function pg_catalog.hashint4(integer)
is 'hash';

alter function pg_catalog.hashint4(integer)
  owner to postgres;

create function pg_catalog.hashfloat4(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashfloat4
;

comment on function pg_catalog.hashfloat4(real)
is 'hash';

alter function pg_catalog.hashfloat4(real)
  owner to postgres;

create function pg_catalog.hashfloat8(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashfloat8
;

comment on function pg_catalog.hashfloat8(double precision)
is 'hash';

alter function pg_catalog.hashfloat8(double precision)
  owner to postgres;

create function pg_catalog.hashoid(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashoid
;

comment on function pg_catalog.hashoid(oid)
is 'hash';

alter function pg_catalog.hashoid(oid)
  owner to postgres;

create function pg_catalog.hashchar("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashchar
;

comment on function pg_catalog.hashchar("char")
is 'hash';

alter function pg_catalog.hashchar("char")
  owner to postgres;

create function pg_catalog.hashname(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashname
;

comment on function pg_catalog.hashname(name)
is 'hash';

alter function pg_catalog.hashname(name)
  owner to postgres;

create function pg_catalog.hashvarlena(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashvarlena
;

comment on function pg_catalog.hashvarlena(internal)
is 'hash';

alter function pg_catalog.hashvarlena(internal)
  owner to postgres;

create function pg_catalog.hashoidvector(oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashoidvector
;

comment on function pg_catalog.hashoidvector(oidvector)
is 'hash';

alter function pg_catalog.hashoidvector(oidvector)
  owner to postgres;

create function pg_catalog.text_larger(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_larger
;

comment on function pg_catalog.text_larger(text, text)
is 'larger of two';

alter function pg_catalog.text_larger(text, text)
  owner to postgres;

create function pg_catalog.text_smaller(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_smaller
;

comment on function pg_catalog.text_smaller(text, text)
is 'smaller of two';

alter function pg_catalog.text_smaller(text, text)
  owner to postgres;

create function pg_catalog.int8in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8in
;

comment on function pg_catalog.int8in(cstring)
is 'I/O';

alter function pg_catalog.int8in(cstring)
  owner to postgres;

create function pg_catalog.int8out(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8out
;

comment on function pg_catalog.int8out(bigint)
is 'I/O';

alter function pg_catalog.int8out(bigint)
  owner to postgres;

create function pg_catalog.int8um(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8um
;

comment on function pg_catalog.int8um(bigint)
is 'implementation of - operator';

alter function pg_catalog.int8um(bigint)
  owner to postgres;

create function pg_catalog.int8pl(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8pl
;

comment on function pg_catalog.int8pl(bigint, bigint)
is 'implementation of + operator';

alter function pg_catalog.int8pl(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8mi(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8mi
;

comment on function pg_catalog.int8mi(bigint, bigint)
is 'implementation of - operator';

alter function pg_catalog.int8mi(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8mul(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8mul
;

comment on function pg_catalog.int8mul(bigint, bigint)
is 'implementation of * operator';

alter function pg_catalog.int8mul(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8div(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8div
;

comment on function pg_catalog.int8div(bigint, bigint)
is 'implementation of / operator';

alter function pg_catalog.int8div(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8eq(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8eq
;

comment on function pg_catalog.int8eq(bigint, bigint)
is 'implementation of = operator';

alter function pg_catalog.int8eq(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8ne(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8ne
;

comment on function pg_catalog.int8ne(bigint, bigint)
is 'implementation of <> operator';

alter function pg_catalog.int8ne(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8lt(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8lt
;

comment on function pg_catalog.int8lt(bigint, bigint)
is 'implementation of < operator';

alter function pg_catalog.int8lt(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8gt(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8gt
;

comment on function pg_catalog.int8gt(bigint, bigint)
is 'implementation of > operator';

alter function pg_catalog.int8gt(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8le(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8le
;

comment on function pg_catalog.int8le(bigint, bigint)
is 'implementation of <= operator';

alter function pg_catalog.int8le(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8ge(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8ge
;

comment on function pg_catalog.int8ge(bigint, bigint)
is 'implementation of >= operator';

alter function pg_catalog.int8ge(bigint, bigint)
  owner to postgres;

create function pg_catalog.int84eq(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84eq
;

comment on function pg_catalog.int84eq(bigint, integer)
is 'implementation of = operator';

alter function pg_catalog.int84eq(bigint, integer)
  owner to postgres;

create function pg_catalog.int84ne(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84ne
;

comment on function pg_catalog.int84ne(bigint, integer)
is 'implementation of <> operator';

alter function pg_catalog.int84ne(bigint, integer)
  owner to postgres;

create function pg_catalog.int84lt(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84lt
;

comment on function pg_catalog.int84lt(bigint, integer)
is 'implementation of < operator';

alter function pg_catalog.int84lt(bigint, integer)
  owner to postgres;

create function pg_catalog.int84gt(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84gt
;

comment on function pg_catalog.int84gt(bigint, integer)
is 'implementation of > operator';

alter function pg_catalog.int84gt(bigint, integer)
  owner to postgres;

create function pg_catalog.int84le(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84le
;

comment on function pg_catalog.int84le(bigint, integer)
is 'implementation of <= operator';

alter function pg_catalog.int84le(bigint, integer)
  owner to postgres;

create function pg_catalog.int84ge(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84ge
;

comment on function pg_catalog.int84ge(bigint, integer)
is 'implementation of >= operator';

alter function pg_catalog.int84ge(bigint, integer)
  owner to postgres;

create function pg_catalog.int4(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(bigint)
is 'convert int8 to int4';

alter function pg_catalog.int4(bigint)
  owner to postgres;

create function pg_catalog.int8(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(integer)
is 'convert int4 to int8';

alter function pg_catalog.int8(integer)
  owner to postgres;

create function pg_catalog.float8(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(bigint)
is 'convert int8 to float8';

alter function pg_catalog.float8(bigint)
  owner to postgres;

create function pg_catalog.int8(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(double precision)
is 'convert float8 to int8';

alter function pg_catalog.int8(double precision)
  owner to postgres;

create function pg_catalog.array_larger(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_larger
;

comment on function pg_catalog.array_larger(anyarray, anyarray)
is 'larger of two';

alter function pg_catalog.array_larger(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.array_smaller(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_smaller
;

comment on function pg_catalog.array_smaller(anyarray, anyarray)
is 'smaller of two';

alter function pg_catalog.array_smaller(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.abbrev(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abbrev
;

comment on function pg_catalog.abbrev(inet)
is 'abbreviated display of inet value';

alter function pg_catalog.abbrev(inet)
  owner to postgres;

create function pg_catalog.abbrev(cidr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abbrev
;

comment on function pg_catalog.abbrev(cidr)
is 'abbreviated display of cidr value';

alter function pg_catalog.abbrev(cidr)
  owner to postgres;

create function pg_catalog.set_masklen(inet, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_masklen
;

comment on function pg_catalog.set_masklen(inet, integer)
is 'change netmask of inet';

alter function pg_catalog.set_masklen(inet, integer)
  owner to postgres;

create function pg_catalog.oidvectorne(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorne
;

comment on function pg_catalog.oidvectorne(oidvector, oidvector)
is 'implementation of <> operator';

alter function pg_catalog.oidvectorne(oidvector, oidvector)
  owner to postgres;

create function pg_catalog.hash_array(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_array
;

comment on function pg_catalog.hash_array(anyarray)
is 'hash';

alter function pg_catalog.hash_array(anyarray)
  owner to postgres;

create function pg_catalog.set_masklen(cidr, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_masklen
;

comment on function pg_catalog.set_masklen(cidr, integer)
is 'change netmask of cidr';

alter function pg_catalog.set_masklen(cidr, integer)
  owner to postgres;

create function pg_catalog.pg_indexam_has_property(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_indexam_has_property
;

comment on function pg_catalog.pg_indexam_has_property(oid, text)
is 'test property of an index access method';

alter function pg_catalog.pg_indexam_has_property(oid, text)
  owner to postgres;

create function pg_catalog.pg_index_has_property(regclass, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_index_has_property
;

comment on function pg_catalog.pg_index_has_property(regclass, text)
is 'test property of an index';

alter function pg_catalog.pg_index_has_property(regclass, text)
  owner to postgres;

create function pg_catalog.pg_index_column_has_property(regclass, integer, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_index_column_has_property
;

comment on function pg_catalog.pg_index_column_has_property(regclass, integer, text)
is 'test property of an index column';

alter function pg_catalog.pg_index_column_has_property(regclass, integer, text)
  owner to postgres;

create function pg_catalog.float4(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(bigint)
is 'convert int8 to float4';

alter function pg_catalog.float4(bigint)
  owner to postgres;

create function pg_catalog.int8(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(real)
is 'convert float4 to int8';

alter function pg_catalog.int8(real)
  owner to postgres;

create function pg_catalog.namelt(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namelt
;

comment on function pg_catalog.namelt(name, name)
is 'implementation of < operator';

alter function pg_catalog.namelt(name, name)
  owner to postgres;

create function pg_catalog.namele(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namele
;

comment on function pg_catalog.namele(name, name)
is 'implementation of <= operator';

alter function pg_catalog.namele(name, name)
  owner to postgres;

create function pg_catalog.namegt(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namegt
;

comment on function pg_catalog.namegt(name, name)
is 'implementation of > operator';

alter function pg_catalog.namegt(name, name)
  owner to postgres;

create function pg_catalog.namege(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namege
;

comment on function pg_catalog.namege(name, name)
is 'implementation of >= operator';

alter function pg_catalog.namege(name, name)
  owner to postgres;

create function pg_catalog.namene(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namene
;

comment on function pg_catalog.namene(name, name)
is 'implementation of <> operator';

alter function pg_catalog.namene(name, name)
  owner to postgres;

create function pg_catalog.bpchar(char, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar
;

comment on function pg_catalog.bpchar(char, integer, boolean)
is 'adjust char() to typmod length';

alter function pg_catalog.bpchar(char, integer, boolean)
  owner to postgres;

create function pg_catalog.varchar(varchar, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchar
;

comment on function pg_catalog.varchar(varchar, integer, boolean)
is 'adjust varchar() to typmod length';

alter function pg_catalog.varchar(varchar, integer, boolean)
  owner to postgres;

create function pg_catalog.mktinterval(abstime, abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mktinterval
;

comment on function pg_catalog.mktinterval(abstime, abstime)
is 'implementation of <#> operator';

alter function pg_catalog.mktinterval(abstime, abstime)
  owner to postgres;

create function pg_catalog.oidvectorlt(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorlt
;

comment on function pg_catalog.oidvectorlt(oidvector, oidvector)
is 'implementation of < operator';

alter function pg_catalog.oidvectorlt(oidvector, oidvector)
  owner to postgres;

create function pg_catalog.oidvectorle(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorle
;

comment on function pg_catalog.oidvectorle(oidvector, oidvector)
is 'implementation of <= operator';

alter function pg_catalog.oidvectorle(oidvector, oidvector)
  owner to postgres;

create function pg_catalog.oidvectoreq(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectoreq
;

comment on function pg_catalog.oidvectoreq(oidvector, oidvector)
is 'implementation of = operator';

alter function pg_catalog.oidvectoreq(oidvector, oidvector)
  owner to postgres;

create function pg_catalog.oidvectorge(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorge
;

comment on function pg_catalog.oidvectorge(oidvector, oidvector)
is 'implementation of >= operator';

alter function pg_catalog.oidvectorge(oidvector, oidvector)
  owner to postgres;

create function pg_catalog.oidvectorgt(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorgt
;

comment on function pg_catalog.oidvectorgt(oidvector, oidvector)
is 'implementation of > operator';

alter function pg_catalog.oidvectorgt(oidvector, oidvector)
  owner to postgres;

create function pg_catalog.network(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network
;

comment on function pg_catalog.network(inet)
is 'network part of address';

alter function pg_catalog.network(inet)
  owner to postgres;

create function pg_catalog.netmask(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.netmask
;

comment on function pg_catalog.netmask(inet)
is 'netmask of address';

alter function pg_catalog.netmask(inet)
  owner to postgres;

create function pg_catalog.masklen(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.masklen
;

comment on function pg_catalog.masklen(inet)
is 'netmask length';

alter function pg_catalog.masklen(inet)
  owner to postgres;

create function pg_catalog.broadcast(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.broadcast
;

comment on function pg_catalog.broadcast(inet)
is 'broadcast address of network';

alter function pg_catalog.broadcast(inet)
  owner to postgres;

create function pg_catalog.host(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.host
;

comment on function pg_catalog.host(inet)
is 'show address octets only';

alter function pg_catalog.host(inet)
  owner to postgres;

create function pg_catalog.getpgusername()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.getpgusername
;

comment on function pg_catalog.getpgusername()
is 'deprecated, use current_user instead';

alter function pg_catalog.getpgusername()
  owner to postgres;

create function pg_catalog.family(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.family
;

comment on function pg_catalog.family(inet)
is 'address family (4 for IPv4, 6 for IPv6)';

alter function pg_catalog.family(inet)
  owner to postgres;

create function pg_catalog.int2(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(bigint)
is 'convert int8 to int2';

alter function pg_catalog.int2(bigint)
  owner to postgres;

create function pg_catalog.lo_create(oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_create
;

comment on function pg_catalog.lo_create(oid)
is 'large object create';

alter function pg_catalog.lo_create(oid)
  owner to postgres;

create function pg_catalog.oidlt(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidlt
;

comment on function pg_catalog.oidlt(oid, oid)
is 'implementation of < operator';

alter function pg_catalog.oidlt(oid, oid)
  owner to postgres;

create function pg_catalog.oidle(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidle
;

comment on function pg_catalog.oidle(oid, oid)
is 'implementation of <= operator';

alter function pg_catalog.oidle(oid, oid)
  owner to postgres;

create function pg_catalog.octet_length(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(bytea)
is 'octet length';

alter function pg_catalog.octet_length(bytea)
  owner to postgres;

create function pg_catalog.get_byte(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_byte
;

comment on function pg_catalog.get_byte(bytea, integer)
is 'get byte';

alter function pg_catalog.get_byte(bytea, integer)
  owner to postgres;

create function pg_catalog.set_byte(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_byte
;

comment on function pg_catalog.set_byte(bytea, integer, integer)
is 'set byte';

alter function pg_catalog.set_byte(bytea, integer, integer)
  owner to postgres;

create function pg_catalog.get_bit(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_bit
;

comment on function pg_catalog.get_bit(bytea, integer)
is 'get bit';

alter function pg_catalog.get_bit(bytea, integer)
  owner to postgres;

create function pg_catalog.set_bit(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_bit
;

comment on function pg_catalog.set_bit(bytea, integer, integer)
is 'set bit';

alter function pg_catalog.set_bit(bytea, integer, integer)
  owner to postgres;

create function pg_catalog.dist_pl(point, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_pl
;

comment on function pg_catalog.dist_pl(point, line)
is 'implementation of <-> operator';

alter function pg_catalog.dist_pl(point, line)
  owner to postgres;

create function pg_catalog.dist_lb(line, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_lb
;

comment on function pg_catalog.dist_lb(line, box)
is 'implementation of <-> operator';

alter function pg_catalog.dist_lb(line, box)
  owner to postgres;

create function pg_catalog.dist_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_sl
;

comment on function pg_catalog.dist_sl(lseg, line)
is 'implementation of <-> operator';

alter function pg_catalog.dist_sl(lseg, line)
  owner to postgres;

create function pg_catalog.dist_cpoly(circle, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_cpoly
;

comment on function pg_catalog.dist_cpoly(circle, polygon)
is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoly(circle, polygon)
  owner to postgres;

create function pg_catalog.poly_distance(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_distance
;

comment on function pg_catalog.poly_distance(polygon, polygon)
is 'implementation of <-> operator';

alter function pg_catalog.poly_distance(polygon, polygon)
  owner to postgres;

create function pg_catalog.text(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(inet)
is 'show all parts of inet/cidr value';

alter function pg_catalog.text(inet)
  owner to postgres;

create function pg_catalog.text_lt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_lt
;

comment on function pg_catalog.text_lt(text, text)
is 'implementation of < operator';

alter function pg_catalog.text_lt(text, text)
  owner to postgres;

create function pg_catalog.text_le(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_le
;

comment on function pg_catalog.text_le(text, text)
is 'implementation of <= operator';

alter function pg_catalog.text_le(text, text)
  owner to postgres;

create function pg_catalog.text_gt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_gt
;

comment on function pg_catalog.text_gt(text, text)
is 'implementation of > operator';

alter function pg_catalog.text_gt(text, text)
  owner to postgres;

create function pg_catalog.text_ge(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_ge
;

comment on function pg_catalog.text_ge(text, text)
is 'implementation of >= operator';

alter function pg_catalog.text_ge(text, text)
  owner to postgres;

create function pg_catalog.array_eq(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_eq
;

comment on function pg_catalog.array_eq(anyarray, anyarray)
is 'implementation of = operator';

alter function pg_catalog.array_eq(anyarray, anyarray)
  owner to postgres;

create function pg_catalog."current_user"()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."current_user"
;

comment on function pg_catalog."current_user"()
is 'current user name';

alter function pg_catalog."current_user"()
  owner to postgres;

create function pg_catalog."session_user"()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."session_user"
;

comment on function pg_catalog."session_user"()
is 'session user name';

alter function pg_catalog."session_user"()
  owner to postgres;

create function pg_catalog.array_dims(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_dims
;

comment on function pg_catalog.array_dims(anyarray)
is 'array dimensions';

alter function pg_catalog.array_dims(anyarray)
  owner to postgres;

create function pg_catalog.array_ndims(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_ndims
;

comment on function pg_catalog.array_ndims(anyarray)
is 'number of array dimensions';

alter function pg_catalog.array_ndims(anyarray)
  owner to postgres;

create function pg_catalog.overlay(bytea, bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bytea, bytea, integer, integer)
is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea, integer, integer)
  owner to postgres;

create function pg_catalog.array_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_in
;

comment on function pg_catalog.array_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.array_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.array_out(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_out
;

comment on function pg_catalog.array_out(anyarray)
is 'I/O';

alter function pg_catalog.array_out(anyarray)
  owner to postgres;

create function pg_catalog.overlay(bytea, bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bytea, bytea, integer)
is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea, integer)
  owner to postgres;

create function pg_catalog.trunc(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(macaddr)
is 'MACADDR manufacturer fields';

alter function pg_catalog.trunc(macaddr)
  owner to postgres;

create function pg_catalog.int8(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(smallint)
is 'convert int2 to int8';

alter function pg_catalog.int8(smallint)
  owner to postgres;

create function pg_catalog.smgrin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgrin
;

comment on function pg_catalog.smgrin(cstring)
is 'I/O';

alter function pg_catalog.smgrin(cstring)
  owner to postgres;

create function pg_catalog.smgrout(smgr)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgrout
;

comment on function pg_catalog.smgrout(smgr)
is 'I/O';

alter function pg_catalog.smgrout(smgr)
  owner to postgres;

create function pg_catalog.smgreq(smgr, smgr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgreq
;

comment on function pg_catalog.smgreq(smgr, smgr)
is 'storage manager';

alter function pg_catalog.smgreq(smgr, smgr)
  owner to postgres;

create function pg_catalog.smgrne(smgr, smgr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgrne
;

comment on function pg_catalog.smgrne(smgr, smgr)
is 'storage manager';

alter function pg_catalog.smgrne(smgr, smgr)
  owner to postgres;

create function pg_catalog.lo_import(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_import
;

comment on function pg_catalog.lo_import(text)
is 'large object import';

alter function pg_catalog.lo_import(text)
  owner to postgres;

create function pg_catalog.lo_export(oid, text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_export
;

comment on function pg_catalog.lo_export(oid, text)
is 'large object export';

alter function pg_catalog.lo_export(oid, text)
  owner to postgres;

create function pg_catalog.int4inc(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4inc
;

comment on function pg_catalog.int4inc(integer)
is 'increment';

alter function pg_catalog.int4inc(integer)
  owner to postgres;

create function pg_catalog.lo_import(text, oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_import
;

comment on function pg_catalog.lo_import(text, oid)
is 'large object import';

alter function pg_catalog.lo_import(text, oid)
  owner to postgres;

create function pg_catalog.int4larger(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4larger
;

comment on function pg_catalog.int4larger(integer, integer)
is 'larger of two';

alter function pg_catalog.int4larger(integer, integer)
  owner to postgres;

create function pg_catalog.int4smaller(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4smaller
;

comment on function pg_catalog.int4smaller(integer, integer)
is 'smaller of two';

alter function pg_catalog.int4smaller(integer, integer)
  owner to postgres;

create function pg_catalog.int2larger(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2larger
;

comment on function pg_catalog.int2larger(smallint, smallint)
is 'larger of two';

alter function pg_catalog.int2larger(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2smaller(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2smaller
;

comment on function pg_catalog.int2smaller(smallint, smallint)
is 'smaller of two';

alter function pg_catalog.int2smaller(smallint, smallint)
  owner to postgres;

create function pg_catalog.tintervaleq(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervaleq
;

comment on function pg_catalog.tintervaleq(tinterval, tinterval)
is 'implementation of = operator';

alter function pg_catalog.tintervaleq(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervalne(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalne
;

comment on function pg_catalog.tintervalne(tinterval, tinterval)
is 'implementation of <> operator';

alter function pg_catalog.tintervalne(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervallt(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallt
;

comment on function pg_catalog.tintervallt(tinterval, tinterval)
is 'implementation of < operator';

alter function pg_catalog.tintervallt(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervalgt(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalgt
;

comment on function pg_catalog.tintervalgt(tinterval, tinterval)
is 'implementation of > operator';

alter function pg_catalog.tintervalgt(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervalle(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalle
;

comment on function pg_catalog.tintervalle(tinterval, tinterval)
is 'implementation of <= operator';

alter function pg_catalog.tintervalle(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.tintervalge(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalge
;

comment on function pg_catalog.tintervalge(tinterval, tinterval)
is 'implementation of >= operator';

alter function pg_catalog.tintervalge(tinterval, tinterval)
  owner to postgres;

create function pg_catalog.pg_client_encoding()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_client_encoding
;

comment on function pg_catalog.pg_client_encoding()
is 'encoding name of current database';

alter function pg_catalog.pg_client_encoding()
  owner to postgres;

create function pg_catalog.current_query()
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.current_query
;

comment on function pg_catalog.current_query()
is 'get the currently executing query';

alter function pg_catalog.current_query()
  owner to postgres;

create function pg_catalog.macaddr_eq(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_eq
;

comment on function pg_catalog.macaddr_eq(macaddr, macaddr)
is 'implementation of = operator';

alter function pg_catalog.macaddr_eq(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.macaddr_lt(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_lt
;

comment on function pg_catalog.macaddr_lt(macaddr, macaddr)
is 'implementation of < operator';

alter function pg_catalog.macaddr_lt(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.macaddr_le(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_le
;

comment on function pg_catalog.macaddr_le(macaddr, macaddr)
is 'implementation of <= operator';

alter function pg_catalog.macaddr_le(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.macaddr_gt(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_gt
;

comment on function pg_catalog.macaddr_gt(macaddr, macaddr)
is 'implementation of > operator';

alter function pg_catalog.macaddr_gt(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.macaddr_ge(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_ge
;

comment on function pg_catalog.macaddr_ge(macaddr, macaddr)
is 'implementation of >= operator';

alter function pg_catalog.macaddr_ge(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.macaddr_ne(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_ne
;

comment on function pg_catalog.macaddr_ne(macaddr, macaddr)
is 'implementation of <> operator';

alter function pg_catalog.macaddr_ne(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.macaddr_cmp(macaddr, macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_cmp
;

comment on function pg_catalog.macaddr_cmp(macaddr, macaddr)
is 'less-equal-greater';

alter function pg_catalog.macaddr_cmp(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.int82pl(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82pl
;

comment on function pg_catalog.int82pl(bigint, smallint)
is 'implementation of + operator';

alter function pg_catalog.int82pl(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82mi(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82mi
;

comment on function pg_catalog.int82mi(bigint, smallint)
is 'implementation of - operator';

alter function pg_catalog.int82mi(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82mul(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82mul
;

comment on function pg_catalog.int82mul(bigint, smallint)
is 'implementation of * operator';

alter function pg_catalog.int82mul(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82div(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82div
;

comment on function pg_catalog.int82div(bigint, smallint)
is 'implementation of / operator';

alter function pg_catalog.int82div(bigint, smallint)
  owner to postgres;

create function pg_catalog.int28pl(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28pl
;

comment on function pg_catalog.int28pl(smallint, bigint)
is 'implementation of + operator';

alter function pg_catalog.int28pl(smallint, bigint)
  owner to postgres;

create function pg_catalog.btint8cmp(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint8cmp
;

comment on function pg_catalog.btint8cmp(bigint, bigint)
is 'less-equal-greater';

alter function pg_catalog.btint8cmp(bigint, bigint)
  owner to postgres;

create function pg_catalog.cash_mul_flt4(money, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_flt4
;

comment on function pg_catalog.cash_mul_flt4(money, real)
is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt4(money, real)
  owner to postgres;

create function pg_catalog.cash_div_flt4(money, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_flt4
;

comment on function pg_catalog.cash_div_flt4(money, real)
is 'implementation of / operator';

alter function pg_catalog.cash_div_flt4(money, real)
  owner to postgres;

create function pg_catalog.flt4_mul_cash(real, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.flt4_mul_cash
;

comment on function pg_catalog.flt4_mul_cash(real, money)
is 'implementation of * operator';

alter function pg_catalog.flt4_mul_cash(real, money)
  owner to postgres;

create function pg_catalog.position(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.position
;

comment on function pg_catalog.position(text, text)
is 'position of substring';

alter function pg_catalog.position(text, text)
  owner to postgres;

create function pg_catalog.textlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textlike
;

comment on function pg_catalog.textlike(text, text)
is 'implementation of ~~ operator';

alter function pg_catalog.textlike(text, text)
  owner to postgres;

create function pg_catalog.textnlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textnlike
;

comment on function pg_catalog.textnlike(text, text)
is 'implementation of !~~ operator';

alter function pg_catalog.textnlike(text, text)
  owner to postgres;

create function pg_catalog.int48eq(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48eq
;

comment on function pg_catalog.int48eq(integer, bigint)
is 'implementation of = operator';

alter function pg_catalog.int48eq(integer, bigint)
  owner to postgres;

create function pg_catalog.int48ne(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48ne
;

comment on function pg_catalog.int48ne(integer, bigint)
is 'implementation of <> operator';

alter function pg_catalog.int48ne(integer, bigint)
  owner to postgres;

create function pg_catalog.int48lt(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48lt
;

comment on function pg_catalog.int48lt(integer, bigint)
is 'implementation of < operator';

alter function pg_catalog.int48lt(integer, bigint)
  owner to postgres;

create function pg_catalog.int48gt(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48gt
;

comment on function pg_catalog.int48gt(integer, bigint)
is 'implementation of > operator';

alter function pg_catalog.int48gt(integer, bigint)
  owner to postgres;

create function pg_catalog.int48le(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48le
;

comment on function pg_catalog.int48le(integer, bigint)
is 'implementation of <= operator';

alter function pg_catalog.int48le(integer, bigint)
  owner to postgres;

create function pg_catalog.int48ge(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48ge
;

comment on function pg_catalog.int48ge(integer, bigint)
is 'implementation of >= operator';

alter function pg_catalog.int48ge(integer, bigint)
  owner to postgres;

create function pg_catalog.namelike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namelike
;

comment on function pg_catalog.namelike(name, text)
is 'implementation of ~~ operator';

alter function pg_catalog.namelike(name, text)
  owner to postgres;

create function pg_catalog.namenlike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namenlike
;

comment on function pg_catalog.namenlike(name, text)
is 'implementation of !~~ operator';

alter function pg_catalog.namenlike(name, text)
  owner to postgres;

create function pg_catalog.bpchar("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar
;

comment on function pg_catalog.bpchar("char")
is 'convert char to char(n)';

alter function pg_catalog.bpchar("char")
  owner to postgres;

create function pg_catalog.current_database()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_database
;

comment on function pg_catalog.current_database()
is 'name of the current database';

alter function pg_catalog.current_database()
  owner to postgres;

create function pg_catalog.int4_mul_cash(integer, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_mul_cash
;

comment on function pg_catalog.int4_mul_cash(integer, money)
is 'implementation of * operator';

alter function pg_catalog.int4_mul_cash(integer, money)
  owner to postgres;

create function pg_catalog.int2_mul_cash(smallint, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_mul_cash
;

comment on function pg_catalog.int2_mul_cash(smallint, money)
is 'implementation of * operator';

alter function pg_catalog.int2_mul_cash(smallint, money)
  owner to postgres;

create function pg_catalog.cash_mul_int4(money, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_int4
;

comment on function pg_catalog.cash_mul_int4(money, integer)
is 'implementation of * operator';

alter function pg_catalog.cash_mul_int4(money, integer)
  owner to postgres;

create function pg_catalog.cash_div_int4(money, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_int4
;

comment on function pg_catalog.cash_div_int4(money, integer)
is 'implementation of / operator';

alter function pg_catalog.cash_div_int4(money, integer)
  owner to postgres;

create function pg_catalog.cash_mul_int2(money, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_int2
;

comment on function pg_catalog.cash_mul_int2(money, smallint)
is 'implementation of * operator';

alter function pg_catalog.cash_mul_int2(money, smallint)
  owner to postgres;

create function pg_catalog.cash_div_int2(money, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_int2
;

comment on function pg_catalog.cash_div_int2(money, smallint)
is 'implementation of / operator';

alter function pg_catalog.cash_div_int2(money, smallint)
  owner to postgres;

create function pg_catalog.strpos(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.strpos
;

comment on function pg_catalog.strpos(text, text)
is 'position of substring';

alter function pg_catalog.strpos(text, text)
  owner to postgres;

create function pg_catalog.lower(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower
;

comment on function pg_catalog.lower(text)
is 'lowercase';

alter function pg_catalog.lower(text)
  owner to postgres;

create function pg_catalog.upper(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper
;

comment on function pg_catalog.upper(text)
is 'uppercase';

alter function pg_catalog.upper(text)
  owner to postgres;

create function pg_catalog.initcap(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.initcap
;

comment on function pg_catalog.initcap(text)
is 'capitalize each word';

alter function pg_catalog.initcap(text)
  owner to postgres;

create function pg_catalog.lpad(text, integer, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lpad
;

comment on function pg_catalog.lpad(text, integer, text)
is 'left-pad string to length';

alter function pg_catalog.lpad(text, integer, text)
  owner to postgres;

create function pg_catalog.rpad(text, integer, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rpad
;

comment on function pg_catalog.rpad(text, integer, text)
is 'right-pad string to length';

alter function pg_catalog.rpad(text, integer, text)
  owner to postgres;

create function pg_catalog.ltrim(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ltrim
;

comment on function pg_catalog.ltrim(text, text)
is 'trim selected characters from left end of string';

alter function pg_catalog.ltrim(text, text)
  owner to postgres;

create function pg_catalog.rtrim(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rtrim
;

comment on function pg_catalog.rtrim(text, text)
is 'trim selected characters from right end of string';

alter function pg_catalog.rtrim(text, text)
  owner to postgres;

create function pg_catalog.substr(text, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(text, integer, integer)
is 'extract portion of string';

alter function pg_catalog.substr(text, integer, integer)
  owner to postgres;

create function pg_catalog.translate(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.translate
;

comment on function pg_catalog.translate(text, text, text)
is 'map a set of characters appearing in string';

alter function pg_catalog.translate(text, text, text)
  owner to postgres;

create function pg_catalog.lpad(text, integer)
  returns text
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.lpad($1, $2, ' ')
$$;

comment on function pg_catalog.lpad(text, integer)
is 'left-pad string to length';

alter function pg_catalog.lpad(text, integer)
  owner to postgres;

create function pg_catalog.rpad(text, integer)
  returns text
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.rpad($1, $2, ' ')
$$;

comment on function pg_catalog.rpad(text, integer)
is 'right-pad string to length';

alter function pg_catalog.rpad(text, integer)
  owner to postgres;

create function pg_catalog.ltrim(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ltrim
;

comment on function pg_catalog.ltrim(text)
is 'trim spaces from left end of string';

alter function pg_catalog.ltrim(text)
  owner to postgres;

create function pg_catalog.rtrim(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rtrim
;

comment on function pg_catalog.rtrim(text)
is 'trim spaces from right end of string';

alter function pg_catalog.rtrim(text)
  owner to postgres;

create function pg_catalog.substr(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(text, integer)
is 'extract portion of string';

alter function pg_catalog.substr(text, integer)
  owner to postgres;

create function pg_catalog.btrim(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrim
;

comment on function pg_catalog.btrim(text, text)
is 'trim selected characters from both ends of string';

alter function pg_catalog.btrim(text, text)
  owner to postgres;

create function pg_catalog.btrim(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrim
;

comment on function pg_catalog.btrim(text)
is 'trim spaces from both ends of string';

alter function pg_catalog.btrim(text)
  owner to postgres;

create function pg_catalog.cash_in(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_in
;

comment on function pg_catalog.cash_in(cstring)
is 'I/O';

alter function pg_catalog.cash_in(cstring)
  owner to postgres;

create function pg_catalog.cash_out(money)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_out
;

comment on function pg_catalog.cash_out(money)
is 'I/O';

alter function pg_catalog.cash_out(money)
  owner to postgres;

create function pg_catalog.cash_eq(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_eq
;

comment on function pg_catalog.cash_eq(money, money)
is 'implementation of = operator';

alter function pg_catalog.cash_eq(money, money)
  owner to postgres;

create function pg_catalog.cash_ne(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_ne
;

comment on function pg_catalog.cash_ne(money, money)
is 'implementation of <> operator';

alter function pg_catalog.cash_ne(money, money)
  owner to postgres;

create function pg_catalog.cash_lt(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_lt
;

comment on function pg_catalog.cash_lt(money, money)
is 'implementation of < operator';

alter function pg_catalog.cash_lt(money, money)
  owner to postgres;

create function pg_catalog.cash_le(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_le
;

comment on function pg_catalog.cash_le(money, money)
is 'implementation of <= operator';

alter function pg_catalog.cash_le(money, money)
  owner to postgres;

create function pg_catalog.cash_gt(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_gt
;

comment on function pg_catalog.cash_gt(money, money)
is 'implementation of > operator';

alter function pg_catalog.cash_gt(money, money)
  owner to postgres;

create function pg_catalog.cash_ge(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_ge
;

comment on function pg_catalog.cash_ge(money, money)
is 'implementation of >= operator';

alter function pg_catalog.cash_ge(money, money)
  owner to postgres;

create function pg_catalog.cash_pl(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_pl
;

comment on function pg_catalog.cash_pl(money, money)
is 'implementation of + operator';

alter function pg_catalog.cash_pl(money, money)
  owner to postgres;

create function pg_catalog.cash_mi(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mi
;

comment on function pg_catalog.cash_mi(money, money)
is 'implementation of - operator';

alter function pg_catalog.cash_mi(money, money)
  owner to postgres;

create function pg_catalog.cash_mul_flt8(money, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_flt8
;

comment on function pg_catalog.cash_mul_flt8(money, double precision)
is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt8(money, double precision)
  owner to postgres;

create function pg_catalog.cash_div_flt8(money, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_flt8
;

comment on function pg_catalog.cash_div_flt8(money, double precision)
is 'implementation of / operator';

alter function pg_catalog.cash_div_flt8(money, double precision)
  owner to postgres;

create function pg_catalog.cashlarger(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cashlarger
;

comment on function pg_catalog.cashlarger(money, money)
is 'larger of two';

alter function pg_catalog.cashlarger(money, money)
  owner to postgres;

create function pg_catalog.cashsmaller(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cashsmaller
;

comment on function pg_catalog.cashsmaller(money, money)
is 'smaller of two';

alter function pg_catalog.cashsmaller(money, money)
  owner to postgres;

create function pg_catalog.inet_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_in
;

comment on function pg_catalog.inet_in(cstring)
is 'I/O';

alter function pg_catalog.inet_in(cstring)
  owner to postgres;

create function pg_catalog.inet_out(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_out
;

comment on function pg_catalog.inet_out(inet)
is 'I/O';

alter function pg_catalog.inet_out(inet)
  owner to postgres;

create function pg_catalog.flt8_mul_cash(double precision, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.flt8_mul_cash
;

comment on function pg_catalog.flt8_mul_cash(double precision, money)
is 'implementation of * operator';

alter function pg_catalog.flt8_mul_cash(double precision, money)
  owner to postgres;

create function pg_catalog.network_eq(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_eq
;

comment on function pg_catalog.network_eq(inet, inet)
is 'implementation of = operator';

alter function pg_catalog.network_eq(inet, inet)
  owner to postgres;

create function pg_catalog.network_lt(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_lt
;

comment on function pg_catalog.network_lt(inet, inet)
is 'implementation of < operator';

alter function pg_catalog.network_lt(inet, inet)
  owner to postgres;

create function pg_catalog.network_le(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_le
;

comment on function pg_catalog.network_le(inet, inet)
is 'implementation of <= operator';

alter function pg_catalog.network_le(inet, inet)
  owner to postgres;

create function pg_catalog.network_gt(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_gt
;

comment on function pg_catalog.network_gt(inet, inet)
is 'implementation of > operator';

alter function pg_catalog.network_gt(inet, inet)
  owner to postgres;

create function pg_catalog.network_ge(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_ge
;

comment on function pg_catalog.network_ge(inet, inet)
is 'implementation of >= operator';

alter function pg_catalog.network_ge(inet, inet)
  owner to postgres;

create function pg_catalog.network_ne(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_ne
;

comment on function pg_catalog.network_ne(inet, inet)
is 'implementation of <> operator';

alter function pg_catalog.network_ne(inet, inet)
  owner to postgres;

create function pg_catalog.network_cmp(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_cmp
;

comment on function pg_catalog.network_cmp(inet, inet)
is 'less-equal-greater';

alter function pg_catalog.network_cmp(inet, inet)
  owner to postgres;

create function pg_catalog.network_sub(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_sub
;

comment on function pg_catalog.network_sub(inet, inet)
is 'implementation of << operator';

alter function pg_catalog.network_sub(inet, inet)
  owner to postgres;

create function pg_catalog.network_subeq(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_subeq
;

comment on function pg_catalog.network_subeq(inet, inet)
is 'implementation of <<= operator';

alter function pg_catalog.network_subeq(inet, inet)
  owner to postgres;

create function pg_catalog.network_sup(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_sup
;

comment on function pg_catalog.network_sup(inet, inet)
is 'implementation of >> operator';

alter function pg_catalog.network_sup(inet, inet)
  owner to postgres;

create function pg_catalog.network_supeq(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_supeq
;

comment on function pg_catalog.network_supeq(inet, inet)
is 'implementation of >>= operator';

alter function pg_catalog.network_supeq(inet, inet)
  owner to postgres;

create function pg_catalog.cash_words(money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_words
;

comment on function pg_catalog.cash_words(money)
is 'output money amount as words';

alter function pg_catalog.cash_words(money)
  owner to postgres;

create function pg_catalog.substring(text, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(text, integer, integer)
is 'extract portion of string';

alter function pg_catalog.substring(text, integer, integer)
  owner to postgres;

create function pg_catalog.substring(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(text, integer)
is 'extract portion of string';

alter function pg_catalog.substring(text, integer)
  owner to postgres;

create function pg_catalog.generate_series(timestamp, timestamp, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(timestamp, timestamp, interval)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp, timestamp, interval)
  owner to postgres;

create function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval)
  owner to postgres;

create function pg_catalog.mod(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(smallint, smallint)
is 'modulus';

alter function pg_catalog.mod(smallint, smallint)
  owner to postgres;

create function pg_catalog.mod(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(integer, integer)
is 'modulus';

alter function pg_catalog.mod(integer, integer)
  owner to postgres;

create function pg_catalog.int28mi(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28mi
;

comment on function pg_catalog.int28mi(smallint, bigint)
is 'implementation of - operator';

alter function pg_catalog.int28mi(smallint, bigint)
  owner to postgres;

create function pg_catalog.int28mul(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28mul
;

comment on function pg_catalog.int28mul(smallint, bigint)
is 'implementation of * operator';

alter function pg_catalog.int28mul(smallint, bigint)
  owner to postgres;

create function pg_catalog.char(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char
;

comment on function pg_catalog.char(text)
is 'convert text to char';

alter function pg_catalog.char(text)
  owner to postgres;

create function pg_catalog.int8mod(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8mod
;

comment on function pg_catalog.int8mod(bigint, bigint)
is 'implementation of % operator';

alter function pg_catalog.int8mod(bigint, bigint)
  owner to postgres;

create function pg_catalog.text("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text("char")
is 'convert char to text';

alter function pg_catalog.text("char")
  owner to postgres;

create function pg_catalog.mod(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(bigint, bigint)
is 'modulus';

alter function pg_catalog.mod(bigint, bigint)
  owner to postgres;

create function pg_catalog.int28div(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28div
;

comment on function pg_catalog.int28div(smallint, bigint)
is 'implementation of / operator';

alter function pg_catalog.int28div(smallint, bigint)
  owner to postgres;

create function pg_catalog.hashint8(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint8
;

comment on function pg_catalog.hashint8(bigint)
is 'hash';

alter function pg_catalog.hashint8(bigint)
  owner to postgres;

create function pg_catalog.lo_open(oid, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_open
;

comment on function pg_catalog.lo_open(oid, integer)
is 'large object open';

alter function pg_catalog.lo_open(oid, integer)
  owner to postgres;

create function pg_catalog.lo_close(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_close
;

comment on function pg_catalog.lo_close(integer)
is 'large object close';

alter function pg_catalog.lo_close(integer)
  owner to postgres;

create function pg_catalog.loread(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.loread
;

comment on function pg_catalog.loread(integer, integer)
is 'large object read';

alter function pg_catalog.loread(integer, integer)
  owner to postgres;

create function pg_catalog.lowrite(integer, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lowrite
;

comment on function pg_catalog.lowrite(integer, bytea)
is 'large object write';

alter function pg_catalog.lowrite(integer, bytea)
  owner to postgres;

create function pg_catalog.lo_lseek(integer, integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_lseek
;

comment on function pg_catalog.lo_lseek(integer, integer, integer)
is 'large object seek';

alter function pg_catalog.lo_lseek(integer, integer, integer)
  owner to postgres;

create function pg_catalog.lo_creat(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_creat
;

comment on function pg_catalog.lo_creat(integer)
is 'large object create';

alter function pg_catalog.lo_creat(integer)
  owner to postgres;

create function pg_catalog.lo_tell(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_tell
;

comment on function pg_catalog.lo_tell(integer)
is 'large object position';

alter function pg_catalog.lo_tell(integer)
  owner to postgres;

create function pg_catalog.on_pl(point, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_pl
;

comment on function pg_catalog.on_pl(point, line)
is 'implementation of <@ operator';

alter function pg_catalog.on_pl(point, line)
  owner to postgres;

create function pg_catalog.on_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_sl
;

comment on function pg_catalog.on_sl(lseg, line)
is 'implementation of <@ operator';

alter function pg_catalog.on_sl(lseg, line)
  owner to postgres;

create function pg_catalog.close_pl(point, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_pl
;

comment on function pg_catalog.close_pl(point, line)
is 'implementation of ## operator';

alter function pg_catalog.close_pl(point, line)
  owner to postgres;

create function pg_catalog.close_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_sl
;

comment on function pg_catalog.close_sl(lseg, line)
is 'implementation of ## operator';

alter function pg_catalog.close_sl(lseg, line)
  owner to postgres;

create function pg_catalog.close_lb(line, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_lb
;

comment on function pg_catalog.close_lb(line, box)
is 'implementation of ## operator';

alter function pg_catalog.close_lb(line, box)
  owner to postgres;

create function pg_catalog.lo_unlink(oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_unlink
;

comment on function pg_catalog.lo_unlink(oid)
is 'large object unlink (delete)';

alter function pg_catalog.lo_unlink(oid)
  owner to postgres;

create function pg_catalog.path_inter(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_inter
;

comment on function pg_catalog.path_inter(path, path)
is 'implementation of ?# operator';

alter function pg_catalog.path_inter(path, path)
  owner to postgres;

create function pg_catalog.area(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.area
;

comment on function pg_catalog.area(box)
is 'box area';

alter function pg_catalog.area(box)
  owner to postgres;

create function pg_catalog.width(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width
;

comment on function pg_catalog.width(box)
is 'box width';

alter function pg_catalog.width(box)
  owner to postgres;

create function pg_catalog.height(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.height
;

comment on function pg_catalog.height(box)
is 'box height';

alter function pg_catalog.height(box)
  owner to postgres;

create function pg_catalog.box_distance(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_distance
;

comment on function pg_catalog.box_distance(box, box)
is 'implementation of <-> operator';

alter function pg_catalog.box_distance(box, box)
  owner to postgres;

create function pg_catalog.area(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.area
;

comment on function pg_catalog.area(path)
is 'area of a closed path';

alter function pg_catalog.area(path)
  owner to postgres;

create function pg_catalog.box_intersect(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_intersect
;

comment on function pg_catalog.box_intersect(box, box)
is 'implementation of # operator';

alter function pg_catalog.box_intersect(box, box)
  owner to postgres;

create function pg_catalog.diagonal(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.diagonal
;

comment on function pg_catalog.diagonal(box)
is 'box diagonal';

alter function pg_catalog.diagonal(box)
  owner to postgres;

create function pg_catalog.path_n_lt(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_lt
;

comment on function pg_catalog.path_n_lt(path, path)
is 'implementation of < operator';

alter function pg_catalog.path_n_lt(path, path)
  owner to postgres;

create function pg_catalog.path_n_gt(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_gt
;

comment on function pg_catalog.path_n_gt(path, path)
is 'implementation of > operator';

alter function pg_catalog.path_n_gt(path, path)
  owner to postgres;

create function pg_catalog.path_n_eq(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_eq
;

comment on function pg_catalog.path_n_eq(path, path)
is 'implementation of = operator';

alter function pg_catalog.path_n_eq(path, path)
  owner to postgres;

create function pg_catalog.path_n_le(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_le
;

comment on function pg_catalog.path_n_le(path, path)
is 'implementation of <= operator';

alter function pg_catalog.path_n_le(path, path)
  owner to postgres;

create function pg_catalog.path_n_ge(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_ge
;

comment on function pg_catalog.path_n_ge(path, path)
is 'implementation of >= operator';

alter function pg_catalog.path_n_ge(path, path)
  owner to postgres;

create function pg_catalog.path_length(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_length
;

comment on function pg_catalog.path_length(path)
is 'implementation of @-@ operator';

alter function pg_catalog.path_length(path)
  owner to postgres;

create function pg_catalog.point_ne(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_ne
;

comment on function pg_catalog.point_ne(point, point)
is 'implementation of <> operator';

alter function pg_catalog.point_ne(point, point)
  owner to postgres;

create function pg_catalog.point_vert(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_vert
;

comment on function pg_catalog.point_vert(point, point)
is 'implementation of ?| operator';

alter function pg_catalog.point_vert(point, point)
  owner to postgres;

create function pg_catalog.point_horiz(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_horiz
;

comment on function pg_catalog.point_horiz(point, point)
is 'implementation of ?- operator';

alter function pg_catalog.point_horiz(point, point)
  owner to postgres;

create function pg_catalog.point_distance(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_distance
;

comment on function pg_catalog.point_distance(point, point)
is 'implementation of <-> operator';

alter function pg_catalog.point_distance(point, point)
  owner to postgres;

create function pg_catalog.slope(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.slope
;

comment on function pg_catalog.slope(point, point)
is 'slope between points';

alter function pg_catalog.slope(point, point)
  owner to postgres;

create function pg_catalog.lseg(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg
;

comment on function pg_catalog.lseg(point, point)
is 'convert points to line segment';

alter function pg_catalog.lseg(point, point)
  owner to postgres;

create function pg_catalog.lseg_intersect(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_intersect
;

comment on function pg_catalog.lseg_intersect(lseg, lseg)
is 'implementation of ?# operator';

alter function pg_catalog.lseg_intersect(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_parallel(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_parallel
;

comment on function pg_catalog.lseg_parallel(lseg, lseg)
is 'implementation of ?|| operator';

alter function pg_catalog.lseg_parallel(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_perp(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_perp
;

comment on function pg_catalog.lseg_perp(lseg, lseg)
is 'implementation of ?-| operator';

alter function pg_catalog.lseg_perp(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_vertical(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_vertical
;

comment on function pg_catalog.lseg_vertical(lseg)
is 'implementation of ?| operator';

alter function pg_catalog.lseg_vertical(lseg)
  owner to postgres;

create function pg_catalog.lseg_horizontal(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_horizontal
;

comment on function pg_catalog.lseg_horizontal(lseg)
is 'implementation of ?- operator';

alter function pg_catalog.lseg_horizontal(lseg)
  owner to postgres;

create function pg_catalog.lseg_eq(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_eq
;

comment on function pg_catalog.lseg_eq(lseg, lseg)
is 'implementation of = operator';

alter function pg_catalog.lseg_eq(lseg, lseg)
  owner to postgres;

create function pg_catalog.lo_truncate(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_truncate
;

comment on function pg_catalog.lo_truncate(integer, integer)
is 'truncate large object';

alter function pg_catalog.lo_truncate(integer, integer)
  owner to postgres;

create function pg_catalog.timezone(interval, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(interval, timestamp with time zone)
is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval, timestamp with time zone)
  owner to postgres;

create function pg_catalog.gist_point_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_compress
;

comment on function pg_catalog.gist_point_compress(internal)
is 'GiST support';

alter function pg_catalog.gist_point_compress(internal)
  owner to postgres;

create function pg_catalog.aclitemin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclitemin
;

comment on function pg_catalog.aclitemin(cstring)
is 'I/O';

alter function pg_catalog.aclitemin(cstring)
  owner to postgres;

create function pg_catalog.aclitemout(aclitem)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclitemout
;

comment on function pg_catalog.aclitemout(aclitem)
is 'I/O';

alter function pg_catalog.aclitemout(aclitem)
  owner to postgres;

create function pg_catalog.aclinsert(aclitem [], aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclinsert
;

comment on function pg_catalog.aclinsert(aclitem [], aclitem)
is 'add/update ACL item';

alter function pg_catalog.aclinsert(aclitem [], aclitem)
  owner to postgres;

create function pg_catalog.aclremove(aclitem [], aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclremove
;

comment on function pg_catalog.aclremove(aclitem [], aclitem)
is 'remove ACL item';

alter function pg_catalog.aclremove(aclitem [], aclitem)
  owner to postgres;

create function pg_catalog.aclcontains(aclitem [], aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclcontains
;

comment on function pg_catalog.aclcontains(aclitem [], aclitem)
is 'contains';

alter function pg_catalog.aclcontains(aclitem [], aclitem)
  owner to postgres;

create function pg_catalog.getdatabaseencoding()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.getdatabaseencoding
;

comment on function pg_catalog.getdatabaseencoding()
is 'encoding name of current database';

alter function pg_catalog.getdatabaseencoding()
  owner to postgres;

create function pg_catalog.bpcharin(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharin
;

comment on function pg_catalog.bpcharin(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.bpcharin(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.bpcharout(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharout
;

comment on function pg_catalog.bpcharout(char)
is 'I/O';

alter function pg_catalog.bpcharout(char)
  owner to postgres;

create function pg_catalog.varcharin(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharin
;

comment on function pg_catalog.varcharin(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.varcharin(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.varcharout(varchar)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharout
;

comment on function pg_catalog.varcharout(varchar)
is 'I/O';

alter function pg_catalog.varcharout(varchar)
  owner to postgres;

create function pg_catalog.bpchareq(char, char)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchareq
;

comment on function pg_catalog.bpchareq(char, char)
is 'implementation of = operator';

alter function pg_catalog.bpchareq(char, char)
  owner to postgres;

create function pg_catalog.bpcharlt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharlt
;

comment on function pg_catalog.bpcharlt(char, char)
is 'implementation of < operator';

alter function pg_catalog.bpcharlt(char, char)
  owner to postgres;

create function pg_catalog.bpcharle(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharle
;

comment on function pg_catalog.bpcharle(char, char)
is 'implementation of <= operator';

alter function pg_catalog.bpcharle(char, char)
  owner to postgres;

create function pg_catalog.bpchargt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchargt
;

comment on function pg_catalog.bpchargt(char, char)
is 'implementation of > operator';

alter function pg_catalog.bpchargt(char, char)
  owner to postgres;

create function pg_catalog.bpcharge(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharge
;

comment on function pg_catalog.bpcharge(char, char)
is 'implementation of >= operator';

alter function pg_catalog.bpcharge(char, char)
  owner to postgres;

create function pg_catalog.bpcharne(char, char)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharne
;

comment on function pg_catalog.bpcharne(char, char)
is 'implementation of <> operator';

alter function pg_catalog.bpcharne(char, char)
  owner to postgres;

create function pg_catalog.aclitemeq(aclitem, aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclitemeq
;

comment on function pg_catalog.aclitemeq(aclitem, aclitem)
is 'implementation of = operator';

alter function pg_catalog.aclitemeq(aclitem, aclitem)
  owner to postgres;

create function pg_catalog.bpchar_larger(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_larger
;

comment on function pg_catalog.bpchar_larger(char, char)
is 'larger of two';

alter function pg_catalog.bpchar_larger(char, char)
  owner to postgres;

create function pg_catalog.bpchar_smaller(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_smaller
;

comment on function pg_catalog.bpchar_smaller(char, char)
is 'smaller of two';

alter function pg_catalog.bpchar_smaller(char, char)
  owner to postgres;

create function pg_catalog.pg_prepared_xact(out transaction xid, out gid text, out prepared timestamp with time zone,
                                            out ownerid     oid, out dbid oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_prepared_xact
;

comment on function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid)
is 'view two-phase transactions';

alter function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid)
  owner to postgres;

create function pg_catalog.generate_series(integer, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(integer, integer, integer)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer, integer)
  owner to postgres;

create function pg_catalog.generate_series(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(integer, integer)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer)
  owner to postgres;

create function pg_catalog.generate_series(bigint, bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(bigint, bigint, bigint)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint, bigint)
  owner to postgres;

create function pg_catalog.generate_series(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(bigint, bigint)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint)
  owner to postgres;

create function pg_catalog.bpcharcmp(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharcmp
;

comment on function pg_catalog.bpcharcmp(char, char)
is 'less-equal-greater';

alter function pg_catalog.bpcharcmp(char, char)
  owner to postgres;

create function pg_catalog.regclass(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclass
;

comment on function pg_catalog.regclass(text)
is 'convert text to regclass';

alter function pg_catalog.regclass(text)
  owner to postgres;

create function pg_catalog.hashbpchar(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashbpchar
;

comment on function pg_catalog.hashbpchar(char)
is 'hash';

alter function pg_catalog.hashbpchar(char)
  owner to postgres;

create function pg_catalog.format_type(oid, integer)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.format_type
;

comment on function pg_catalog.format_type(oid, integer)
is 'format a type oid and atttypmod to canonical SQL';

alter function pg_catalog.format_type(oid, integer)
  owner to postgres;

create function pg_catalog.date_in(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_in
;

comment on function pg_catalog.date_in(cstring)
is 'I/O';

alter function pg_catalog.date_in(cstring)
  owner to postgres;

create function pg_catalog.date_out(date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_out
;

comment on function pg_catalog.date_out(date)
is 'I/O';

alter function pg_catalog.date_out(date)
  owner to postgres;

create function pg_catalog.date_eq(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_eq
;

comment on function pg_catalog.date_eq(date, date)
is 'implementation of = operator';

alter function pg_catalog.date_eq(date, date)
  owner to postgres;

create function pg_catalog.date_lt(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_lt
;

comment on function pg_catalog.date_lt(date, date)
is 'implementation of < operator';

alter function pg_catalog.date_lt(date, date)
  owner to postgres;

create function pg_catalog.date_le(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_le
;

comment on function pg_catalog.date_le(date, date)
is 'implementation of <= operator';

alter function pg_catalog.date_le(date, date)
  owner to postgres;

create function pg_catalog.date_gt(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_gt
;

comment on function pg_catalog.date_gt(date, date)
is 'implementation of > operator';

alter function pg_catalog.date_gt(date, date)
  owner to postgres;

create function pg_catalog.date_ge(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ge
;

comment on function pg_catalog.date_ge(date, date)
is 'implementation of >= operator';

alter function pg_catalog.date_ge(date, date)
  owner to postgres;

create function pg_catalog.date_ne(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ne
;

comment on function pg_catalog.date_ne(date, date)
is 'implementation of <> operator';

alter function pg_catalog.date_ne(date, date)
  owner to postgres;

create function pg_catalog.date_cmp(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_cmp
;

comment on function pg_catalog.date_cmp(date, date)
is 'less-equal-greater';

alter function pg_catalog.date_cmp(date, date)
  owner to postgres;

create function pg_catalog.time_lt(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_lt
;

comment on function pg_catalog.time_lt(time, time)
is 'implementation of < operator';

alter function pg_catalog.time_lt(time, time)
  owner to postgres;

create function pg_catalog.time_le(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_le
;

comment on function pg_catalog.time_le(time, time)
is 'implementation of <= operator';

alter function pg_catalog.time_le(time, time)
  owner to postgres;

create function pg_catalog.time_gt(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_gt
;

comment on function pg_catalog.time_gt(time, time)
is 'implementation of > operator';

alter function pg_catalog.time_gt(time, time)
  owner to postgres;

create function pg_catalog.time_ge(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_ge
;

comment on function pg_catalog.time_ge(time, time)
is 'implementation of >= operator';

alter function pg_catalog.time_ge(time, time)
  owner to postgres;

create function pg_catalog.time_ne(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_ne
;

comment on function pg_catalog.time_ne(time, time)
is 'implementation of <> operator';

alter function pg_catalog.time_ne(time, time)
  owner to postgres;

create function pg_catalog.time_cmp(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_cmp
;

comment on function pg_catalog.time_cmp(time, time)
is 'less-equal-greater';

alter function pg_catalog.time_cmp(time, time)
  owner to postgres;

create function pg_catalog.date_larger(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_larger
;

comment on function pg_catalog.date_larger(date, date)
is 'larger of two';

alter function pg_catalog.date_larger(date, date)
  owner to postgres;

create function pg_catalog.date_smaller(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_smaller
;

comment on function pg_catalog.date_smaller(date, date)
is 'smaller of two';

alter function pg_catalog.date_smaller(date, date)
  owner to postgres;

create function pg_catalog.date_mi(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_mi
;

comment on function pg_catalog.date_mi(date, date)
is 'implementation of - operator';

alter function pg_catalog.date_mi(date, date)
  owner to postgres;

create function pg_catalog.date_pli(date, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_pli
;

comment on function pg_catalog.date_pli(date, integer)
is 'implementation of + operator';

alter function pg_catalog.date_pli(date, integer)
  owner to postgres;

create function pg_catalog.date_mii(date, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_mii
;

comment on function pg_catalog.date_mii(date, integer)
is 'implementation of - operator';

alter function pg_catalog.date_mii(date, integer)
  owner to postgres;

create function pg_catalog.time_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_in
;

comment on function pg_catalog.time_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.time_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.time_out(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_out
;

comment on function pg_catalog.time_out(time)
is 'I/O';

alter function pg_catalog.time_out(time)
  owner to postgres;

create function pg_catalog.time_eq(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_eq
;

comment on function pg_catalog.time_eq(time, time)
is 'implementation of = operator';

alter function pg_catalog.time_eq(time, time)
  owner to postgres;

create function pg_catalog.circle_add_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_add_pt
;

comment on function pg_catalog.circle_add_pt(circle, point)
is 'implementation of + operator';

alter function pg_catalog.circle_add_pt(circle, point)
  owner to postgres;

create function pg_catalog.circle_sub_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_sub_pt
;

comment on function pg_catalog.circle_sub_pt(circle, point)
is 'implementation of - operator';

alter function pg_catalog.circle_sub_pt(circle, point)
  owner to postgres;

create function pg_catalog.circle_mul_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_mul_pt
;

comment on function pg_catalog.circle_mul_pt(circle, point)
is 'implementation of * operator';

alter function pg_catalog.circle_mul_pt(circle, point)
  owner to postgres;

create function pg_catalog.circle_div_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_div_pt
;

comment on function pg_catalog.circle_div_pt(circle, point)
is 'implementation of / operator';

alter function pg_catalog.circle_div_pt(circle, point)
  owner to postgres;

create function pg_catalog.timestamptz_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_in
;

comment on function pg_catalog.timestamptz_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.timestamptz_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.timestamptz_out(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_out
;

comment on function pg_catalog.timestamptz_out(timestamp with time zone)
is 'I/O';

alter function pg_catalog.timestamptz_out(timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_eq
;

comment on function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone)
is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ne
;

comment on function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone)
is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_lt
;

comment on function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone)
is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_le
;

comment on function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone)
is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ge
;

comment on function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone)
is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_gt
;

comment on function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone)
is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.to_timestamp(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_timestamp
;

comment on function pg_catalog.to_timestamp(double precision)
is 'convert UNIX epoch to timestamptz';

alter function pg_catalog.to_timestamp(double precision)
  owner to postgres;

create function pg_catalog.timezone(text, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(text, timestamp with time zone)
is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(text, timestamp with time zone)
  owner to postgres;

create function pg_catalog.interval_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_in
;

comment on function pg_catalog.interval_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.interval_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.interval_out(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_out
;

comment on function pg_catalog.interval_out(interval)
is 'I/O';

alter function pg_catalog.interval_out(interval)
  owner to postgres;

create function pg_catalog.interval_eq(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_eq
;

comment on function pg_catalog.interval_eq(interval, interval)
is 'implementation of = operator';

alter function pg_catalog.interval_eq(interval, interval)
  owner to postgres;

create function pg_catalog.interval_ne(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_ne
;

comment on function pg_catalog.interval_ne(interval, interval)
is 'implementation of <> operator';

alter function pg_catalog.interval_ne(interval, interval)
  owner to postgres;

create function pg_catalog.interval_lt(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_lt
;

comment on function pg_catalog.interval_lt(interval, interval)
is 'implementation of < operator';

alter function pg_catalog.interval_lt(interval, interval)
  owner to postgres;

create function pg_catalog.interval_le(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_le
;

comment on function pg_catalog.interval_le(interval, interval)
is 'implementation of <= operator';

alter function pg_catalog.interval_le(interval, interval)
  owner to postgres;

create function pg_catalog.interval_ge(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_ge
;

comment on function pg_catalog.interval_ge(interval, interval)
is 'implementation of >= operator';

alter function pg_catalog.interval_ge(interval, interval)
  owner to postgres;

create function pg_catalog.interval_gt(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_gt
;

comment on function pg_catalog.interval_gt(interval, interval)
is 'implementation of > operator';

alter function pg_catalog.interval_gt(interval, interval)
  owner to postgres;

create function pg_catalog.interval_um(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_um
;

comment on function pg_catalog.interval_um(interval)
is 'implementation of - operator';

alter function pg_catalog.interval_um(interval)
  owner to postgres;

create function pg_catalog.interval_pl(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_pl
;

comment on function pg_catalog.interval_pl(interval, interval)
is 'implementation of + operator';

alter function pg_catalog.interval_pl(interval, interval)
  owner to postgres;

create function pg_catalog.interval_mi(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_mi
;

comment on function pg_catalog.interval_mi(interval, interval)
is 'implementation of - operator';

alter function pg_catalog.interval_mi(interval, interval)
  owner to postgres;

create function pg_catalog.date_part(text, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, timestamp with time zone)
is 'extract field from timestamp with time zone';

alter function pg_catalog.date_part(text, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_part(text, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, interval)
is 'extract field from interval';

alter function pg_catalog.date_part(text, interval)
  owner to postgres;

create function pg_catalog.timestamptz(abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(abstime)
is 'convert abstime to timestamp with time zone';

alter function pg_catalog.timestamptz(abstime)
  owner to postgres;

create function pg_catalog.timestamptz(date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(date)
is 'convert date to timestamp with time zone';

alter function pg_catalog.timestamptz(date)
  owner to postgres;

create function pg_catalog.justify_hours(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.justify_hours
;

comment on function pg_catalog.justify_hours(interval)
is 'promote groups of 24 hours to numbers of days';

alter function pg_catalog.justify_hours(interval)
  owner to postgres;

create function pg_catalog.timestamptz(date, time without time zone)
  returns timestamp with time zone
stable
strict
parallel safe
cost 1
language sql
as $$
select cast(($1 + $2) as timestamp with time zone)
$$;

comment on function pg_catalog.timestamptz(date, time)
is 'convert date and time to timestamp with time zone';

alter function pg_catalog.timestamptz(date, time)
  owner to postgres;

create function pg_catalog.interval(reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval
;

comment on function pg_catalog.interval(reltime)
is 'convert reltime to interval';

alter function pg_catalog.interval(reltime)
  owner to postgres;

create function pg_catalog.date(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date
;

comment on function pg_catalog.date(timestamp with time zone)
is 'convert timestamp with time zone to date';

alter function pg_catalog.date(timestamp with time zone)
  owner to postgres;

create function pg_catalog.date(abstime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date
;

comment on function pg_catalog.date(abstime)
is 'convert abstime to date';

alter function pg_catalog.date(abstime)
  owner to postgres;

create function pg_catalog.abstime(timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstime
;

comment on function pg_catalog.abstime(timestamp with time zone)
is 'convert timestamp with time zone to abstime';

alter function pg_catalog.abstime(timestamp with time zone)
  owner to postgres;

create function pg_catalog.age(xid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.age
;

comment on function pg_catalog.age(xid)
is 'age of a transaction ID, in transactions before current transaction';

alter function pg_catalog.age(xid)
  owner to postgres;

create function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_mi
;

comment on function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone)
is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_pl_interval
;

comment on function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval)
is 'implementation of + operator';

alter function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval)
  owner to postgres;

create function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_mi_interval
;

comment on function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval)
is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval)
  owner to postgres;

create function pg_catalog.generate_subscripts(anyarray, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_subscripts
;

comment on function pg_catalog.generate_subscripts(anyarray, integer, boolean)
is 'array subscripts generator';

alter function pg_catalog.generate_subscripts(anyarray, integer, boolean)
  owner to postgres;

create function pg_catalog.generate_subscripts(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_subscripts
;

comment on function pg_catalog.generate_subscripts(anyarray, integer)
is 'array subscripts generator';

alter function pg_catalog.generate_subscripts(anyarray, integer)
  owner to postgres;

create function pg_catalog.array_fill(anyelement, integer [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_fill
;

comment on function pg_catalog.array_fill(anyelement, integer [])
is 'array constructor with value';

alter function pg_catalog.array_fill(anyelement, integer [])
  owner to postgres;

create function pg_catalog.reltime(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltime
;

comment on function pg_catalog.reltime(interval)
is 'convert interval to reltime';

alter function pg_catalog.reltime(interval)
  owner to postgres;

create function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_smaller
;

comment on function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone)
is 'smaller of two';

alter function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_larger
;

comment on function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone)
is 'larger of two';

alter function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.interval_smaller(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_smaller
;

comment on function pg_catalog.interval_smaller(interval, interval)
is 'smaller of two';

alter function pg_catalog.interval_smaller(interval, interval)
  owner to postgres;

create function pg_catalog.interval_larger(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_larger
;

comment on function pg_catalog.interval_larger(interval, interval)
is 'larger of two';

alter function pg_catalog.interval_larger(interval, interval)
  owner to postgres;

create function pg_catalog.age(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.age
;

comment on function pg_catalog.age(timestamp with time zone, timestamp with time zone)
is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.interval(interval, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval
;

comment on function pg_catalog.interval(interval, integer)
is 'adjust interval precision';

alter function pg_catalog.interval(interval, integer)
  owner to postgres;

create function pg_catalog.obj_description(oid, name)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_description
where objoid = $1
  and classoid = (select oid
                  from pg_catalog.pg_class
                  where relname = $2
                    and relnamespace = 11)
  and objsubid = 0
$$;

comment on function pg_catalog.obj_description(oid, name)
is 'get description for object id and catalog name';

alter function pg_catalog.obj_description(oid, name)
  owner to postgres;

create function pg_catalog.col_description(oid, integer)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_description
where objoid = $1
  and classoid = 'pg_catalog.pg_class' :: pg_catalog.regclass
  and objsubid = $2
$$;

comment on function pg_catalog.col_description(oid, integer)
is 'get description for table column';

alter function pg_catalog.col_description(oid, integer)
  owner to postgres;

create function pg_catalog.date_trunc(text, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_trunc
;

comment on function pg_catalog.date_trunc(text, timestamp with time zone)
is 'truncate timestamp with time zone to specified units';

alter function pg_catalog.date_trunc(text, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_trunc(text, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_trunc
;

comment on function pg_catalog.date_trunc(text, interval)
is 'truncate interval to specified units';

alter function pg_catalog.date_trunc(text, interval)
  owner to postgres;

create function pg_catalog.int8inc(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8inc
;

comment on function pg_catalog.int8inc(bigint)
is 'increment';

alter function pg_catalog.int8inc(bigint)
  owner to postgres;

create function pg_catalog.int8abs(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8abs
;

comment on function pg_catalog.int8abs(bigint)
is 'implementation of @ operator';

alter function pg_catalog.int8abs(bigint)
  owner to postgres;

create function pg_catalog.int8larger(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8larger
;

comment on function pg_catalog.int8larger(bigint, bigint)
is 'larger of two';

alter function pg_catalog.int8larger(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8smaller(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8smaller
;

comment on function pg_catalog.int8smaller(bigint, bigint)
is 'smaller of two';

alter function pg_catalog.int8smaller(bigint, bigint)
  owner to postgres;

create function pg_catalog.texticregexeq(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticregexeq
;

comment on function pg_catalog.texticregexeq(text, text)
is 'implementation of ~* operator';

alter function pg_catalog.texticregexeq(text, text)
  owner to postgres;

create function pg_catalog.texticregexne(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticregexne
;

comment on function pg_catalog.texticregexne(text, text)
is 'implementation of !~* operator';

alter function pg_catalog.texticregexne(text, text)
  owner to postgres;

create function pg_catalog.nameicregexeq(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameicregexeq
;

comment on function pg_catalog.nameicregexeq(name, text)
is 'implementation of ~* operator';

alter function pg_catalog.nameicregexeq(name, text)
  owner to postgres;

create function pg_catalog.nameicregexne(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameicregexne
;

comment on function pg_catalog.nameicregexne(name, text)
is 'implementation of !~* operator';

alter function pg_catalog.nameicregexne(name, text)
  owner to postgres;

create function pg_catalog.boolin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolin
;

comment on function pg_catalog.boolin(cstring)
is 'I/O';

alter function pg_catalog.boolin(cstring)
  owner to postgres;

create function pg_catalog.boolout(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolout
;

comment on function pg_catalog.boolout(boolean)
is 'I/O';

alter function pg_catalog.boolout(boolean)
  owner to postgres;

create function pg_catalog.byteain(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteain
;

comment on function pg_catalog.byteain(cstring)
is 'I/O';

alter function pg_catalog.byteain(cstring)
  owner to postgres;

create function pg_catalog.charin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charin
;

comment on function pg_catalog.charin(cstring)
is 'I/O';

alter function pg_catalog.charin(cstring)
  owner to postgres;

create function pg_catalog.charlt("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charlt
;

comment on function pg_catalog.charlt("char", "char")
is 'implementation of < operator';

alter function pg_catalog.charlt("char", "char")
  owner to postgres;

create function pg_catalog.unique_key_recheck()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unique_key_recheck
;

comment on function pg_catalog.unique_key_recheck()
is 'deferred UNIQUE constraint check';

alter function pg_catalog.unique_key_recheck()
  owner to postgres;

create function pg_catalog.int4abs(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4abs
;

comment on function pg_catalog.int4abs(integer)
is 'implementation of @ operator';

alter function pg_catalog.int4abs(integer)
  owner to postgres;

create function pg_catalog.nameregexne(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameregexne
;

comment on function pg_catalog.nameregexne(name, text)
is 'implementation of !~ operator';

alter function pg_catalog.nameregexne(name, text)
  owner to postgres;

create function pg_catalog.int2abs(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2abs
;

comment on function pg_catalog.int2abs(smallint)
is 'implementation of @ operator';

alter function pg_catalog.int2abs(smallint)
  owner to postgres;

create function pg_catalog.textregexeq(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textregexeq
;

comment on function pg_catalog.textregexeq(text, text)
is 'implementation of ~ operator';

alter function pg_catalog.textregexeq(text, text)
  owner to postgres;

create function pg_catalog.textregexne(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textregexne
;

comment on function pg_catalog.textregexne(text, text)
is 'implementation of !~ operator';

alter function pg_catalog.textregexne(text, text)
  owner to postgres;

create function pg_catalog.textlen(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textlen
;

comment on function pg_catalog.textlen(text)
is 'length';

alter function pg_catalog.textlen(text)
  owner to postgres;

create function pg_catalog.textcat(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textcat
;

comment on function pg_catalog.textcat(text, text)
is 'implementation of || operator';

alter function pg_catalog.textcat(text, text)
  owner to postgres;

create function pg_catalog.pg_char_to_encoding(name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_char_to_encoding
;

comment on function pg_catalog.pg_char_to_encoding(name)
is 'convert encoding name to encoding id';

alter function pg_catalog.pg_char_to_encoding(name)
  owner to postgres;

create function pg_catalog.tidne(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidne
;

comment on function pg_catalog.tidne(tid, tid)
is 'implementation of <> operator';

alter function pg_catalog.tidne(tid, tid)
  owner to postgres;

create function pg_catalog.cidr_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_in
;

comment on function pg_catalog.cidr_in(cstring)
is 'I/O';

alter function pg_catalog.cidr_in(cstring)
  owner to postgres;

create function pg_catalog.parse_ident(str text, strict boolean default true)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.parse_ident
;

comment on function pg_catalog.parse_ident(text, boolean)
is 'parse qualified identifier to array of identifiers';

alter function pg_catalog.parse_ident(text, boolean)
  owner to postgres;

create function pg_catalog.pg_column_size("any")
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_column_size
;

comment on function pg_catalog.pg_column_size("any")
is 'bytes required to store the value, perhaps with compression';

alter function pg_catalog.pg_column_size("any")
  owner to postgres;

create function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone,
                                      time with time zone)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone,
                                          time with time zone)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.datetime_pl(date, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.datetime_pl
;

comment on function pg_catalog.datetime_pl(date, time)
is 'implementation of + operator';

alter function pg_catalog.datetime_pl(date, time)
  owner to postgres;

create function pg_catalog.date_part(text, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, time with time zone)
is 'extract field from time with time zone';

alter function pg_catalog.date_part(text, time with time zone)
  owner to postgres;

create function pg_catalog.int84pl(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84pl
;

comment on function pg_catalog.int84pl(bigint, integer)
is 'implementation of + operator';

alter function pg_catalog.int84pl(bigint, integer)
  owner to postgres;

create function pg_catalog.int84mi(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84mi
;

comment on function pg_catalog.int84mi(bigint, integer)
is 'implementation of - operator';

alter function pg_catalog.int84mi(bigint, integer)
  owner to postgres;

create function pg_catalog.int84mul(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84mul
;

comment on function pg_catalog.int84mul(bigint, integer)
is 'implementation of * operator';

alter function pg_catalog.int84mul(bigint, integer)
  owner to postgres;

create function pg_catalog.int84div(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84div
;

comment on function pg_catalog.int84div(bigint, integer)
is 'implementation of / operator';

alter function pg_catalog.int84div(bigint, integer)
  owner to postgres;

create function pg_catalog.int48pl(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48pl
;

comment on function pg_catalog.int48pl(integer, bigint)
is 'implementation of + operator';

alter function pg_catalog.int48pl(integer, bigint)
  owner to postgres;

create function pg_catalog.int48mi(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48mi
;

comment on function pg_catalog.int48mi(integer, bigint)
is 'implementation of - operator';

alter function pg_catalog.int48mi(integer, bigint)
  owner to postgres;

create function pg_catalog.int48mul(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48mul
;

comment on function pg_catalog.int48mul(integer, bigint)
is 'implementation of * operator';

alter function pg_catalog.int48mul(integer, bigint)
  owner to postgres;

create function pg_catalog.int48div(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48div
;

comment on function pg_catalog.int48div(integer, bigint)
is 'implementation of / operator';

alter function pg_catalog.int48div(integer, bigint)
  owner to postgres;

create function pg_catalog.quote_ident(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.quote_ident
;

comment on function pg_catalog.quote_ident(text)
is 'quote an identifier for usage in a querystring';

alter function pg_catalog.quote_ident(text)
  owner to postgres;

create function pg_catalog.quote_literal(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.quote_literal
;

comment on function pg_catalog.quote_literal(text)
is 'quote a literal for usage in a querystring';

alter function pg_catalog.quote_literal(text)
  owner to postgres;

create function pg_catalog.quote_literal(anyelement)
  returns text
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.quote_literal($1 :: pg_catalog.text)
$$;

comment on function pg_catalog.quote_literal(anyelement)
is 'quote a data value for usage in a querystring';

alter function pg_catalog.quote_literal(anyelement)
  owner to postgres;

create function pg_catalog.array_fill(anyelement, integer [], integer [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_fill
;

comment on function pg_catalog.array_fill(anyelement, integer [], integer [])
is 'array constructor with value';

alter function pg_catalog.array_fill(anyelement, integer [], integer [])
  owner to postgres;

create function pg_catalog.oid(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oid
;

comment on function pg_catalog.oid(bigint)
is 'convert int8 to oid';

alter function pg_catalog.oid(bigint)
  owner to postgres;

create function pg_catalog.int8(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(oid)
is 'convert oid to int8';

alter function pg_catalog.int8(oid)
  owner to postgres;

create function pg_catalog.quote_nullable(text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.quote_nullable
;

comment on function pg_catalog.quote_nullable(text)
is 'quote a possibly-null literal for usage in a querystring';

alter function pg_catalog.quote_nullable(text)
  owner to postgres;

create function pg_catalog.quote_nullable(anyelement)
  returns text
stable
parallel safe
cost 1
language sql
as $$
select pg_catalog.quote_nullable($1 :: pg_catalog.text)
$$;

comment on function pg_catalog.quote_nullable(anyelement)
is 'quote a possibly-null data value for usage in a querystring';

alter function pg_catalog.quote_nullable(anyelement)
  owner to postgres;

create function pg_catalog.suppress_redundant_updates_trigger()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.suppress_redundant_updates_trigger
;

comment on function pg_catalog.suppress_redundant_updates_trigger()
is 'trigger to suppress updates when new and old records match';

alter function pg_catalog.suppress_redundant_updates_trigger()
  owner to postgres;

create function pg_catalog.tideq(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tideq
;

comment on function pg_catalog.tideq(tid, tid)
is 'implementation of = operator';

alter function pg_catalog.tideq(tid, tid)
  owner to postgres;

create function pg_catalog.currtid(oid, tid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.currtid
;

comment on function pg_catalog.currtid(oid, tid)
is 'latest tid of a tuple';

alter function pg_catalog.currtid(oid, tid)
  owner to postgres;

create function pg_catalog.currtid2(text, tid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.currtid2
;

comment on function pg_catalog.currtid2(text, tid)
is 'latest tid of a tuple';

alter function pg_catalog.currtid2(text, tid)
  owner to postgres;

create function pg_catalog.justify_days(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.justify_days
;

comment on function pg_catalog.justify_days(interval)
is 'promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_days(interval)
  owner to postgres;

create function pg_catalog.timedate_pl(time without time zone, date)
  returns timestamp without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select ($2 + $1)
$$;

comment on function pg_catalog.timedate_pl(time, date)
is 'implementation of + operator';

alter function pg_catalog.timedate_pl(time, date)
  owner to postgres;

create function pg_catalog.datetimetz_pl(date, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.datetimetz_pl
;

comment on function pg_catalog.datetimetz_pl(date, time with time zone)
is 'implementation of + operator';

alter function pg_catalog.datetimetz_pl(date, time with time zone)
  owner to postgres;

create function pg_catalog.timetzdate_pl(time with time zone, date)
  returns timestamp with time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select ($2 + $1)
$$;

comment on function pg_catalog.timetzdate_pl(time with time zone, date)
is 'implementation of + operator';

alter function pg_catalog.timetzdate_pl(time with time zone, date)
  owner to postgres;

create function pg_catalog.now()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.now
;

comment on function pg_catalog.now()
is 'current transaction time';

alter function pg_catalog.now()
  owner to postgres;

create function pg_catalog.positionsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.positionsel
;

comment on function pg_catalog.positionsel(internal, oid, internal, integer)
is 'restriction selectivity for position-comparison operators';

alter function pg_catalog.positionsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.positionjoinsel
;

comment on function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for position-comparison operators';

alter function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.contsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.contsel
;

comment on function pg_catalog.contsel(internal, oid, internal, integer)
is 'restriction selectivity for containment comparison operators';

alter function pg_catalog.contsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.contjoinsel
;

comment on function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for containment comparison operators';

alter function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                      timestamp with time zone)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                          timestamp with time zone)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval)
  returns boolean
stable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                      interval)
  returns boolean
stable
parallel safe
cost 1
language sql
as $$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                          interval)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone,
                                      timestamp with time zone)
  returns boolean
stable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone,
                                          timestamp with time zone)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog."overlaps"(time, time, time, time)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(time, time, time, time)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, time, time, time)
  owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(time, interval, time, interval)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, interval)
  owner to postgres;

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(time, time, time, interval)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, time, time, interval)
  owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(time, interval, time, time)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, time)
  owner to postgres;

create function pg_catalog.timestamp_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_in
;

comment on function pg_catalog.timestamp_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.timestamp_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.timestamp_out(timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_out
;

comment on function pg_catalog.timestamp_out(timestamp)
is 'I/O';

alter function pg_catalog.timestamp_out(timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_cmp
;

comment on function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone)
is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.interval_cmp(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_cmp
;

comment on function pg_catalog.interval_cmp(interval, interval)
is 'less-equal-greater';

alter function pg_catalog.interval_cmp(interval, interval)
  owner to postgres;

create function pg_catalog.time(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(timestamp)
is 'convert timestamp to time';

alter function pg_catalog.time(timestamp)
  owner to postgres;

create function pg_catalog.length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(text)
is 'length';

alter function pg_catalog.length(text)
  owner to postgres;

create function pg_catalog.length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(char)
is 'character length';

alter function pg_catalog.length(char)
  owner to postgres;

create function pg_catalog.xideqint4(xid, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xideqint4
;

comment on function pg_catalog.xideqint4(xid, integer)
is 'implementation of = operator';

alter function pg_catalog.xideqint4(xid, integer)
  owner to postgres;

create function pg_catalog.interval_div(interval, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_div
;

comment on function pg_catalog.interval_div(interval, double precision)
is 'implementation of / operator';

alter function pg_catalog.interval_div(interval, double precision)
  owner to postgres;

create function pg_catalog.dlog10(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dlog10
;

comment on function pg_catalog.dlog10(double precision)
is 'base 10 logarithm';

alter function pg_catalog.dlog10(double precision)
  owner to postgres;

create function pg_catalog.log(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.log
;

comment on function pg_catalog.log(double precision)
is 'base 10 logarithm';

alter function pg_catalog.log(double precision)
  owner to postgres;

create function pg_catalog.ln(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ln
;

comment on function pg_catalog.ln(double precision)
is 'natural logarithm';

alter function pg_catalog.ln(double precision)
  owner to postgres;

create function pg_catalog.round(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.round
;

comment on function pg_catalog.round(double precision)
is 'round to nearest integer';

alter function pg_catalog.round(double precision)
  owner to postgres;

create function pg_catalog.trunc(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(double precision)
is 'truncate to integer';

alter function pg_catalog.trunc(double precision)
  owner to postgres;

create function pg_catalog.sqrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sqrt
;

comment on function pg_catalog.sqrt(double precision)
is 'square root';

alter function pg_catalog.sqrt(double precision)
  owner to postgres;

create function pg_catalog.cbrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cbrt
;

comment on function pg_catalog.cbrt(double precision)
is 'cube root';

alter function pg_catalog.cbrt(double precision)
  owner to postgres;

create function pg_catalog.pow(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pow
;

comment on function pg_catalog.pow(double precision, double precision)
is 'exponentiation';

alter function pg_catalog.pow(double precision, double precision)
  owner to postgres;

create function pg_catalog.exp(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.exp
;

comment on function pg_catalog.exp(double precision)
is 'natural exponential (e^x)';

alter function pg_catalog.exp(double precision)
  owner to postgres;

create function pg_catalog.obj_description(oid)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_description
where objoid = $1
  and objsubid = 0
$$;

comment on function pg_catalog.obj_description(oid)
is 'deprecated, use two-argument form instead';

alter function pg_catalog.obj_description(oid)
  owner to postgres;

create function pg_catalog.oidvectortypes(oidvector)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectortypes
;

comment on function pg_catalog.oidvectortypes(oidvector)
is 'print type names of oidvector field';

alter function pg_catalog.oidvectortypes(oidvector)
  owner to postgres;

create function pg_catalog.timetz_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_in
;

comment on function pg_catalog.timetz_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.timetz_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.timetz_out(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_out
;

comment on function pg_catalog.timetz_out(time with time zone)
is 'I/O';

alter function pg_catalog.timetz_out(time with time zone)
  owner to postgres;

create function pg_catalog.timetz_eq(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_eq
;

comment on function pg_catalog.timetz_eq(time with time zone, time with time zone)
is 'implementation of = operator';

alter function pg_catalog.timetz_eq(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timetz_ne(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_ne
;

comment on function pg_catalog.timetz_ne(time with time zone, time with time zone)
is 'implementation of <> operator';

alter function pg_catalog.timetz_ne(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timetz_lt(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_lt
;

comment on function pg_catalog.timetz_lt(time with time zone, time with time zone)
is 'implementation of < operator';

alter function pg_catalog.timetz_lt(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timetz_le(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_le
;

comment on function pg_catalog.timetz_le(time with time zone, time with time zone)
is 'implementation of <= operator';

alter function pg_catalog.timetz_le(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timetz_ge(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_ge
;

comment on function pg_catalog.timetz_ge(time with time zone, time with time zone)
is 'implementation of >= operator';

alter function pg_catalog.timetz_ge(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timetz_gt(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_gt
;

comment on function pg_catalog.timetz_gt(time with time zone, time with time zone)
is 'implementation of > operator';

alter function pg_catalog.timetz_gt(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timetz_cmp(time with time zone, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_cmp
;

comment on function pg_catalog.timetz_cmp(time with time zone, time with time zone)
is 'less-equal-greater';

alter function pg_catalog.timetz_cmp(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timestamptz(date, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(date, time with time zone)
is 'convert date and time with time zone to timestamp with time zone';

alter function pg_catalog.timestamptz(date, time with time zone)
  owner to postgres;

create function pg_catalog.hostmask(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hostmask
;

comment on function pg_catalog.hostmask(inet)
is 'hostmask of address';

alter function pg_catalog.hostmask(inet)
  owner to postgres;

create function pg_catalog.time(abstime)
  returns time without time zone
stable
strict
parallel safe
cost 1
language sql
as $$
select cast(cast($1 as timestamp without time zone) as pg_catalog.time)
$$;

comment on function pg_catalog.time(abstime)
is 'convert abstime to time';

alter function pg_catalog.time(abstime)
  owner to postgres;

create function pg_catalog.makeaclitem(oid, oid, text, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.makeaclitem
;

comment on function pg_catalog.makeaclitem(oid, oid, text, boolean)
is 'make ACL item';

alter function pg_catalog.makeaclitem(oid, oid, text, boolean)
  owner to postgres;

create function pg_catalog.character_length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.character_length
;

comment on function pg_catalog.character_length(char)
is 'character length';

alter function pg_catalog.character_length(char)
  owner to postgres;

create function pg_catalog.power(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.power
;

comment on function pg_catalog.power(double precision, double precision)
is 'exponentiation';

alter function pg_catalog.power(double precision, double precision)
  owner to postgres;

create function pg_catalog.character_length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.character_length
;

comment on function pg_catalog.character_length(text)
is 'character length';

alter function pg_catalog.character_length(text)
  owner to postgres;

create function pg_catalog.interval(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval
;

comment on function pg_catalog.interval(time)
is 'convert time to interval';

alter function pg_catalog.interval(time)
  owner to postgres;

create function pg_catalog.pg_lock_status(out locktype           text, out database oid, out relation oid,
                                          out page               integer, out tuple smallint, out virtualxid text,
                                          out transactionid      xid, out classid oid, out objid oid,
                                          out objsubid           smallint, out virtualtransaction text, out pid integer,
                                          out mode               text, out granted boolean, out fastpath boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lock_status
;

comment on function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid,
                                              out oid, out oid, out smallint, out text, out integer, out text,
                                              out boolean, out boolean)
is 'view system lock information';

alter function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid, out oid, out oid, out smallint, out text, out integer, out text, out boolean, out boolean)
  owner to postgres;

create function pg_catalog.char_length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char_length
;

comment on function pg_catalog.char_length(char)
is 'character length';

alter function pg_catalog.char_length(char)
  owner to postgres;

create function pg_catalog.isfinite(date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(date)
is 'finite date?';

alter function pg_catalog.isfinite(date)
  owner to postgres;

create function pg_catalog.octet_length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(text)
is 'octet length';

alter function pg_catalog.octet_length(text)
  owner to postgres;

create function pg_catalog.octet_length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(char)
is 'octet length';

alter function pg_catalog.octet_length(char)
  owner to postgres;

create function pg_catalog.factorial(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.factorial
;

comment on function pg_catalog.factorial(bigint)
is 'factorial';

alter function pg_catalog.factorial(bigint)
  owner to postgres;

create function pg_catalog.time_larger(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_larger
;

comment on function pg_catalog.time_larger(time, time)
is 'larger of two';

alter function pg_catalog.time_larger(time, time)
  owner to postgres;

create function pg_catalog.time_smaller(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_smaller
;

comment on function pg_catalog.time_smaller(time, time)
is 'smaller of two';

alter function pg_catalog.time_smaller(time, time)
  owner to postgres;

create function pg_catalog.timetz_larger(time with time zone, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_larger
;

comment on function pg_catalog.timetz_larger(time with time zone, time with time zone)
is 'larger of two';

alter function pg_catalog.timetz_larger(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.timetz_smaller(time with time zone, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_smaller
;

comment on function pg_catalog.timetz_smaller(time with time zone, time with time zone)
is 'smaller of two';

alter function pg_catalog.timetz_smaller(time with time zone, time with time zone)
  owner to postgres;

create function pg_catalog.char_length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char_length
;

comment on function pg_catalog.char_length(text)
is 'character length';

alter function pg_catalog.char_length(text)
  owner to postgres;

create function pg_catalog.date_part(text, abstime)
  returns double precision
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.date_part($1, cast($2 as timestamp with time zone))
$$;

comment on function pg_catalog.date_part(text, abstime)
is 'extract field from abstime';

alter function pg_catalog.date_part(text, abstime)
  owner to postgres;

create function pg_catalog.date_part(text, reltime)
  returns double precision
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.date_part($1, cast($2 as pg_catalog.interval))
$$;

comment on function pg_catalog.date_part(text, reltime)
is 'extract field from reltime';

alter function pg_catalog.date_part(text, reltime)
  owner to postgres;

create function pg_catalog.date_part(text, date)
  returns double precision
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.date_part($1, cast($2 as timestamp without time zone))
$$;

comment on function pg_catalog.date_part(text, date)
is 'extract field from date';

alter function pg_catalog.date_part(text, date)
  owner to postgres;

create function pg_catalog.date_part(text, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, time)
is 'extract field from time';

alter function pg_catalog.date_part(text, time)
  owner to postgres;

create function pg_catalog.age(timestamp with time zone)
  returns interval
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.age(cast(current_date as timestamp with time zone), $1)
$$;

comment on function pg_catalog.age(timestamp with time zone)
is 'date difference from today preserving months and years';

alter function pg_catalog.age(timestamp with time zone)
  owner to postgres;

create function pg_catalog.pg_get_constraintdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_constraintdef
;

comment on function pg_catalog.pg_get_constraintdef(oid)
is 'constraint description';

alter function pg_catalog.pg_get_constraintdef(oid)
  owner to postgres;

create function pg_catalog.timetz(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz
;

comment on function pg_catalog.timetz(timestamp with time zone)
is 'convert timestamp with time zone to time with time zone';

alter function pg_catalog.timetz(timestamp with time zone)
  owner to postgres;

create function pg_catalog.isfinite(timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(timestamp with time zone)
is 'finite timestamp?';

alter function pg_catalog.isfinite(timestamp with time zone)
  owner to postgres;

create function pg_catalog.isfinite(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(interval)
is 'finite interval?';

alter function pg_catalog.isfinite(interval)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_start(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_start
;

comment on function pg_catalog.pg_stat_get_backend_start(integer)
is 'statistics: start time for current backend session';

alter function pg_catalog.pg_stat_get_backend_start(integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_client_addr(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_client_addr
;

comment on function pg_catalog.pg_stat_get_backend_client_addr(integer)
is 'statistics: address of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_addr(integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_client_port(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_client_port
;

comment on function pg_catalog.pg_stat_get_backend_client_port(integer)
is 'statistics: port number of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_port(integer)
  owner to postgres;

create function pg_catalog.abs(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(real)
is 'absolute value';

alter function pg_catalog.abs(real)
  owner to postgres;

create function pg_catalog.abs(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(double precision)
is 'absolute value';

alter function pg_catalog.abs(double precision)
  owner to postgres;

create function pg_catalog.abs(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(bigint)
is 'absolute value';

alter function pg_catalog.abs(bigint)
  owner to postgres;

create function pg_catalog.abs(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(integer)
is 'absolute value';

alter function pg_catalog.abs(integer)
  owner to postgres;

create function pg_catalog.abs(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(smallint)
is 'absolute value';

alter function pg_catalog.abs(smallint)
  owner to postgres;

create function pg_catalog.name(varchar)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.name
;

comment on function pg_catalog.name(varchar)
is 'convert varchar to name';

alter function pg_catalog.name(varchar)
  owner to postgres;

create function pg_catalog.varchar(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchar
;

comment on function pg_catalog.varchar(name)
is 'convert name to varchar';

alter function pg_catalog.varchar(name)
  owner to postgres;

create function pg_catalog."current_schema"()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."current_schema"
;

comment on function pg_catalog."current_schema"()
is 'current schema name';

alter function pg_catalog."current_schema"()
  owner to postgres;

create function pg_catalog.current_schemas(boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_schemas
;

comment on function pg_catalog.current_schemas(boolean)
is 'current schema search list';

alter function pg_catalog.current_schemas(boolean)
  owner to postgres;

create function pg_catalog.overlay(text, text, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(text, text, integer, integer)
is 'substitute portion of string';

alter function pg_catalog.overlay(text, text, integer, integer)
  owner to postgres;

create function pg_catalog.overlay(text, text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(text, text, integer)
is 'substitute portion of string';

alter function pg_catalog.overlay(text, text, integer)
  owner to postgres;

create function pg_catalog.isvertical(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isvertical
;

comment on function pg_catalog.isvertical(point, point)
is 'vertically aligned';

alter function pg_catalog.isvertical(point, point)
  owner to postgres;

create function pg_catalog.ishorizontal(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ishorizontal
;

comment on function pg_catalog.ishorizontal(point, point)
is 'horizontally aligned';

alter function pg_catalog.ishorizontal(point, point)
  owner to postgres;

create function pg_catalog.isparallel(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isparallel
;

comment on function pg_catalog.isparallel(lseg, lseg)
is 'parallel';

alter function pg_catalog.isparallel(lseg, lseg)
  owner to postgres;

create function pg_catalog.isperp(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isperp
;

comment on function pg_catalog.isperp(lseg, lseg)
is 'perpendicular';

alter function pg_catalog.isperp(lseg, lseg)
  owner to postgres;

create function pg_catalog.isvertical(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isvertical
;

comment on function pg_catalog.isvertical(lseg)
is 'vertical';

alter function pg_catalog.isvertical(lseg)
  owner to postgres;

create function pg_catalog.ishorizontal(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ishorizontal
;

comment on function pg_catalog.ishorizontal(lseg)
is 'horizontal';

alter function pg_catalog.ishorizontal(lseg)
  owner to postgres;

create function pg_catalog.isparallel(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isparallel
;

comment on function pg_catalog.isparallel(line, line)
is 'parallel';

alter function pg_catalog.isparallel(line, line)
  owner to postgres;

create function pg_catalog.isperp(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isperp
;

comment on function pg_catalog.isperp(line, line)
is 'perpendicular';

alter function pg_catalog.isperp(line, line)
  owner to postgres;

create function pg_catalog.isvertical(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isvertical
;

comment on function pg_catalog.isvertical(line)
is 'vertical';

alter function pg_catalog.isvertical(line)
  owner to postgres;

create function pg_catalog.ishorizontal(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ishorizontal
;

comment on function pg_catalog.ishorizontal(line)
is 'horizontal';

alter function pg_catalog.ishorizontal(line)
  owner to postgres;

create function pg_catalog.point(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(circle)
is 'center of';

alter function pg_catalog.point(circle)
  owner to postgres;

create function pg_catalog.time(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(interval)
is 'convert interval to time';

alter function pg_catalog.time(interval)
  owner to postgres;

create function pg_catalog.box(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(point, point)
is 'convert points to box';

alter function pg_catalog.box(point, point)
  owner to postgres;

create function pg_catalog.box_add(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_add
;

comment on function pg_catalog.box_add(box, point)
is 'implementation of + operator';

alter function pg_catalog.box_add(box, point)
  owner to postgres;

create function pg_catalog.box_sub(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_sub
;

comment on function pg_catalog.box_sub(box, point)
is 'implementation of - operator';

alter function pg_catalog.box_sub(box, point)
  owner to postgres;

create function pg_catalog.box_mul(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_mul
;

comment on function pg_catalog.box_mul(box, point)
is 'implementation of * operator';

alter function pg_catalog.box_mul(box, point)
  owner to postgres;

create function pg_catalog.box_div(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_div
;

comment on function pg_catalog.box_div(box, point)
is 'implementation of / operator';

alter function pg_catalog.box_div(box, point)
  owner to postgres;

create function pg_catalog.path_contain_pt(path, point)
  returns boolean
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.on_ppath($2, $1)
$$;

comment on function pg_catalog.path_contain_pt(path, point)
is 'implementation of @> operator';

alter function pg_catalog.path_contain_pt(path, point)
  owner to postgres;

create function pg_catalog.cidr_out(cidr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_out
;

comment on function pg_catalog.cidr_out(cidr)
is 'I/O';

alter function pg_catalog.cidr_out(cidr)
  owner to postgres;

create function pg_catalog.poly_contain_pt(polygon, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_contain_pt
;

comment on function pg_catalog.poly_contain_pt(polygon, point)
is 'implementation of @> operator';

alter function pg_catalog.poly_contain_pt(polygon, point)
  owner to postgres;

create function pg_catalog.pt_contained_poly(point, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pt_contained_poly
;

comment on function pg_catalog.pt_contained_poly(point, polygon)
is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_poly(point, polygon)
  owner to postgres;

create function pg_catalog.isclosed(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isclosed
;

comment on function pg_catalog.isclosed(path)
is 'path closed?';

alter function pg_catalog.isclosed(path)
  owner to postgres;

create function pg_catalog.isopen(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isopen
;

comment on function pg_catalog.isopen(path)
is 'path open?';

alter function pg_catalog.isopen(path)
  owner to postgres;

create function pg_catalog.path_npoints(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_npoints
;

comment on function pg_catalog.path_npoints(path)
is 'implementation of # operator';

alter function pg_catalog.path_npoints(path)
  owner to postgres;

create function pg_catalog.pclose(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pclose
;

comment on function pg_catalog.pclose(path)
is 'close path';

alter function pg_catalog.pclose(path)
  owner to postgres;

create function pg_catalog.popen(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.popen
;

comment on function pg_catalog.popen(path)
is 'open path';

alter function pg_catalog.popen(path)
  owner to postgres;

create function pg_catalog.path_add(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_add
;

comment on function pg_catalog.path_add(path, path)
is 'implementation of + operator';

alter function pg_catalog.path_add(path, path)
  owner to postgres;

create function pg_catalog.path_add_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_add_pt
;

comment on function pg_catalog.path_add_pt(path, point)
is 'implementation of + operator';

alter function pg_catalog.path_add_pt(path, point)
  owner to postgres;

create function pg_catalog.path_sub_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_sub_pt
;

comment on function pg_catalog.path_sub_pt(path, point)
is 'implementation of - operator';

alter function pg_catalog.path_sub_pt(path, point)
  owner to postgres;

create function pg_catalog.path_mul_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_mul_pt
;

comment on function pg_catalog.path_mul_pt(path, point)
is 'implementation of * operator';

alter function pg_catalog.path_mul_pt(path, point)
  owner to postgres;

create function pg_catalog.path_div_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_div_pt
;

comment on function pg_catalog.path_div_pt(path, point)
is 'implementation of / operator';

alter function pg_catalog.path_div_pt(path, point)
  owner to postgres;

create function pg_catalog.point(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(double precision, double precision)
is 'convert x, y to point';

alter function pg_catalog.point(double precision, double precision)
  owner to postgres;

create function pg_catalog.point_add(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_add
;

comment on function pg_catalog.point_add(point, point)
is 'implementation of + operator';

alter function pg_catalog.point_add(point, point)
  owner to postgres;

create function pg_catalog.point_sub(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_sub
;

comment on function pg_catalog.point_sub(point, point)
is 'implementation of - operator';

alter function pg_catalog.point_sub(point, point)
  owner to postgres;

create function pg_catalog.point_mul(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_mul
;

comment on function pg_catalog.point_mul(point, point)
is 'implementation of * operator';

alter function pg_catalog.point_mul(point, point)
  owner to postgres;

create function pg_catalog.point_div(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_div
;

comment on function pg_catalog.point_div(point, point)
is 'implementation of / operator';

alter function pg_catalog.point_div(point, point)
  owner to postgres;

create function pg_catalog.poly_npoints(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_npoints
;

comment on function pg_catalog.poly_npoints(polygon)
is 'implementation of # operator';

alter function pg_catalog.poly_npoints(polygon)
  owner to postgres;

create function pg_catalog.box(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(polygon)
is 'convert polygon to bounding box';

alter function pg_catalog.box(polygon)
  owner to postgres;

create function pg_catalog.path(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path
;

comment on function pg_catalog.path(polygon)
is 'convert polygon to path';

alter function pg_catalog.path(polygon)
  owner to postgres;

create function pg_catalog.polygon(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.polygon
;

comment on function pg_catalog.polygon(box)
is 'convert box to polygon';

alter function pg_catalog.polygon(box)
  owner to postgres;

create function pg_catalog.polygon(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.polygon
;

comment on function pg_catalog.polygon(path)
is 'convert path to polygon';

alter function pg_catalog.polygon(path)
  owner to postgres;

create function pg_catalog.circle_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_in
;

comment on function pg_catalog.circle_in(cstring)
is 'I/O';

alter function pg_catalog.circle_in(cstring)
  owner to postgres;

create function pg_catalog.circle_out(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_out
;

comment on function pg_catalog.circle_out(circle)
is 'I/O';

alter function pg_catalog.circle_out(circle)
  owner to postgres;

create function pg_catalog.circle_same(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_same
;

comment on function pg_catalog.circle_same(circle, circle)
is 'implementation of ~= operator';

alter function pg_catalog.circle_same(circle, circle)
  owner to postgres;

create function pg_catalog.circle_contain(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_contain
;

comment on function pg_catalog.circle_contain(circle, circle)
is 'implementation of @> operator';

alter function pg_catalog.circle_contain(circle, circle)
  owner to postgres;

create function pg_catalog.circle_left(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_left
;

comment on function pg_catalog.circle_left(circle, circle)
is 'implementation of << operator';

alter function pg_catalog.circle_left(circle, circle)
  owner to postgres;

create function pg_catalog.circle_overleft(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overleft
;

comment on function pg_catalog.circle_overleft(circle, circle)
is 'implementation of &< operator';

alter function pg_catalog.circle_overleft(circle, circle)
  owner to postgres;

create function pg_catalog.circle_overright(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overright
;

comment on function pg_catalog.circle_overright(circle, circle)
is 'implementation of &> operator';

alter function pg_catalog.circle_overright(circle, circle)
  owner to postgres;

create function pg_catalog.circle_right(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_right
;

comment on function pg_catalog.circle_right(circle, circle)
is 'implementation of >> operator';

alter function pg_catalog.circle_right(circle, circle)
  owner to postgres;

create function pg_catalog.circle_contained(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_contained
;

comment on function pg_catalog.circle_contained(circle, circle)
is 'implementation of <@ operator';

alter function pg_catalog.circle_contained(circle, circle)
  owner to postgres;

create function pg_catalog.circle_overlap(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overlap
;

comment on function pg_catalog.circle_overlap(circle, circle)
is 'implementation of && operator';

alter function pg_catalog.circle_overlap(circle, circle)
  owner to postgres;

create function pg_catalog.circle_below(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_below
;

comment on function pg_catalog.circle_below(circle, circle)
is 'implementation of <<| operator';

alter function pg_catalog.circle_below(circle, circle)
  owner to postgres;

create function pg_catalog.circle_above(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_above
;

comment on function pg_catalog.circle_above(circle, circle)
is 'implementation of |>> operator';

alter function pg_catalog.circle_above(circle, circle)
  owner to postgres;

create function pg_catalog.circle_eq(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_eq
;

comment on function pg_catalog.circle_eq(circle, circle)
is 'implementation of = operator';

alter function pg_catalog.circle_eq(circle, circle)
  owner to postgres;

create function pg_catalog.circle_ne(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_ne
;

comment on function pg_catalog.circle_ne(circle, circle)
is 'implementation of <> operator';

alter function pg_catalog.circle_ne(circle, circle)
  owner to postgres;

create function pg_catalog.circle_lt(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_lt
;

comment on function pg_catalog.circle_lt(circle, circle)
is 'implementation of < operator';

alter function pg_catalog.circle_lt(circle, circle)
  owner to postgres;

create function pg_catalog.circle_gt(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_gt
;

comment on function pg_catalog.circle_gt(circle, circle)
is 'implementation of > operator';

alter function pg_catalog.circle_gt(circle, circle)
  owner to postgres;

create function pg_catalog.circle_le(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_le
;

comment on function pg_catalog.circle_le(circle, circle)
is 'implementation of <= operator';

alter function pg_catalog.circle_le(circle, circle)
  owner to postgres;

create function pg_catalog.circle_ge(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_ge
;

comment on function pg_catalog.circle_ge(circle, circle)
is 'implementation of >= operator';

alter function pg_catalog.circle_ge(circle, circle)
  owner to postgres;

create function pg_catalog.area(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.area
;

comment on function pg_catalog.area(circle)
is 'area of circle';

alter function pg_catalog.area(circle)
  owner to postgres;

create function pg_catalog.diameter(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.diameter
;

comment on function pg_catalog.diameter(circle)
is 'diameter of circle';

alter function pg_catalog.diameter(circle)
  owner to postgres;

create function pg_catalog.radius(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.radius
;

comment on function pg_catalog.radius(circle)
is 'radius of circle';

alter function pg_catalog.radius(circle)
  owner to postgres;

create function pg_catalog.circle_distance(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_distance
;

comment on function pg_catalog.circle_distance(circle, circle)
is 'implementation of <-> operator';

alter function pg_catalog.circle_distance(circle, circle)
  owner to postgres;

create function pg_catalog.circle_center(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_center
;

comment on function pg_catalog.circle_center(circle)
is 'implementation of @@ operator';

alter function pg_catalog.circle_center(circle)
  owner to postgres;

create function pg_catalog.circle(point, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle
;

comment on function pg_catalog.circle(point, double precision)
is 'convert point and radius to circle';

alter function pg_catalog.circle(point, double precision)
  owner to postgres;

create function pg_catalog.circle(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle
;

comment on function pg_catalog.circle(polygon)
is 'convert polygon to circle';

alter function pg_catalog.circle(polygon)
  owner to postgres;

create function pg_catalog.polygon(integer, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.polygon
;

comment on function pg_catalog.polygon(integer, circle)
is 'convert vertex count and circle to polygon';

alter function pg_catalog.polygon(integer, circle)
  owner to postgres;

create function pg_catalog.dist_pc(point, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_pc
;

comment on function pg_catalog.dist_pc(point, circle)
is 'implementation of <-> operator';

alter function pg_catalog.dist_pc(point, circle)
  owner to postgres;

create function pg_catalog.circle_contain_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_contain_pt
;

comment on function pg_catalog.circle_contain_pt(circle, point)
is 'implementation of @> operator';

alter function pg_catalog.circle_contain_pt(circle, point)
  owner to postgres;

create function pg_catalog.pt_contained_circle(point, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pt_contained_circle
;

comment on function pg_catalog.pt_contained_circle(point, circle)
is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_circle(point, circle)
  owner to postgres;

create function pg_catalog.circle(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle
;

comment on function pg_catalog.circle(box)
is 'convert box to circle';

alter function pg_catalog.circle(box)
  owner to postgres;

create function pg_catalog.box(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(circle)
is 'convert circle to box';

alter function pg_catalog.box(circle)
  owner to postgres;

create function pg_catalog.tinterval(abstime, abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tinterval
;

comment on function pg_catalog.tinterval(abstime, abstime)
is 'convert to tinterval';

alter function pg_catalog.tinterval(abstime, abstime)
  owner to postgres;

create function pg_catalog.lseg_ne(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_ne
;

comment on function pg_catalog.lseg_ne(lseg, lseg)
is 'implementation of <> operator';

alter function pg_catalog.lseg_ne(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_lt(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_lt
;

comment on function pg_catalog.lseg_lt(lseg, lseg)
is 'implementation of < operator';

alter function pg_catalog.lseg_lt(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_le(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_le
;

comment on function pg_catalog.lseg_le(lseg, lseg)
is 'implementation of <= operator';

alter function pg_catalog.lseg_le(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_gt(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_gt
;

comment on function pg_catalog.lseg_gt(lseg, lseg)
is 'implementation of > operator';

alter function pg_catalog.lseg_gt(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_ge(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_ge
;

comment on function pg_catalog.lseg_ge(lseg, lseg)
is 'implementation of >= operator';

alter function pg_catalog.lseg_ge(lseg, lseg)
  owner to postgres;

create function pg_catalog.lseg_length(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_length
;

comment on function pg_catalog.lseg_length(lseg)
is 'implementation of @-@ operator';

alter function pg_catalog.lseg_length(lseg)
  owner to postgres;

create function pg_catalog.close_ls(line, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_ls
;

comment on function pg_catalog.close_ls(line, lseg)
is 'implementation of ## operator';

alter function pg_catalog.close_ls(line, lseg)
  owner to postgres;

create function pg_catalog.close_lseg(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_lseg
;

comment on function pg_catalog.close_lseg(lseg, lseg)
is 'implementation of ## operator';

alter function pg_catalog.close_lseg(lseg, lseg)
  owner to postgres;

create function pg_catalog.line_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_in
;

comment on function pg_catalog.line_in(cstring)
is 'I/O';

alter function pg_catalog.line_in(cstring)
  owner to postgres;

create function pg_catalog.line_out(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_out
;

comment on function pg_catalog.line_out(line)
is 'I/O';

alter function pg_catalog.line_out(line)
  owner to postgres;

create function pg_catalog.line_eq(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_eq
;

comment on function pg_catalog.line_eq(line, line)
is 'implementation of = operator';

alter function pg_catalog.line_eq(line, line)
  owner to postgres;

create function pg_catalog.line(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line
;

comment on function pg_catalog.line(point, point)
is 'construct line from points';

alter function pg_catalog.line(point, point)
  owner to postgres;

create function pg_catalog.line_interpt(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_interpt
;

comment on function pg_catalog.line_interpt(line, line)
is 'implementation of # operator';

alter function pg_catalog.line_interpt(line, line)
  owner to postgres;

create function pg_catalog.line_intersect(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_intersect
;

comment on function pg_catalog.line_intersect(line, line)
is 'implementation of ?# operator';

alter function pg_catalog.line_intersect(line, line)
  owner to postgres;

create function pg_catalog.line_parallel(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_parallel
;

comment on function pg_catalog.line_parallel(line, line)
is 'implementation of ?|| operator';

alter function pg_catalog.line_parallel(line, line)
  owner to postgres;

create function pg_catalog.line_perp(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_perp
;

comment on function pg_catalog.line_perp(line, line)
is 'implementation of ?-| operator';

alter function pg_catalog.line_perp(line, line)
  owner to postgres;

create function pg_catalog.line_vertical(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_vertical
;

comment on function pg_catalog.line_vertical(line)
is 'implementation of ?| operator';

alter function pg_catalog.line_vertical(line)
  owner to postgres;

create function pg_catalog.line_horizontal(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_horizontal
;

comment on function pg_catalog.line_horizontal(line)
is 'implementation of ?- operator';

alter function pg_catalog.line_horizontal(line)
  owner to postgres;

create function pg_catalog.length(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(lseg)
is 'distance between endpoints';

alter function pg_catalog.length(lseg)
  owner to postgres;

create function pg_catalog.length(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(path)
is 'sum of path segments';

alter function pg_catalog.length(path)
  owner to postgres;

create function pg_catalog.point(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(lseg)
is 'center of';

alter function pg_catalog.point(lseg)
  owner to postgres;

create function pg_catalog.point(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(path)
is 'center of';

alter function pg_catalog.point(path)
  owner to postgres;

create function pg_catalog.point(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(box)
is 'center of';

alter function pg_catalog.point(box)
  owner to postgres;

create function pg_catalog.point(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(polygon)
is 'center of';

alter function pg_catalog.point(polygon)
  owner to postgres;

create function pg_catalog.lseg(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg
;

comment on function pg_catalog.lseg(box)
is 'diagonal of';

alter function pg_catalog.lseg(box)
  owner to postgres;

create function pg_catalog.center(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.center
;

comment on function pg_catalog.center(box)
is 'center of';

alter function pg_catalog.center(box)
  owner to postgres;

create function pg_catalog.center(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.center
;

comment on function pg_catalog.center(circle)
is 'center of';

alter function pg_catalog.center(circle)
  owner to postgres;

create function pg_catalog.polygon(circle)
  returns polygon
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.polygon(12, $1)
$$;

comment on function pg_catalog.polygon(circle)
is 'convert circle to 12-vertex polygon';

alter function pg_catalog.polygon(circle)
  owner to postgres;

create function pg_catalog.npoints(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.npoints
;

comment on function pg_catalog.npoints(path)
is 'number of points';

alter function pg_catalog.npoints(path)
  owner to postgres;

create function pg_catalog.npoints(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.npoints
;

comment on function pg_catalog.npoints(polygon)
is 'number of points';

alter function pg_catalog.npoints(polygon)
  owner to postgres;

create function pg_catalog.bit_in(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_in
;

comment on function pg_catalog.bit_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.bit_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.bit_out(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_out
;

comment on function pg_catalog.bit_out(bit)
is 'I/O';

alter function pg_catalog.bit_out(bit)
  owner to postgres;

create function pg_catalog."like"(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."like"
;

comment on function pg_catalog."like"(text, text)
is 'matches LIKE expression';

alter function pg_catalog."like"(text, text)
  owner to postgres;

create function pg_catalog.notlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.notlike
;

comment on function pg_catalog.notlike(text, text)
is 'does not match LIKE expression';

alter function pg_catalog.notlike(text, text)
  owner to postgres;

create function pg_catalog."like"(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."like"
;

comment on function pg_catalog."like"(name, text)
is 'matches LIKE expression';

alter function pg_catalog."like"(name, text)
  owner to postgres;

create function pg_catalog.notlike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.notlike
;

comment on function pg_catalog.notlike(name, text)
is 'does not match LIKE expression';

alter function pg_catalog.notlike(name, text)
  owner to postgres;

create function pg_catalog.pg_get_ruledef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_ruledef
;

comment on function pg_catalog.pg_get_ruledef(oid)
is 'source text of a rule';

alter function pg_catalog.pg_get_ruledef(oid)
  owner to postgres;

create function pg_catalog.nextval(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.nextval
;

comment on function pg_catalog.nextval(regclass)
is 'sequence next value';

alter function pg_catalog.nextval(regclass)
  owner to postgres;

create function pg_catalog.currval(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.currval
;

comment on function pg_catalog.currval(regclass)
is 'sequence current value';

alter function pg_catalog.currval(regclass)
  owner to postgres;

create function pg_catalog.setval(regclass, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.setval
;

comment on function pg_catalog.setval(regclass, bigint)
is 'set sequence value';

alter function pg_catalog.setval(regclass, bigint)
  owner to postgres;

create function pg_catalog.varbit_in(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_in
;

comment on function pg_catalog.varbit_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.varbit_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.varbit_out(bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_out
;

comment on function pg_catalog.varbit_out(bit varying)
is 'I/O';

alter function pg_catalog.varbit_out(bit varying)
  owner to postgres;

create function pg_catalog.biteq(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.biteq
;

comment on function pg_catalog.biteq(bit, bit)
is 'implementation of = operator';

alter function pg_catalog.biteq(bit, bit)
  owner to postgres;

create function pg_catalog.bitne(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitne
;

comment on function pg_catalog.bitne(bit, bit)
is 'implementation of <> operator';

alter function pg_catalog.bitne(bit, bit)
  owner to postgres;

create function pg_catalog.bitge(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitge
;

comment on function pg_catalog.bitge(bit, bit)
is 'implementation of >= operator';

alter function pg_catalog.bitge(bit, bit)
  owner to postgres;

create function pg_catalog.bitgt(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitgt
;

comment on function pg_catalog.bitgt(bit, bit)
is 'implementation of > operator';

alter function pg_catalog.bitgt(bit, bit)
  owner to postgres;

create function pg_catalog.bitle(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitle
;

comment on function pg_catalog.bitle(bit, bit)
is 'implementation of <= operator';

alter function pg_catalog.bitle(bit, bit)
  owner to postgres;

create function pg_catalog.bitlt(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitlt
;

comment on function pg_catalog.bitlt(bit, bit)
is 'implementation of < operator';

alter function pg_catalog.bitlt(bit, bit)
  owner to postgres;

create function pg_catalog.bitcmp(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitcmp
;

comment on function pg_catalog.bitcmp(bit, bit)
is 'less-equal-greater';

alter function pg_catalog.bitcmp(bit, bit)
  owner to postgres;

create function pg_catalog.pg_encoding_to_char(integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_encoding_to_char
;

comment on function pg_catalog.pg_encoding_to_char(integer)
is 'convert encoding id to encoding name';

alter function pg_catalog.pg_encoding_to_char(integer)
  owner to postgres;

create function pg_catalog.random()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.random
;

comment on function pg_catalog.random()
is 'random value';

alter function pg_catalog.random()
  owner to postgres;

create function pg_catalog.setseed(double precision)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.setseed
;

comment on function pg_catalog.setseed(double precision)
is 'set random seed';

alter function pg_catalog.setseed(double precision)
  owner to postgres;

create function pg_catalog.asin(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.asin
;

comment on function pg_catalog.asin(double precision)
is 'arcsine';

alter function pg_catalog.asin(double precision)
  owner to postgres;

create function pg_catalog.acos(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.acos
;

comment on function pg_catalog.acos(double precision)
is 'arccosine';

alter function pg_catalog.acos(double precision)
  owner to postgres;

create function pg_catalog.atan(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atan
;

comment on function pg_catalog.atan(double precision)
is 'arctangent';

alter function pg_catalog.atan(double precision)
  owner to postgres;

create function pg_catalog.atan2(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atan2
;

comment on function pg_catalog.atan2(double precision, double precision)
is 'arctangent, two arguments';

alter function pg_catalog.atan2(double precision, double precision)
  owner to postgres;

create function pg_catalog.sin(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sin
;

comment on function pg_catalog.sin(double precision)
is 'sine';

alter function pg_catalog.sin(double precision)
  owner to postgres;

create function pg_catalog.cos(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cos
;

comment on function pg_catalog.cos(double precision)
is 'cosine';

alter function pg_catalog.cos(double precision)
  owner to postgres;

create function pg_catalog.tan(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tan
;

comment on function pg_catalog.tan(double precision)
is 'tangent';

alter function pg_catalog.tan(double precision)
  owner to postgres;

create function pg_catalog.cot(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cot
;

comment on function pg_catalog.cot(double precision)
is 'cotangent';

alter function pg_catalog.cot(double precision)
  owner to postgres;

create function pg_catalog.degrees(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.degrees
;

comment on function pg_catalog.degrees(double precision)
is 'radians to degrees';

alter function pg_catalog.degrees(double precision)
  owner to postgres;

create function pg_catalog.radians(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.radians
;

comment on function pg_catalog.radians(double precision)
is 'degrees to radians';

alter function pg_catalog.radians(double precision)
  owner to postgres;

create function pg_catalog.pi()
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pi
;

comment on function pg_catalog.pi()
is 'PI';

alter function pg_catalog.pi()
  owner to postgres;

create function pg_catalog.interval_mul(interval, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_mul
;

comment on function pg_catalog.interval_mul(interval, double precision)
is 'implementation of * operator';

alter function pg_catalog.interval_mul(interval, double precision)
  owner to postgres;

create function pg_catalog.pg_typeof("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_typeof
;

comment on function pg_catalog.pg_typeof("any")
is 'type of the argument';

alter function pg_catalog.pg_typeof("any")
  owner to postgres;

create function pg_catalog.ascii(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ascii
;

comment on function pg_catalog.ascii(text)
is 'convert first char to int4';

alter function pg_catalog.ascii(text)
  owner to postgres;

create function pg_catalog.chr(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.chr
;

comment on function pg_catalog.chr(integer)
is 'convert int4 to char';

alter function pg_catalog.chr(integer)
  owner to postgres;

create function pg_catalog.repeat(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.repeat
;

comment on function pg_catalog.repeat(text, integer)
is 'replicate string n times';

alter function pg_catalog.repeat(text, integer)
  owner to postgres;

create function pg_catalog.similar_escape(text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.similar_escape
;

comment on function pg_catalog.similar_escape(text, text)
is 'convert SQL99 regexp pattern to POSIX style';

alter function pg_catalog.similar_escape(text, text)
  owner to postgres;

create function pg_catalog.mul_d_interval(double precision, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mul_d_interval
;

comment on function pg_catalog.mul_d_interval(double precision, interval)
is 'implementation of * operator';

alter function pg_catalog.mul_d_interval(double precision, interval)
  owner to postgres;

create function pg_catalog.bpcharlike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharlike
;

comment on function pg_catalog.bpcharlike(char, text)
is 'implementation of ~~ operator';

alter function pg_catalog.bpcharlike(char, text)
  owner to postgres;

create function pg_catalog.bpcharnlike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharnlike
;

comment on function pg_catalog.bpcharnlike(char, text)
is 'implementation of !~~ operator';

alter function pg_catalog.bpcharnlike(char, text)
  owner to postgres;

create function pg_catalog.texticlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticlike
;

comment on function pg_catalog.texticlike(text, text)
is 'implementation of ~~* operator';

alter function pg_catalog.texticlike(text, text)
  owner to postgres;

create function pg_catalog.texticnlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticnlike
;

comment on function pg_catalog.texticnlike(text, text)
is 'implementation of !~~* operator';

alter function pg_catalog.texticnlike(text, text)
  owner to postgres;

create function pg_catalog.nameiclike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameiclike
;

comment on function pg_catalog.nameiclike(name, text)
is 'implementation of ~~* operator';

alter function pg_catalog.nameiclike(name, text)
  owner to postgres;

create function pg_catalog.nameicnlike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameicnlike
;

comment on function pg_catalog.nameicnlike(name, text)
is 'implementation of !~~* operator';

alter function pg_catalog.nameicnlike(name, text)
  owner to postgres;

create function pg_catalog.like_escape(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.like_escape
;

comment on function pg_catalog.like_escape(text, text)
is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(text, text)
  owner to postgres;

create function pg_catalog.oidgt(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidgt
;

comment on function pg_catalog.oidgt(oid, oid)
is 'implementation of > operator';

alter function pg_catalog.oidgt(oid, oid)
  owner to postgres;

create function pg_catalog.oidge(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidge
;

comment on function pg_catalog.oidge(oid, oid)
is 'implementation of >= operator';

alter function pg_catalog.oidge(oid, oid)
  owner to postgres;

create function pg_catalog.pg_get_viewdef(text)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(text)
is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(text)
  owner to postgres;

create function pg_catalog.pg_get_viewdef(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(oid)
is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(oid)
  owner to postgres;

create function pg_catalog.pg_get_userbyid(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_userbyid
;

comment on function pg_catalog.pg_get_userbyid(oid)
is 'role name by OID (with fallback)';

alter function pg_catalog.pg_get_userbyid(oid)
  owner to postgres;

create function pg_catalog.pg_get_indexdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_indexdef
;

comment on function pg_catalog.pg_get_indexdef(oid)
is 'index description';

alter function pg_catalog.pg_get_indexdef(oid)
  owner to postgres;

create function pg_catalog."RI_FKey_check_ins"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_check_ins"
;

comment on function pg_catalog."RI_FKey_check_ins"()
is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_ins"()
  owner to postgres;

create function pg_catalog."RI_FKey_check_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_check_upd"
;

comment on function pg_catalog."RI_FKey_check_upd"()
is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_upd"()
  owner to postgres;

create function pg_catalog."RI_FKey_cascade_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_cascade_del"
;

comment on function pg_catalog."RI_FKey_cascade_del"()
is 'referential integrity ON DELETE CASCADE';

alter function pg_catalog."RI_FKey_cascade_del"()
  owner to postgres;

create function pg_catalog."RI_FKey_cascade_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_cascade_upd"
;

comment on function pg_catalog."RI_FKey_cascade_upd"()
is 'referential integrity ON UPDATE CASCADE';

alter function pg_catalog."RI_FKey_cascade_upd"()
  owner to postgres;

create function pg_catalog."RI_FKey_restrict_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_restrict_del"
;

comment on function pg_catalog."RI_FKey_restrict_del"()
is 'referential integrity ON DELETE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_del"()
  owner to postgres;

create function pg_catalog."RI_FKey_restrict_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_restrict_upd"
;

comment on function pg_catalog."RI_FKey_restrict_upd"()
is 'referential integrity ON UPDATE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_upd"()
  owner to postgres;

create function pg_catalog."RI_FKey_setnull_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setnull_del"
;

comment on function pg_catalog."RI_FKey_setnull_del"()
is 'referential integrity ON DELETE SET NULL';

alter function pg_catalog."RI_FKey_setnull_del"()
  owner to postgres;

create function pg_catalog."RI_FKey_setnull_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setnull_upd"
;

comment on function pg_catalog."RI_FKey_setnull_upd"()
is 'referential integrity ON UPDATE SET NULL';

alter function pg_catalog."RI_FKey_setnull_upd"()
  owner to postgres;

create function pg_catalog."RI_FKey_setdefault_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setdefault_del"
;

comment on function pg_catalog."RI_FKey_setdefault_del"()
is 'referential integrity ON DELETE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_del"()
  owner to postgres;

create function pg_catalog."RI_FKey_setdefault_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setdefault_upd"
;

comment on function pg_catalog."RI_FKey_setdefault_upd"()
is 'referential integrity ON UPDATE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_upd"()
  owner to postgres;

create function pg_catalog."RI_FKey_noaction_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_noaction_del"
;

comment on function pg_catalog."RI_FKey_noaction_del"()
is 'referential integrity ON DELETE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_del"()
  owner to postgres;

create function pg_catalog."RI_FKey_noaction_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_noaction_upd"
;

comment on function pg_catalog."RI_FKey_noaction_upd"()
is 'referential integrity ON UPDATE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_upd"()
  owner to postgres;

create function pg_catalog.bpcharicregexeq(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharicregexeq
;

comment on function pg_catalog.bpcharicregexeq(char, text)
is 'implementation of ~* operator';

alter function pg_catalog.bpcharicregexeq(char, text)
  owner to postgres;

create function pg_catalog.bpcharicregexne(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharicregexne
;

comment on function pg_catalog.bpcharicregexne(char, text)
is 'implementation of !~* operator';

alter function pg_catalog.bpcharicregexne(char, text)
  owner to postgres;

create function pg_catalog.bpcharregexeq(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharregexeq
;

comment on function pg_catalog.bpcharregexeq(char, text)
is 'implementation of ~ operator';

alter function pg_catalog.bpcharregexeq(char, text)
  owner to postgres;

create function pg_catalog.bpcharregexne(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharregexne
;

comment on function pg_catalog.bpcharregexne(char, text)
is 'implementation of !~ operator';

alter function pg_catalog.bpcharregexne(char, text)
  owner to postgres;

create function pg_catalog.bpchariclike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchariclike
;

comment on function pg_catalog.bpchariclike(char, text)
is 'implementation of ~~* operator';

alter function pg_catalog.bpchariclike(char, text)
  owner to postgres;

create function pg_catalog.bpcharicnlike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharicnlike
;

comment on function pg_catalog.bpcharicnlike(char, text)
is 'implementation of !~~* operator';

alter function pg_catalog.bpcharicnlike(char, text)
  owner to postgres;

create function pg_catalog.pg_get_triggerdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_triggerdef
;

comment on function pg_catalog.pg_get_triggerdef(oid)
is 'trigger description';

alter function pg_catalog.pg_get_triggerdef(oid)
  owner to postgres;

create function pg_catalog.pg_get_serial_sequence(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_serial_sequence
;

comment on function pg_catalog.pg_get_serial_sequence(text, text)
is 'name of sequence for a serial column';

alter function pg_catalog.pg_get_serial_sequence(text, text)
  owner to postgres;

create function pg_catalog.varbiteq(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbiteq
;

comment on function pg_catalog.varbiteq(bit varying, bit varying)
is 'implementation of = operator';

alter function pg_catalog.varbiteq(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.varbitne(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitne
;

comment on function pg_catalog.varbitne(bit varying, bit varying)
is 'implementation of <> operator';

alter function pg_catalog.varbitne(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.varbitge(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitge
;

comment on function pg_catalog.varbitge(bit varying, bit varying)
is 'implementation of >= operator';

alter function pg_catalog.varbitge(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.varbitgt(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitgt
;

comment on function pg_catalog.varbitgt(bit varying, bit varying)
is 'implementation of > operator';

alter function pg_catalog.varbitgt(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.varbitle(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitle
;

comment on function pg_catalog.varbitle(bit varying, bit varying)
is 'implementation of <= operator';

alter function pg_catalog.varbitle(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.varbitlt(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitlt
;

comment on function pg_catalog.varbitlt(bit varying, bit varying)
is 'implementation of < operator';

alter function pg_catalog.varbitlt(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.varbitcmp(bit varying, bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitcmp
;

comment on function pg_catalog.varbitcmp(bit varying, bit varying)
is 'less-equal-greater';

alter function pg_catalog.varbitcmp(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.bitand(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitand
;

comment on function pg_catalog.bitand(bit, bit)
is 'implementation of & operator';

alter function pg_catalog.bitand(bit, bit)
  owner to postgres;

create function pg_catalog.bitor(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitor
;

comment on function pg_catalog.bitor(bit, bit)
is 'implementation of | operator';

alter function pg_catalog.bitor(bit, bit)
  owner to postgres;

create function pg_catalog.bitxor(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitxor
;

comment on function pg_catalog.bitxor(bit, bit)
is 'implementation of # operator';

alter function pg_catalog.bitxor(bit, bit)
  owner to postgres;

create function pg_catalog.bitnot(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitnot
;

comment on function pg_catalog.bitnot(bit)
is 'implementation of ~ operator';

alter function pg_catalog.bitnot(bit)
  owner to postgres;

create function pg_catalog.bitshiftleft(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitshiftleft
;

comment on function pg_catalog.bitshiftleft(bit, integer)
is 'implementation of << operator';

alter function pg_catalog.bitshiftleft(bit, integer)
  owner to postgres;

create function pg_catalog.bitshiftright(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitshiftright
;

comment on function pg_catalog.bitshiftright(bit, integer)
is 'implementation of >> operator';

alter function pg_catalog.bitshiftright(bit, integer)
  owner to postgres;

create function pg_catalog.bitcat(bit varying, bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitcat
;

comment on function pg_catalog.bitcat(bit varying, bit varying)
is 'implementation of || operator';

alter function pg_catalog.bitcat(bit varying, bit varying)
  owner to postgres;

create function pg_catalog.substring(bit, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bit, integer, integer)
is 'extract portion of bitstring';

alter function pg_catalog.substring(bit, integer, integer)
  owner to postgres;

create function pg_catalog.length(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(bit)
is 'bitstring length';

alter function pg_catalog.length(bit)
  owner to postgres;

create function pg_catalog.octet_length(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(bit)
is 'octet length';

alter function pg_catalog.octet_length(bit)
  owner to postgres;

create function pg_catalog.bit(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit
;

comment on function pg_catalog.bit(integer, integer)
is 'convert int4 to bitstring';

alter function pg_catalog.bit(integer, integer)
  owner to postgres;

create function pg_catalog.int4(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(bit)
is 'convert bitstring to int4';

alter function pg_catalog.int4(bit)
  owner to postgres;

create function pg_catalog.bit(bit, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit
;

comment on function pg_catalog.bit(bit, integer, boolean)
is 'adjust bit() to typmod length';

alter function pg_catalog.bit(bit, integer, boolean)
  owner to postgres;

create function pg_catalog.pg_get_keywords(out word text, out catcode "char", out catdesc text)
stable
strict
parallel safe
cost 10
rows 400
language internal
as
-- missing source code for pg_catalog.pg_get_keywords
;

comment on function pg_catalog.pg_get_keywords(out text, out "char", out text)
is 'list of SQL keywords';

alter function pg_catalog.pg_get_keywords(out text, out "char", out text)
  owner to postgres;

create function pg_catalog.varbit(bit varying, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit
;

comment on function pg_catalog.varbit(bit varying, integer, boolean)
is 'adjust varbit() to typmod length';

alter function pg_catalog.varbit(bit varying, integer, boolean)
  owner to postgres;

create function pg_catalog.time_hash(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_hash
;

comment on function pg_catalog.time_hash(time)
is 'hash';

alter function pg_catalog.time_hash(time)
  owner to postgres;

create function pg_catalog.aclexplode(acl aclitem [], out grantor oid, out grantee oid, out privilege_type text,
                                                      out is_grantable boolean)
stable
strict
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.aclexplode
;

comment on function pg_catalog.aclexplode(aclitem [], out oid, out oid, out text, out boolean)
is 'convert ACL item array to table, for use by information schema';

alter function pg_catalog.aclexplode(aclitem [], out oid, out oid, out text, out boolean)
  owner to postgres;

create function pg_catalog.time_mi_time(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_mi_time
;

comment on function pg_catalog.time_mi_time(time, time)
is 'implementation of - operator';

alter function pg_catalog.time_mi_time(time, time)
  owner to postgres;

create function pg_catalog.boolle(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolle
;

comment on function pg_catalog.boolle(boolean, boolean)
is 'implementation of <= operator';

alter function pg_catalog.boolle(boolean, boolean)
  owner to postgres;

create function pg_catalog.boolge(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolge
;

comment on function pg_catalog.boolge(boolean, boolean)
is 'implementation of >= operator';

alter function pg_catalog.boolge(boolean, boolean)
  owner to postgres;

create function pg_catalog.btboolcmp(boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btboolcmp
;

comment on function pg_catalog.btboolcmp(boolean, boolean)
is 'less-equal-greater';

alter function pg_catalog.btboolcmp(boolean, boolean)
  owner to postgres;

create function pg_catalog.timetz_hash(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_hash
;

comment on function pg_catalog.timetz_hash(time with time zone)
is 'hash';

alter function pg_catalog.timetz_hash(time with time zone)
  owner to postgres;

create function pg_catalog.interval_hash(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_hash
;

comment on function pg_catalog.interval_hash(interval)
is 'hash';

alter function pg_catalog.interval_hash(interval)
  owner to postgres;

create function pg_catalog.position(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.position
;

comment on function pg_catalog.position(bit, bit)
is 'position of sub-bitstring';

alter function pg_catalog.position(bit, bit)
  owner to postgres;

create function pg_catalog.substring(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bit, integer)
is 'extract portion of bitstring';

alter function pg_catalog.substring(bit, integer)
  owner to postgres;

create function pg_catalog.numeric_in(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_in
;

comment on function pg_catalog.numeric_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.numeric_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.numeric_out(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_out
;

comment on function pg_catalog.numeric_out(numeric)
is 'I/O';

alter function pg_catalog.numeric_out(numeric)
  owner to postgres;

create function pg_catalog.numeric(numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(numeric, integer)
is 'adjust numeric to typmod precision/scale';

alter function pg_catalog.numeric(numeric, integer)
  owner to postgres;

create function pg_catalog.numeric_abs(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_abs
;

comment on function pg_catalog.numeric_abs(numeric)
is 'implementation of @ operator';

alter function pg_catalog.numeric_abs(numeric)
  owner to postgres;

create function pg_catalog.abs(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(numeric)
is 'absolute value';

alter function pg_catalog.abs(numeric)
  owner to postgres;

create function pg_catalog.sign(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sign
;

comment on function pg_catalog.sign(numeric)
is 'sign of value';

alter function pg_catalog.sign(numeric)
  owner to postgres;

create function pg_catalog.round(numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.round
;

comment on function pg_catalog.round(numeric, integer)
is 'value rounded to ''scale''';

alter function pg_catalog.round(numeric, integer)
  owner to postgres;

create function pg_catalog.round(numeric)
  returns numeric
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.round($1, 0)
$$;

comment on function pg_catalog.round(numeric)
is 'value rounded to ''scale'' of zero';

alter function pg_catalog.round(numeric)
  owner to postgres;

create function pg_catalog.trunc(numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(numeric, integer)
is 'value truncated to ''scale''';

alter function pg_catalog.trunc(numeric, integer)
  owner to postgres;

create function pg_catalog.trunc(numeric)
  returns numeric
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.trunc($1, 0)
$$;

comment on function pg_catalog.trunc(numeric)
is 'value truncated to ''scale'' of zero';

alter function pg_catalog.trunc(numeric)
  owner to postgres;

create function pg_catalog.ceil(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceil
;

comment on function pg_catalog.ceil(numeric)
is 'nearest integer >= value';

alter function pg_catalog.ceil(numeric)
  owner to postgres;

create function pg_catalog.floor(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.floor
;

comment on function pg_catalog.floor(numeric)
is 'nearest integer <= value';

alter function pg_catalog.floor(numeric)
  owner to postgres;

create function pg_catalog.length(bytea, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(bytea, name)
is 'length of string in specified encoding';

alter function pg_catalog.length(bytea, name)
  owner to postgres;

create function pg_catalog.convert_from(bytea, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.convert_from
;

comment on function pg_catalog.convert_from(bytea, name)
is 'convert string with specified source encoding name';

alter function pg_catalog.convert_from(bytea, name)
  owner to postgres;

create function pg_catalog.cidr(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr
;

comment on function pg_catalog.cidr(inet)
is 'convert inet to cidr';

alter function pg_catalog.cidr(inet)
  owner to postgres;

create function pg_catalog.pg_get_expr(pg_node_tree, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_expr
;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid)
is 'deparse an encoded expression';

alter function pg_catalog.pg_get_expr(pg_node_tree, oid)
  owner to postgres;

create function pg_catalog.convert_to(text, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.convert_to
;

comment on function pg_catalog.convert_to(text, name)
is 'convert string with specified destination encoding name';

alter function pg_catalog.convert_to(text, name)
  owner to postgres;

create function pg_catalog.numeric_eq(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_eq
;

comment on function pg_catalog.numeric_eq(numeric, numeric)
is 'implementation of = operator';

alter function pg_catalog.numeric_eq(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_ne(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_ne
;

comment on function pg_catalog.numeric_ne(numeric, numeric)
is 'implementation of <> operator';

alter function pg_catalog.numeric_ne(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_gt(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_gt
;

comment on function pg_catalog.numeric_gt(numeric, numeric)
is 'implementation of > operator';

alter function pg_catalog.numeric_gt(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_ge(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_ge
;

comment on function pg_catalog.numeric_ge(numeric, numeric)
is 'implementation of >= operator';

alter function pg_catalog.numeric_ge(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_lt(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_lt
;

comment on function pg_catalog.numeric_lt(numeric, numeric)
is 'implementation of < operator';

alter function pg_catalog.numeric_lt(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_le(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_le
;

comment on function pg_catalog.numeric_le(numeric, numeric)
is 'implementation of <= operator';

alter function pg_catalog.numeric_le(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_add(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_add
;

comment on function pg_catalog.numeric_add(numeric, numeric)
is 'implementation of + operator';

alter function pg_catalog.numeric_add(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_sub(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sub
;

comment on function pg_catalog.numeric_sub(numeric, numeric)
is 'implementation of - operator';

alter function pg_catalog.numeric_sub(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_mul(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_mul
;

comment on function pg_catalog.numeric_mul(numeric, numeric)
is 'implementation of * operator';

alter function pg_catalog.numeric_mul(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_div(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_div
;

comment on function pg_catalog.numeric_div(numeric, numeric)
is 'implementation of / operator';

alter function pg_catalog.numeric_div(numeric, numeric)
  owner to postgres;

create function pg_catalog.mod(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(numeric, numeric)
is 'modulus';

alter function pg_catalog.mod(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_mod(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_mod
;

comment on function pg_catalog.numeric_mod(numeric, numeric)
is 'implementation of % operator';

alter function pg_catalog.numeric_mod(numeric, numeric)
  owner to postgres;

create function pg_catalog.sqrt(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sqrt
;

comment on function pg_catalog.sqrt(numeric)
is 'square root';

alter function pg_catalog.sqrt(numeric)
  owner to postgres;

create function pg_catalog.numeric_sqrt(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sqrt
;

comment on function pg_catalog.numeric_sqrt(numeric)
is 'square root';

alter function pg_catalog.numeric_sqrt(numeric)
  owner to postgres;

create function pg_catalog.exp(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.exp
;

comment on function pg_catalog.exp(numeric)
is 'natural exponential (e^x)';

alter function pg_catalog.exp(numeric)
  owner to postgres;

create function pg_catalog.numeric_exp(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_exp
;

comment on function pg_catalog.numeric_exp(numeric)
is 'natural exponential (e^x)';

alter function pg_catalog.numeric_exp(numeric)
  owner to postgres;

create function pg_catalog.ln(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ln
;

comment on function pg_catalog.ln(numeric)
is 'natural logarithm';

alter function pg_catalog.ln(numeric)
  owner to postgres;

create function pg_catalog.numeric_ln(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_ln
;

comment on function pg_catalog.numeric_ln(numeric)
is 'natural logarithm';

alter function pg_catalog.numeric_ln(numeric)
  owner to postgres;

create function pg_catalog.log(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.log
;

comment on function pg_catalog.log(numeric, numeric)
is 'logarithm base m of n';

alter function pg_catalog.log(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_log(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_log
;

comment on function pg_catalog.numeric_log(numeric, numeric)
is 'logarithm base m of n';

alter function pg_catalog.numeric_log(numeric, numeric)
  owner to postgres;

create function pg_catalog.pow(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pow
;

comment on function pg_catalog.pow(numeric, numeric)
is 'exponentiation';

alter function pg_catalog.pow(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_power(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_power
;

comment on function pg_catalog.numeric_power(numeric, numeric)
is 'implementation of ^ operator';

alter function pg_catalog.numeric_power(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(integer)
is 'convert int4 to numeric';

alter function pg_catalog.numeric(integer)
  owner to postgres;

create function pg_catalog.log(numeric)
  returns numeric
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.log(10, $1)
$$;

comment on function pg_catalog.log(numeric)
is 'base 10 logarithm';

alter function pg_catalog.log(numeric)
  owner to postgres;

create function pg_catalog.numeric(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(real)
is 'convert float4 to numeric';

alter function pg_catalog.numeric(real)
  owner to postgres;

create function pg_catalog.numeric(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(double precision)
is 'convert float8 to numeric';

alter function pg_catalog.numeric(double precision)
  owner to postgres;

create function pg_catalog.int4(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(numeric)
is 'convert numeric to int4';

alter function pg_catalog.int4(numeric)
  owner to postgres;

create function pg_catalog.float4(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(numeric)
is 'convert numeric to float4';

alter function pg_catalog.float4(numeric)
  owner to postgres;

create function pg_catalog.float8(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(numeric)
is 'convert numeric to float8';

alter function pg_catalog.float8(numeric)
  owner to postgres;

create function pg_catalog.time_pl_interval(time, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_pl_interval
;

comment on function pg_catalog.time_pl_interval(time, interval)
is 'implementation of + operator';

alter function pg_catalog.time_pl_interval(time, interval)
  owner to postgres;

create function pg_catalog.time_mi_interval(time, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_mi_interval
;

comment on function pg_catalog.time_mi_interval(time, interval)
is 'implementation of - operator';

alter function pg_catalog.time_mi_interval(time, interval)
  owner to postgres;

create function pg_catalog.timetz_pl_interval(time with time zone, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_pl_interval
;

comment on function pg_catalog.timetz_pl_interval(time with time zone, interval)
is 'implementation of + operator';

alter function pg_catalog.timetz_pl_interval(time with time zone, interval)
  owner to postgres;

create function pg_catalog.timetz_mi_interval(time with time zone, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_mi_interval
;

comment on function pg_catalog.timetz_mi_interval(time with time zone, interval)
is 'implementation of - operator';

alter function pg_catalog.timetz_mi_interval(time with time zone, interval)
  owner to postgres;

create function pg_catalog.numeric_inc(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_inc
;

comment on function pg_catalog.numeric_inc(numeric)
is 'increment by one';

alter function pg_catalog.numeric_inc(numeric)
  owner to postgres;

create function pg_catalog.setval(regclass, bigint, boolean)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.setval
;

comment on function pg_catalog.setval(regclass, bigint, boolean)
is 'set sequence value and is_called status';

alter function pg_catalog.setval(regclass, bigint, boolean)
  owner to postgres;

create function pg_catalog.numeric_smaller(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_smaller
;

comment on function pg_catalog.numeric_smaller(numeric, numeric)
is 'smaller of two';

alter function pg_catalog.numeric_smaller(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_larger(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_larger
;

comment on function pg_catalog.numeric_larger(numeric, numeric)
is 'larger of two';

alter function pg_catalog.numeric_larger(numeric, numeric)
  owner to postgres;

create function pg_catalog.to_char(interval, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(interval, text)
is 'format interval to text';

alter function pg_catalog.to_char(interval, text)
  owner to postgres;

create function pg_catalog.numeric_cmp(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_cmp
;

comment on function pg_catalog.numeric_cmp(numeric, numeric)
is 'less-equal-greater';

alter function pg_catalog.numeric_cmp(numeric, numeric)
  owner to postgres;

create function pg_catalog.to_char(timestamp with time zone, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(timestamp with time zone, text)
is 'format timestamp with time zone to text';

alter function pg_catalog.to_char(timestamp with time zone, text)
  owner to postgres;

create function pg_catalog.numeric_uminus(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_uminus
;

comment on function pg_catalog.numeric_uminus(numeric)
is 'implementation of - operator';

alter function pg_catalog.numeric_uminus(numeric)
  owner to postgres;

create function pg_catalog.to_char(numeric, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(numeric, text)
is 'format numeric to text';

alter function pg_catalog.to_char(numeric, text)
  owner to postgres;

create function pg_catalog.to_char(integer, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(integer, text)
is 'format int4 to text';

alter function pg_catalog.to_char(integer, text)
  owner to postgres;

create function pg_catalog.to_char(bigint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(bigint, text)
is 'format int8 to text';

alter function pg_catalog.to_char(bigint, text)
  owner to postgres;

create function pg_catalog.to_char(real, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(real, text)
is 'format float4 to text';

alter function pg_catalog.to_char(real, text)
  owner to postgres;

create function pg_catalog.to_char(double precision, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(double precision, text)
is 'format float8 to text';

alter function pg_catalog.to_char(double precision, text)
  owner to postgres;

create function pg_catalog.to_number(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_number
;

comment on function pg_catalog.to_number(text, text)
is 'convert text to numeric';

alter function pg_catalog.to_number(text, text)
  owner to postgres;

create function pg_catalog.to_timestamp(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_timestamp
;

comment on function pg_catalog.to_timestamp(text, text)
is 'convert text to timestamp with time zone';

alter function pg_catalog.to_timestamp(text, text)
  owner to postgres;

create function pg_catalog.int8(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(numeric)
is 'convert numeric to int8';

alter function pg_catalog.int8(numeric)
  owner to postgres;

create function pg_catalog.to_date(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_date
;

comment on function pg_catalog.to_date(text, text)
is 'convert text to date';

alter function pg_catalog.to_date(text, text)
  owner to postgres;

create function pg_catalog.numeric(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(bigint)
is 'convert int8 to numeric';

alter function pg_catalog.numeric(bigint)
  owner to postgres;

create function pg_catalog.numeric(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(smallint)
is 'convert int2 to numeric';

alter function pg_catalog.numeric(smallint)
  owner to postgres;

create function pg_catalog.int2(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(numeric)
is 'convert numeric to int2';

alter function pg_catalog.int2(numeric)
  owner to postgres;

create function pg_catalog.oidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidin
;

comment on function pg_catalog.oidin(cstring)
is 'I/O';

alter function pg_catalog.oidin(cstring)
  owner to postgres;

create function pg_catalog.oidout(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidout
;

comment on function pg_catalog.oidout(oid)
is 'I/O';

alter function pg_catalog.oidout(oid)
  owner to postgres;

create function pg_catalog.bit_length(bytea)
  returns integer
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.octet_length($1) * 8
$$;

comment on function pg_catalog.bit_length(bytea)
is 'length in bits';

alter function pg_catalog.bit_length(bytea)
  owner to postgres;

create function pg_catalog.bit_length(text)
  returns integer
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.octet_length($1) * 8
$$;

comment on function pg_catalog.bit_length(text)
is 'length in bits';

alter function pg_catalog.bit_length(text)
  owner to postgres;

create function pg_catalog.bit_length(bit)
  returns integer
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.length($1)
$$;

comment on function pg_catalog.bit_length(bit)
is 'length in bits';

alter function pg_catalog.bit_length(bit)
  owner to postgres;

create function pg_catalog.convert(bytea, name, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.convert
;

comment on function pg_catalog.convert(bytea, name, name)
is 'convert string with specified encoding names';

alter function pg_catalog.convert(bytea, name, name)
  owner to postgres;

create function pg_catalog.iclikesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.iclikesel
;

comment on function pg_catalog.iclikesel(internal, oid, internal, integer)
is 'restriction selectivity of ILIKE';

alter function pg_catalog.iclikesel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.icnlikesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icnlikesel
;

comment on function pg_catalog.icnlikesel(internal, oid, internal, integer)
is 'restriction selectivity of NOT ILIKE';

alter function pg_catalog.icnlikesel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.iclikejoinsel
;

comment on function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of ILIKE';

alter function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icnlikejoinsel
;

comment on function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of NOT ILIKE';

alter function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.regexeqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexeqsel
;

comment on function pg_catalog.regexeqsel(internal, oid, internal, integer)
is 'restriction selectivity of regex match';

alter function pg_catalog.regexeqsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.likesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.likesel
;

comment on function pg_catalog.likesel(internal, oid, internal, integer)
is 'restriction selectivity of LIKE';

alter function pg_catalog.likesel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.icregexeqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexeqsel
;

comment on function pg_catalog.icregexeqsel(internal, oid, internal, integer)
is 'restriction selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.regexnesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexnesel
;

comment on function pg_catalog.regexnesel(internal, oid, internal, integer)
is 'restriction selectivity of regex non-match';

alter function pg_catalog.regexnesel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.nlikesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nlikesel
;

comment on function pg_catalog.nlikesel(internal, oid, internal, integer)
is 'restriction selectivity of NOT LIKE';

alter function pg_catalog.nlikesel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.icregexnesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexnesel
;

comment on function pg_catalog.icregexnesel(internal, oid, internal, integer)
is 'restriction selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnesel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexeqjoinsel
;

comment on function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of regex match';

alter function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.likejoinsel
;

comment on function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of LIKE';

alter function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexeqjoinsel
;

comment on function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexnejoinsel
;

comment on function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of regex non-match';

alter function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nlikejoinsel
;

comment on function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of NOT LIKE';

alter function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexnejoinsel
;

comment on function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.float8_avg(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_avg
;

comment on function pg_catalog.float8_avg(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_avg(double precision [])
  owner to postgres;

create function pg_catalog.float8_var_samp(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_var_samp
;

comment on function pg_catalog.float8_var_samp(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_var_samp(double precision [])
  owner to postgres;

create function pg_catalog.float8_stddev_samp(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_stddev_samp
;

comment on function pg_catalog.float8_stddev_samp(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_stddev_samp(double precision [])
  owner to postgres;

create function pg_catalog.numeric_accum(internal, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_accum
;

comment on function pg_catalog.numeric_accum(internal, numeric)
is 'aggregate transition function';

alter function pg_catalog.numeric_accum(internal, numeric)
  owner to postgres;

create function pg_catalog.int2_accum(internal, smallint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_accum
;

comment on function pg_catalog.int2_accum(internal, smallint)
is 'aggregate transition function';

alter function pg_catalog.int2_accum(internal, smallint)
  owner to postgres;

create function pg_catalog.int4_accum(internal, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_accum
;

comment on function pg_catalog.int4_accum(internal, integer)
is 'aggregate transition function';

alter function pg_catalog.int4_accum(internal, integer)
  owner to postgres;

create function pg_catalog.int8_accum(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_accum
;

comment on function pg_catalog.int8_accum(internal, bigint)
is 'aggregate transition function';

alter function pg_catalog.int8_accum(internal, bigint)
  owner to postgres;

create function pg_catalog.numeric_avg(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg
;

comment on function pg_catalog.numeric_avg(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_avg(internal)
  owner to postgres;

create function pg_catalog.numeric_var_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_var_samp
;

comment on function pg_catalog.numeric_var_samp(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_var_samp(internal)
  owner to postgres;

create function pg_catalog.numeric_stddev_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_stddev_samp
;

comment on function pg_catalog.numeric_stddev_samp(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_stddev_samp(internal)
  owner to postgres;

create function pg_catalog.int2_sum(bigint, smallint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_sum
;

comment on function pg_catalog.int2_sum(bigint, smallint)
is 'aggregate transition function';

alter function pg_catalog.int2_sum(bigint, smallint)
  owner to postgres;

create function pg_catalog.int4_sum(bigint, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_sum
;

comment on function pg_catalog.int4_sum(bigint, integer)
is 'aggregate transition function';

alter function pg_catalog.int4_sum(bigint, integer)
  owner to postgres;

create function pg_catalog.int8_sum(numeric, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_sum
;

comment on function pg_catalog.int8_sum(numeric, bigint)
is 'aggregate transition function';

alter function pg_catalog.int8_sum(numeric, bigint)
  owner to postgres;

create function pg_catalog.interval_accum(interval [], interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_accum
;

comment on function pg_catalog.interval_accum(interval [], interval)
is 'aggregate transition function';

alter function pg_catalog.interval_accum(interval [], interval)
  owner to postgres;

create function pg_catalog.interval_avg(interval [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_avg
;

comment on function pg_catalog.interval_avg(interval [])
is 'aggregate final function';

alter function pg_catalog.interval_avg(interval [])
  owner to postgres;

create function pg_catalog.to_ascii(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_ascii
;

comment on function pg_catalog.to_ascii(text)
is 'encode text from DB encoding to ASCII text';

alter function pg_catalog.to_ascii(text)
  owner to postgres;

create function pg_catalog.to_ascii(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_ascii
;

comment on function pg_catalog.to_ascii(text, integer)
is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii(text, integer)
  owner to postgres;

create function pg_catalog.to_ascii(text, name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_ascii
;

comment on function pg_catalog.to_ascii(text, name)
is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii(text, name)
  owner to postgres;

create function pg_catalog.interval_pl_time(interval, time without time zone)
  returns time without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_time(interval, time)
is 'implementation of + operator';

alter function pg_catalog.interval_pl_time(interval, time)
  owner to postgres;

create function pg_catalog.int28eq(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28eq
;

comment on function pg_catalog.int28eq(smallint, bigint)
is 'implementation of = operator';

alter function pg_catalog.int28eq(smallint, bigint)
  owner to postgres;

create function pg_catalog.int28ne(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28ne
;

comment on function pg_catalog.int28ne(smallint, bigint)
is 'implementation of <> operator';

alter function pg_catalog.int28ne(smallint, bigint)
  owner to postgres;

create function pg_catalog.int28lt(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28lt
;

comment on function pg_catalog.int28lt(smallint, bigint)
is 'implementation of < operator';

alter function pg_catalog.int28lt(smallint, bigint)
  owner to postgres;

create function pg_catalog.int28gt(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28gt
;

comment on function pg_catalog.int28gt(smallint, bigint)
is 'implementation of > operator';

alter function pg_catalog.int28gt(smallint, bigint)
  owner to postgres;

create function pg_catalog.int28le(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28le
;

comment on function pg_catalog.int28le(smallint, bigint)
is 'implementation of <= operator';

alter function pg_catalog.int28le(smallint, bigint)
  owner to postgres;

create function pg_catalog.int28ge(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28ge
;

comment on function pg_catalog.int28ge(smallint, bigint)
is 'implementation of >= operator';

alter function pg_catalog.int28ge(smallint, bigint)
  owner to postgres;

create function pg_catalog.int82eq(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82eq
;

comment on function pg_catalog.int82eq(bigint, smallint)
is 'implementation of = operator';

alter function pg_catalog.int82eq(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82ne(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82ne
;

comment on function pg_catalog.int82ne(bigint, smallint)
is 'implementation of <> operator';

alter function pg_catalog.int82ne(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82lt(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82lt
;

comment on function pg_catalog.int82lt(bigint, smallint)
is 'implementation of < operator';

alter function pg_catalog.int82lt(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82gt(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82gt
;

comment on function pg_catalog.int82gt(bigint, smallint)
is 'implementation of > operator';

alter function pg_catalog.int82gt(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82le(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82le
;

comment on function pg_catalog.int82le(bigint, smallint)
is 'implementation of <= operator';

alter function pg_catalog.int82le(bigint, smallint)
  owner to postgres;

create function pg_catalog.int82ge(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82ge
;

comment on function pg_catalog.int82ge(bigint, smallint)
is 'implementation of >= operator';

alter function pg_catalog.int82ge(bigint, smallint)
  owner to postgres;

create function pg_catalog.int2and(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2and
;

comment on function pg_catalog.int2and(smallint, smallint)
is 'implementation of & operator';

alter function pg_catalog.int2and(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2or(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2or
;

comment on function pg_catalog.int2or(smallint, smallint)
is 'implementation of | operator';

alter function pg_catalog.int2or(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2xor(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2xor
;

comment on function pg_catalog.int2xor(smallint, smallint)
is 'implementation of # operator';

alter function pg_catalog.int2xor(smallint, smallint)
  owner to postgres;

create function pg_catalog.int2not(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2not
;

comment on function pg_catalog.int2not(smallint)
is 'implementation of ~ operator';

alter function pg_catalog.int2not(smallint)
  owner to postgres;

create function pg_catalog.int2shl(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2shl
;

comment on function pg_catalog.int2shl(smallint, integer)
is 'implementation of << operator';

alter function pg_catalog.int2shl(smallint, integer)
  owner to postgres;

create function pg_catalog.int2shr(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2shr
;

comment on function pg_catalog.int2shr(smallint, integer)
is 'implementation of >> operator';

alter function pg_catalog.int2shr(smallint, integer)
  owner to postgres;

create function pg_catalog.int4and(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4and
;

comment on function pg_catalog.int4and(integer, integer)
is 'implementation of & operator';

alter function pg_catalog.int4and(integer, integer)
  owner to postgres;

create function pg_catalog.int4or(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4or
;

comment on function pg_catalog.int4or(integer, integer)
is 'implementation of | operator';

alter function pg_catalog.int4or(integer, integer)
  owner to postgres;

create function pg_catalog.int4xor(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4xor
;

comment on function pg_catalog.int4xor(integer, integer)
is 'implementation of # operator';

alter function pg_catalog.int4xor(integer, integer)
  owner to postgres;

create function pg_catalog.int4not(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4not
;

comment on function pg_catalog.int4not(integer)
is 'implementation of ~ operator';

alter function pg_catalog.int4not(integer)
  owner to postgres;

create function pg_catalog.int4shl(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4shl
;

comment on function pg_catalog.int4shl(integer, integer)
is 'implementation of << operator';

alter function pg_catalog.int4shl(integer, integer)
  owner to postgres;

create function pg_catalog.int4shr(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4shr
;

comment on function pg_catalog.int4shr(integer, integer)
is 'implementation of >> operator';

alter function pg_catalog.int4shr(integer, integer)
  owner to postgres;

create function pg_catalog.int8and(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8and
;

comment on function pg_catalog.int8and(bigint, bigint)
is 'implementation of & operator';

alter function pg_catalog.int8and(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8or(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8or
;

comment on function pg_catalog.int8or(bigint, bigint)
is 'implementation of | operator';

alter function pg_catalog.int8or(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8xor(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8xor
;

comment on function pg_catalog.int8xor(bigint, bigint)
is 'implementation of # operator';

alter function pg_catalog.int8xor(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8not(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8not
;

comment on function pg_catalog.int8not(bigint)
is 'implementation of ~ operator';

alter function pg_catalog.int8not(bigint)
  owner to postgres;

create function pg_catalog.int8shl(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8shl
;

comment on function pg_catalog.int8shl(bigint, integer)
is 'implementation of << operator';

alter function pg_catalog.int8shl(bigint, integer)
  owner to postgres;

create function pg_catalog.int8shr(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8shr
;

comment on function pg_catalog.int8shr(bigint, integer)
is 'implementation of >> operator';

alter function pg_catalog.int8shr(bigint, integer)
  owner to postgres;

create function pg_catalog.int8up(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8up
;

comment on function pg_catalog.int8up(bigint)
is 'implementation of + operator';

alter function pg_catalog.int8up(bigint)
  owner to postgres;

create function pg_catalog.int2up(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2up
;

comment on function pg_catalog.int2up(smallint)
is 'implementation of + operator';

alter function pg_catalog.int2up(smallint)
  owner to postgres;

create function pg_catalog.int4up(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4up
;

comment on function pg_catalog.int4up(integer)
is 'implementation of + operator';

alter function pg_catalog.int4up(integer)
  owner to postgres;

create function pg_catalog.float4up(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4up
;

comment on function pg_catalog.float4up(real)
is 'implementation of + operator';

alter function pg_catalog.float4up(real)
  owner to postgres;

create function pg_catalog.float8up(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8up
;

comment on function pg_catalog.float8up(double precision)
is 'implementation of + operator';

alter function pg_catalog.float8up(double precision)
  owner to postgres;

create function pg_catalog.numeric_uplus(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_uplus
;

comment on function pg_catalog.numeric_uplus(numeric)
is 'implementation of + operator';

alter function pg_catalog.numeric_uplus(numeric)
  owner to postgres;

create function pg_catalog.has_table_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(name, text, text)
is 'user privilege on relation by username, rel name';

alter function pg_catalog.has_table_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_table_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(name, oid, text)
is 'user privilege on relation by username, rel oid';

alter function pg_catalog.has_table_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_table_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(oid, text, text)
is 'user privilege on relation by user oid, rel name';

alter function pg_catalog.has_table_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_table_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(oid, oid, text)
is 'user privilege on relation by user oid, rel oid';

alter function pg_catalog.has_table_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_table_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(text, text)
is 'current user privilege on relation by rel name';

alter function pg_catalog.has_table_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_table_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(oid, text)
is 'current user privilege on relation by rel oid';

alter function pg_catalog.has_table_privilege(oid, text)
  owner to postgres;

create function pg_catalog.pg_stat_get_numscans(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_numscans
;

comment on function pg_catalog.pg_stat_get_numscans(oid)
is 'statistics: number of scans done for table/index';

alter function pg_catalog.pg_stat_get_numscans(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_tuples_returned(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_returned
;

comment on function pg_catalog.pg_stat_get_tuples_returned(oid)
is 'statistics: number of tuples read by seqscan';

alter function pg_catalog.pg_stat_get_tuples_returned(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_tuples_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_fetched
;

comment on function pg_catalog.pg_stat_get_tuples_fetched(oid)
is 'statistics: number of tuples fetched by idxscan';

alter function pg_catalog.pg_stat_get_tuples_fetched(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_tuples_inserted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_inserted
;

comment on function pg_catalog.pg_stat_get_tuples_inserted(oid)
is 'statistics: number of tuples inserted';

alter function pg_catalog.pg_stat_get_tuples_inserted(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_tuples_updated(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_updated
;

comment on function pg_catalog.pg_stat_get_tuples_updated(oid)
is 'statistics: number of tuples updated';

alter function pg_catalog.pg_stat_get_tuples_updated(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_tuples_deleted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_deleted
;

comment on function pg_catalog.pg_stat_get_tuples_deleted(oid)
is 'statistics: number of tuples deleted';

alter function pg_catalog.pg_stat_get_tuples_deleted(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_blocks_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_blocks_fetched
;

comment on function pg_catalog.pg_stat_get_blocks_fetched(oid)
is 'statistics: number of blocks fetched';

alter function pg_catalog.pg_stat_get_blocks_fetched(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_blocks_hit(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_blocks_hit
;

comment on function pg_catalog.pg_stat_get_blocks_hit(oid)
is 'statistics: number of blocks found in cache';

alter function pg_catalog.pg_stat_get_blocks_hit(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_idset()
stable
strict
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_idset
;

comment on function pg_catalog.pg_stat_get_backend_idset()
is 'statistics: currently active backend IDs';

alter function pg_catalog.pg_stat_get_backend_idset()
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_pid(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_pid
;

comment on function pg_catalog.pg_stat_get_backend_pid(integer)
is 'statistics: PID of backend';

alter function pg_catalog.pg_stat_get_backend_pid(integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_dbid(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_dbid
;

comment on function pg_catalog.pg_stat_get_backend_dbid(integer)
is 'statistics: database ID of backend';

alter function pg_catalog.pg_stat_get_backend_dbid(integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_userid(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_userid
;

comment on function pg_catalog.pg_stat_get_backend_userid(integer)
is 'statistics: user ID of backend';

alter function pg_catalog.pg_stat_get_backend_userid(integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_activity(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_activity
;

comment on function pg_catalog.pg_stat_get_backend_activity(integer)
is 'statistics: current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity(integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_numbackends(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_numbackends
;

comment on function pg_catalog.pg_stat_get_db_numbackends(oid)
is 'statistics: number of backends in database';

alter function pg_catalog.pg_stat_get_db_numbackends(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_xact_commit(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_xact_commit
;

comment on function pg_catalog.pg_stat_get_db_xact_commit(oid)
is 'statistics: transactions committed';

alter function pg_catalog.pg_stat_get_db_xact_commit(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_xact_rollback(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_xact_rollback
;

comment on function pg_catalog.pg_stat_get_db_xact_rollback(oid)
is 'statistics: transactions rolled back';

alter function pg_catalog.pg_stat_get_db_xact_rollback(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_blocks_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blocks_fetched
;

comment on function pg_catalog.pg_stat_get_db_blocks_fetched(oid)
is 'statistics: blocks fetched for database';

alter function pg_catalog.pg_stat_get_db_blocks_fetched(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_blocks_hit(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blocks_hit
;

comment on function pg_catalog.pg_stat_get_db_blocks_hit(oid)
is 'statistics: blocks found in cache for database';

alter function pg_catalog.pg_stat_get_db_blocks_hit(oid)
  owner to postgres;

create function pg_catalog.encode(bytea, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.encode
;

comment on function pg_catalog.encode(bytea, text)
is 'convert bytea value into some ascii-only text string';

alter function pg_catalog.encode(bytea, text)
  owner to postgres;

create function pg_catalog.decode(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.decode
;

comment on function pg_catalog.decode(text, text)
is 'convert ascii-encoded text string into bytea value';

alter function pg_catalog.decode(text, text)
  owner to postgres;

create function pg_catalog.byteaeq(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteaeq
;

comment on function pg_catalog.byteaeq(bytea, bytea)
is 'implementation of = operator';

alter function pg_catalog.byteaeq(bytea, bytea)
  owner to postgres;

create function pg_catalog.bytealt(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytealt
;

comment on function pg_catalog.bytealt(bytea, bytea)
is 'implementation of < operator';

alter function pg_catalog.bytealt(bytea, bytea)
  owner to postgres;

create function pg_catalog.byteale(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteale
;

comment on function pg_catalog.byteale(bytea, bytea)
is 'implementation of <= operator';

alter function pg_catalog.byteale(bytea, bytea)
  owner to postgres;

create function pg_catalog.byteagt(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteagt
;

comment on function pg_catalog.byteagt(bytea, bytea)
is 'implementation of > operator';

alter function pg_catalog.byteagt(bytea, bytea)
  owner to postgres;

create function pg_catalog.byteage(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteage
;

comment on function pg_catalog.byteage(bytea, bytea)
is 'implementation of >= operator';

alter function pg_catalog.byteage(bytea, bytea)
  owner to postgres;

create function pg_catalog.byteane(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteane
;

comment on function pg_catalog.byteane(bytea, bytea)
is 'implementation of <> operator';

alter function pg_catalog.byteane(bytea, bytea)
  owner to postgres;

create function pg_catalog.byteacmp(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteacmp
;

comment on function pg_catalog.byteacmp(bytea, bytea)
is 'less-equal-greater';

alter function pg_catalog.byteacmp(bytea, bytea)
  owner to postgres;

create function pg_catalog.timestamp(timestamp, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(timestamp, integer)
is 'adjust timestamp precision';

alter function pg_catalog.timestamp(timestamp, integer)
  owner to postgres;

create function pg_catalog.int2_avg_accum(bigint [], smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_avg_accum
;

comment on function pg_catalog.int2_avg_accum(bigint [], smallint)
is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum(bigint [], smallint)
  owner to postgres;

create function pg_catalog.int4_avg_accum(bigint [], integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_avg_accum
;

comment on function pg_catalog.int4_avg_accum(bigint [], integer)
is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum(bigint [], integer)
  owner to postgres;

create function pg_catalog.int8_avg(bigint [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg
;

comment on function pg_catalog.int8_avg(bigint [])
is 'aggregate final function';

alter function pg_catalog.int8_avg(bigint [])
  owner to postgres;

create function pg_catalog.oidlarger(oid, oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidlarger
;

comment on function pg_catalog.oidlarger(oid, oid)
is 'larger of two';

alter function pg_catalog.oidlarger(oid, oid)
  owner to postgres;

create function pg_catalog.oidsmaller(oid, oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidsmaller
;

comment on function pg_catalog.oidsmaller(oid, oid)
is 'smaller of two';

alter function pg_catalog.oidsmaller(oid, oid)
  owner to postgres;

create function pg_catalog.timestamptz(timestamp with time zone, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(timestamp with time zone, integer)
is 'adjust timestamptz precision';

alter function pg_catalog.timestamptz(timestamp with time zone, integer)
  owner to postgres;

create function pg_catalog.time(time, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(time, integer)
is 'adjust time precision';

alter function pg_catalog.time(time, integer)
  owner to postgres;

create function pg_catalog.timetz(time with time zone, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz
;

comment on function pg_catalog.timetz(time with time zone, integer)
is 'adjust time with time zone precision';

alter function pg_catalog.timetz(time with time zone, integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_tuples_hot_updated(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_hot_updated
;

comment on function pg_catalog.pg_stat_get_tuples_hot_updated(oid)
is 'statistics: number of tuples hot updated';

alter function pg_catalog.pg_stat_get_tuples_hot_updated(oid)
  owner to postgres;

create function pg_catalog.div(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.div
;

comment on function pg_catalog.div(numeric, numeric)
is 'trunc(x/y)';

alter function pg_catalog.div(numeric, numeric)
  owner to postgres;

create function pg_catalog.numeric_div_trunc(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_div_trunc
;

comment on function pg_catalog.numeric_div_trunc(numeric, numeric)
is 'trunc(x/y)';

alter function pg_catalog.numeric_div_trunc(numeric, numeric)
  owner to postgres;

create function pg_catalog.shobj_description(oid, name)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_shdescription
where objoid = $1
  and classoid = (select oid
                  from pg_catalog.pg_class
                  where relname = $2
                    and relnamespace = 11)
$$;

comment on function pg_catalog.shobj_description(oid, name)
is 'get description for object id and shared catalog name';

alter function pg_catalog.shobj_description(oid, name)
  owner to postgres;

create function pg_catalog.textanycat(text, anynonarray)
  returns text
stable
strict
parallel safe
cost 1
language sql
as $$
select $1 || $2 :: pg_catalog.text
$$;

comment on function pg_catalog.textanycat(text, anynonarray)
is 'implementation of || operator';

alter function pg_catalog.textanycat(text, anynonarray)
  owner to postgres;

create function pg_catalog.anytextcat(anynonarray, text)
  returns text
stable
strict
parallel safe
cost 1
language sql
as $$
select $1 :: pg_catalog.text || $2
$$;

comment on function pg_catalog.anytextcat(anynonarray, text)
is 'implementation of || operator';

alter function pg_catalog.anytextcat(anynonarray, text)
  owner to postgres;

create function pg_catalog.bytealike(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytealike
;

comment on function pg_catalog.bytealike(bytea, bytea)
is 'implementation of ~~ operator';

alter function pg_catalog.bytealike(bytea, bytea)
  owner to postgres;

create function pg_catalog.byteanlike(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteanlike
;

comment on function pg_catalog.byteanlike(bytea, bytea)
is 'implementation of !~~ operator';

alter function pg_catalog.byteanlike(bytea, bytea)
  owner to postgres;

create function pg_catalog."like"(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."like"
;

comment on function pg_catalog."like"(bytea, bytea)
is 'matches LIKE expression';

alter function pg_catalog."like"(bytea, bytea)
  owner to postgres;

create function pg_catalog.notlike(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.notlike
;

comment on function pg_catalog.notlike(bytea, bytea)
is 'does not match LIKE expression';

alter function pg_catalog.notlike(bytea, bytea)
  owner to postgres;

create function pg_catalog.like_escape(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.like_escape
;

comment on function pg_catalog.like_escape(bytea, bytea)
is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(bytea, bytea)
  owner to postgres;

create function pg_catalog.length(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(bytea)
is 'octet length';

alter function pg_catalog.length(bytea)
  owner to postgres;

create function pg_catalog.byteacat(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteacat
;

comment on function pg_catalog.byteacat(bytea, bytea)
is 'implementation of || operator';

alter function pg_catalog.byteacat(bytea, bytea)
  owner to postgres;

create function pg_catalog.substring(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bytea, integer, integer)
is 'extract portion of string';

alter function pg_catalog.substring(bytea, integer, integer)
  owner to postgres;

create function pg_catalog.substring(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bytea, integer)
is 'extract portion of string';

alter function pg_catalog.substring(bytea, integer)
  owner to postgres;

create function pg_catalog.position(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.position
;

comment on function pg_catalog.position(bytea, bytea)
is 'position of substring';

alter function pg_catalog.position(bytea, bytea)
  owner to postgres;

create function pg_catalog.btrim(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrim
;

comment on function pg_catalog.btrim(bytea, bytea)
is 'trim both ends of string';

alter function pg_catalog.btrim(bytea, bytea)
  owner to postgres;

create function pg_catalog.time(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(timestamp with time zone)
is 'convert timestamp with time zone to time';

alter function pg_catalog.time(timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_trunc(text, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_trunc
;

comment on function pg_catalog.date_trunc(text, timestamp)
is 'truncate timestamp to specified units';

alter function pg_catalog.date_trunc(text, timestamp)
  owner to postgres;

create function pg_catalog.date_part(text, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, timestamp)
is 'extract field from timestamp';

alter function pg_catalog.date_part(text, timestamp)
  owner to postgres;

create function pg_catalog.pg_stat_get_activity(pid integer, out datid oid, out pid integer, out usesysid oid,
                                                             out application_name text, out state text, out query text,
                                                             out wait_event_type text, out wait_event text,
                                                             out xact_start timestamp with time zone,
                                                             out query_start timestamp with time zone,
                                                             out backend_start timestamp with time zone,
                                                             out state_change timestamp with time zone,
                                                             out client_addr inet, out client_hostname text,
                                                             out client_port integer, out backend_xid xid,
                                                             out backend_xmin xid, out backend_type text,
                                                             out ssl boolean, out sslversion text, out sslcipher text,
                                                             out sslbits integer, out sslcompression boolean,
                                                             out sslclientdn text)
stable
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_stat_get_activity
;

comment on function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text,
                                                             out text, out text, out text, out timestamp with time zone,
                                                             out timestamp with time zone, out timestamp with time zone,
                                                             out timestamp with time zone, out inet, out text,
                                                             out integer, out xid, out xid, out text, out boolean,
                                                             out text, out text, out integer, out boolean, out text)
is 'statistics: information about currently active backends';

alter function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text, out text, out text, out text, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out inet, out text, out integer, out xid, out xid, out text, out boolean, out text, out text, out integer, out boolean, out text)
  owner to postgres;

create function pg_catalog.timestamp(abstime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(abstime)
is 'convert abstime to timestamp';

alter function pg_catalog.timestamp(abstime)
  owner to postgres;

create function pg_catalog.timestamp(date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(date)
is 'convert date to timestamp';

alter function pg_catalog.timestamp(date)
  owner to postgres;

create function pg_catalog.timestamp(date, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(date, time)
is 'convert date and time to timestamp';

alter function pg_catalog.timestamp(date, time)
  owner to postgres;

create function pg_catalog.pg_backend_pid()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_backend_pid
;

comment on function pg_catalog.pg_backend_pid()
is 'statistics: current backend PID';

alter function pg_catalog.pg_backend_pid()
  owner to postgres;

create function pg_catalog.timestamp(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(timestamp with time zone)
is 'convert timestamp with time zone to timestamp';

alter function pg_catalog.timestamp(timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz(timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(timestamp)
is 'convert timestamp to timestamp with time zone';

alter function pg_catalog.timestamptz(timestamp)
  owner to postgres;

create function pg_catalog.date(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date
;

comment on function pg_catalog.date(timestamp)
is 'convert timestamp to date';

alter function pg_catalog.date(timestamp)
  owner to postgres;

create function pg_catalog.abstime(timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstime
;

comment on function pg_catalog.abstime(timestamp)
is 'convert timestamp to abstime';

alter function pg_catalog.abstime(timestamp)
  owner to postgres;

create function pg_catalog.timestamp_mi(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_mi
;

comment on function pg_catalog.timestamp_mi(timestamp, timestamp)
is 'implementation of - operator';

alter function pg_catalog.timestamp_mi(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_pl_interval(timestamp, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_pl_interval
;

comment on function pg_catalog.timestamp_pl_interval(timestamp, interval)
is 'implementation of + operator';

alter function pg_catalog.timestamp_pl_interval(timestamp, interval)
  owner to postgres;

create function pg_catalog.timestamp_mi_interval(timestamp, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_mi_interval
;

comment on function pg_catalog.timestamp_mi_interval(timestamp, interval)
is 'implementation of - operator';

alter function pg_catalog.timestamp_mi_interval(timestamp, interval)
  owner to postgres;

create function pg_catalog.pg_conf_load_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_conf_load_time
;

comment on function pg_catalog.pg_conf_load_time()
is 'configuration load time';

alter function pg_catalog.pg_conf_load_time()
  owner to postgres;

create function pg_catalog.timestamp_smaller(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_smaller
;

comment on function pg_catalog.timestamp_smaller(timestamp, timestamp)
is 'smaller of two';

alter function pg_catalog.timestamp_smaller(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_larger(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_larger
;

comment on function pg_catalog.timestamp_larger(timestamp, timestamp)
is 'larger of two';

alter function pg_catalog.timestamp_larger(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timezone(text, time with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(text, time with time zone)
is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(text, time with time zone)
  owner to postgres;

create function pg_catalog.timezone(interval, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(interval, time with time zone)
is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(interval, time with time zone)
  owner to postgres;

create function pg_catalog.timestamp_hash(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_hash
;

comment on function pg_catalog.timestamp_hash(timestamp)
is 'hash';

alter function pg_catalog.timestamp_hash(timestamp)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, interval)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, interval, timestamp, interval)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone,
                                      timestamp without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval)
  owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone,
                                      timestamp without time zone)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp)
is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_cmp(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_cmp
;

comment on function pg_catalog.timestamp_cmp(timestamp, timestamp)
is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.time(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(time with time zone)
is 'convert time with time zone to time';

alter function pg_catalog.time(time with time zone)
  owner to postgres;

create function pg_catalog.timetz(time)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz
;

comment on function pg_catalog.timetz(time)
is 'convert time to time with time zone';

alter function pg_catalog.timetz(time)
  owner to postgres;

create function pg_catalog.isfinite(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(timestamp)
is 'finite timestamp?';

alter function pg_catalog.isfinite(timestamp)
  owner to postgres;

create function pg_catalog.to_char(timestamp, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(timestamp, text)
is 'format timestamp to text';

alter function pg_catalog.to_char(timestamp, text)
  owner to postgres;

create function pg_catalog.timestamp_eq(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_eq
;

comment on function pg_catalog.timestamp_eq(timestamp, timestamp)
is 'implementation of = operator';

alter function pg_catalog.timestamp_eq(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_ne(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ne
;

comment on function pg_catalog.timestamp_ne(timestamp, timestamp)
is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_lt(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_lt
;

comment on function pg_catalog.timestamp_lt(timestamp, timestamp)
is 'implementation of < operator';

alter function pg_catalog.timestamp_lt(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_le(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_le
;

comment on function pg_catalog.timestamp_le(timestamp, timestamp)
is 'implementation of <= operator';

alter function pg_catalog.timestamp_le(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_ge(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ge
;

comment on function pg_catalog.timestamp_ge(timestamp, timestamp)
is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.timestamp_gt(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_gt
;

comment on function pg_catalog.timestamp_gt(timestamp, timestamp)
is 'implementation of > operator';

alter function pg_catalog.timestamp_gt(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.age(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.age
;

comment on function pg_catalog.age(timestamp, timestamp)
is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.age(timestamp without time zone)
  returns interval
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.age(cast(current_date as timestamp without time zone), $1)
$$;

comment on function pg_catalog.age(timestamp)
is 'date difference from today preserving months and years';

alter function pg_catalog.age(timestamp)
  owner to postgres;

create function pg_catalog.timezone(text, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(text, timestamp)
is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(text, timestamp)
  owner to postgres;

create function pg_catalog.timezone(interval, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(interval, timestamp)
is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval, timestamp)
  owner to postgres;

create function pg_catalog.date_pl_interval(date, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_pl_interval
;

comment on function pg_catalog.date_pl_interval(date, interval)
is 'implementation of + operator';

alter function pg_catalog.date_pl_interval(date, interval)
  owner to postgres;

create function pg_catalog.date_mi_interval(date, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_mi_interval
;

comment on function pg_catalog.date_mi_interval(date, interval)
is 'implementation of - operator';

alter function pg_catalog.date_mi_interval(date, interval)
  owner to postgres;

create function pg_catalog.substring(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(text, text)
is 'extract text matching regular expression';

alter function pg_catalog.substring(text, text)
  owner to postgres;

create function pg_catalog.substring(text, text, text)
  returns text
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.substring($1, pg_catalog.similar_escape($2, $3))
$$;

comment on function pg_catalog.substring(text, text, text)
is 'extract text matching SQL99 regular expression';

alter function pg_catalog.substring(text, text, text)
  owner to postgres;

create function pg_catalog.bit(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit
;

comment on function pg_catalog.bit(bigint, integer)
is 'convert int8 to bitstring';

alter function pg_catalog.bit(bigint, integer)
  owner to postgres;

create function pg_catalog.int8(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(bit)
is 'convert bitstring to int8';

alter function pg_catalog.int8(bit)
  owner to postgres;

create function pg_catalog.current_setting(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_setting
;

comment on function pg_catalog.current_setting(text)
is 'SHOW X as a function';

alter function pg_catalog.current_setting(text)
  owner to postgres;

create function pg_catalog.set_config(text, text, boolean)
cost 1
language internal
as
-- missing source code for pg_catalog.set_config
;

comment on function pg_catalog.set_config(text, text, boolean)
is 'SET X as a function';

alter function pg_catalog.set_config(text, text, boolean)
  owner to postgres;

create function pg_catalog.pg_table_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_table_is_visible
;

comment on function pg_catalog.pg_table_is_visible(oid)
is 'is table visible in search path?';

alter function pg_catalog.pg_table_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_type_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_type_is_visible
;

comment on function pg_catalog.pg_type_is_visible(oid)
is 'is type visible in search path?';

alter function pg_catalog.pg_type_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_function_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_function_is_visible
;

comment on function pg_catalog.pg_function_is_visible(oid)
is 'is function visible in search path?';

alter function pg_catalog.pg_function_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_operator_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_operator_is_visible
;

comment on function pg_catalog.pg_operator_is_visible(oid)
is 'is operator visible in search path?';

alter function pg_catalog.pg_operator_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_opclass_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_opclass_is_visible
;

comment on function pg_catalog.pg_opclass_is_visible(oid)
is 'is opclass visible in search path?';

alter function pg_catalog.pg_opclass_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_show_all_settings(out name            text, out setting text, out unit text,
                                                out category        text, out short_desc text, out extra_desc text,
                                                out context         text, out vartype text, out source text,
                                                out min_val         text, out max_val text, out enumvals text [],
                                                out boot_val        text, out reset_val text, out sourcefile text,
                                                out sourceline      integer, out pending_restart boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_show_all_settings
;

comment on function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text,
                                                    out text, out text, out text, out text, out text, out text [],
                                                    out text, out text, out text, out integer, out boolean)
is 'SHOW ALL as a function';

alter function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text [], out text, out text, out text, out integer, out boolean)
  owner to postgres;

create function pg_catalog.substr(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(bytea, integer, integer)
is 'extract portion of string';

alter function pg_catalog.substr(bytea, integer, integer)
  owner to postgres;

create function pg_catalog.substr(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(bytea, integer)
is 'extract portion of string';

alter function pg_catalog.substr(bytea, integer)
  owner to postgres;

create function pg_catalog.replace(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.replace
;

comment on function pg_catalog.replace(text, text, text)
is 'replace all occurrences in string of old_substr with new_substr';

alter function pg_catalog.replace(text, text, text)
  owner to postgres;

create function pg_catalog.split_part(text, text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.split_part
;

comment on function pg_catalog.split_part(text, text, integer)
is 'split string by field_sep and return field_num';

alter function pg_catalog.split_part(text, text, integer)
  owner to postgres;

create function pg_catalog.to_hex(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_hex
;

comment on function pg_catalog.to_hex(integer)
is 'convert int4 number to hex';

alter function pg_catalog.to_hex(integer)
  owner to postgres;

create function pg_catalog.to_hex(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_hex
;

comment on function pg_catalog.to_hex(bigint)
is 'convert int8 number to hex';

alter function pg_catalog.to_hex(bigint)
  owner to postgres;

create function pg_catalog.array_lower(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_lower
;

comment on function pg_catalog.array_lower(anyarray, integer)
is 'array lower dimension';

alter function pg_catalog.array_lower(anyarray, integer)
  owner to postgres;

create function pg_catalog.array_upper(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_upper
;

comment on function pg_catalog.array_upper(anyarray, integer)
is 'array upper dimension';

alter function pg_catalog.array_upper(anyarray, integer)
  owner to postgres;

create function pg_catalog.pg_conversion_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_conversion_is_visible
;

comment on function pg_catalog.pg_conversion_is_visible(oid)
is 'is conversion visible in search path?';

alter function pg_catalog.pg_conversion_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_activity_start(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_activity_start
;

comment on function pg_catalog.pg_stat_get_backend_activity_start(integer)
is 'statistics: start time for current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity_start(integer)
  owner to postgres;

create function pg_catalog.pg_terminate_backend(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_terminate_backend
;

comment on function pg_catalog.pg_terminate_backend(integer)
is 'terminate a server process';

alter function pg_catalog.pg_terminate_backend(integer)
  owner to postgres;

create function pg_catalog.pg_get_functiondef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_functiondef
;

comment on function pg_catalog.pg_get_functiondef(oid)
is 'definition of a function';

alter function pg_catalog.pg_get_functiondef(oid)
  owner to postgres;

create function pg_catalog.text_pattern_lt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_lt
;

comment on function pg_catalog.text_pattern_lt(text, text)
is 'implementation of ~<~ operator';

alter function pg_catalog.text_pattern_lt(text, text)
  owner to postgres;

create function pg_catalog.text_pattern_le(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_le
;

comment on function pg_catalog.text_pattern_le(text, text)
is 'implementation of ~<=~ operator';

alter function pg_catalog.text_pattern_le(text, text)
  owner to postgres;

create function pg_catalog.pg_get_function_arguments(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_arguments
;

comment on function pg_catalog.pg_get_function_arguments(oid)
is 'argument list of a function';

alter function pg_catalog.pg_get_function_arguments(oid)
  owner to postgres;

create function pg_catalog.text_pattern_ge(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_ge
;

comment on function pg_catalog.text_pattern_ge(text, text)
is 'implementation of ~>=~ operator';

alter function pg_catalog.text_pattern_ge(text, text)
  owner to postgres;

create function pg_catalog.text_pattern_gt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_gt
;

comment on function pg_catalog.text_pattern_gt(text, text)
is 'implementation of ~>~ operator';

alter function pg_catalog.text_pattern_gt(text, text)
  owner to postgres;

create function pg_catalog.pg_get_function_result(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_result
;

comment on function pg_catalog.pg_get_function_result(oid)
is 'result type of a function';

alter function pg_catalog.pg_get_function_result(oid)
  owner to postgres;

create function pg_catalog.bttext_pattern_cmp(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttext_pattern_cmp
;

comment on function pg_catalog.bttext_pattern_cmp(text, text)
is 'less-equal-greater';

alter function pg_catalog.bttext_pattern_cmp(text, text)
  owner to postgres;

create function pg_catalog.ceiling(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceiling
;

comment on function pg_catalog.ceiling(numeric)
is 'nearest integer >= value';

alter function pg_catalog.ceiling(numeric)
  owner to postgres;

create function pg_catalog.pg_database_size(name)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_database_size
;

comment on function pg_catalog.pg_database_size(name)
is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(name)
  owner to postgres;

create function pg_catalog.power(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.power
;

comment on function pg_catalog.power(numeric, numeric)
is 'exponentiation';

alter function pg_catalog.power(numeric, numeric)
  owner to postgres;

create function pg_catalog.width_bucket(numeric, numeric, numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width_bucket
;

comment on function pg_catalog.width_bucket(numeric, numeric, numeric, integer)
is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket(numeric, numeric, numeric, integer)
  owner to postgres;

create function pg_catalog.pg_cancel_backend(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_cancel_backend
;

comment on function pg_catalog.pg_cancel_backend(integer)
is 'cancel a server process'' current query';

alter function pg_catalog.pg_cancel_backend(integer)
  owner to postgres;

create function pg_catalog.pg_start_backup(label text, fast boolean default false, exclusive boolean default true)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_start_backup
;

comment on function pg_catalog.pg_start_backup(text, boolean, boolean)
is 'prepare for taking an online backup';

alter function pg_catalog.pg_start_backup(text, boolean, boolean)
  owner to postgres;

create function pg_catalog.pg_stop_backup()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stop_backup
;

comment on function pg_catalog.pg_stop_backup()
is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup()
  owner to postgres;

create function pg_catalog.bpchar_pattern_lt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_lt
;

comment on function pg_catalog.bpchar_pattern_lt(char, char)
is 'implementation of ~<~ operator';

alter function pg_catalog.bpchar_pattern_lt(char, char)
  owner to postgres;

create function pg_catalog.bpchar_pattern_le(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_le
;

comment on function pg_catalog.bpchar_pattern_le(char, char)
is 'implementation of ~<=~ operator';

alter function pg_catalog.bpchar_pattern_le(char, char)
  owner to postgres;

create function pg_catalog.array_length(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_length
;

comment on function pg_catalog.array_length(anyarray, integer)
is 'array length';

alter function pg_catalog.array_length(anyarray, integer)
  owner to postgres;

create function pg_catalog.bpchar_pattern_ge(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_ge
;

comment on function pg_catalog.bpchar_pattern_ge(char, char)
is 'implementation of ~>=~ operator';

alter function pg_catalog.bpchar_pattern_ge(char, char)
  owner to postgres;

create function pg_catalog.bpchar_pattern_gt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_gt
;

comment on function pg_catalog.bpchar_pattern_gt(char, char)
is 'implementation of ~>~ operator';

alter function pg_catalog.bpchar_pattern_gt(char, char)
  owner to postgres;

create function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_consistent
;

comment on function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.btbpchar_pattern_cmp(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btbpchar_pattern_cmp
;

comment on function pg_catalog.btbpchar_pattern_cmp(char, char)
is 'less-equal-greater';

alter function pg_catalog.btbpchar_pattern_cmp(char, char)
  owner to postgres;

create function pg_catalog.has_sequence_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(name, text, text)
is 'user privilege on sequence by username, seq name';

alter function pg_catalog.has_sequence_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_sequence_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(name, oid, text)
is 'user privilege on sequence by username, seq oid';

alter function pg_catalog.has_sequence_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_sequence_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(oid, text, text)
is 'user privilege on sequence by user oid, seq name';

alter function pg_catalog.has_sequence_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_sequence_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(oid, oid, text)
is 'user privilege on sequence by user oid, seq oid';

alter function pg_catalog.has_sequence_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_sequence_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(text, text)
is 'current user privilege on sequence by seq name';

alter function pg_catalog.has_sequence_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_sequence_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(oid, text)
is 'current user privilege on sequence by seq oid';

alter function pg_catalog.has_sequence_privilege(oid, text)
  owner to postgres;

create function pg_catalog.btint48cmp(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint48cmp
;

comment on function pg_catalog.btint48cmp(integer, bigint)
is 'less-equal-greater';

alter function pg_catalog.btint48cmp(integer, bigint)
  owner to postgres;

create function pg_catalog.btint84cmp(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint84cmp
;

comment on function pg_catalog.btint84cmp(bigint, integer)
is 'less-equal-greater';

alter function pg_catalog.btint84cmp(bigint, integer)
  owner to postgres;

create function pg_catalog.btint24cmp(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint24cmp
;

comment on function pg_catalog.btint24cmp(smallint, integer)
is 'less-equal-greater';

alter function pg_catalog.btint24cmp(smallint, integer)
  owner to postgres;

create function pg_catalog.btint42cmp(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint42cmp
;

comment on function pg_catalog.btint42cmp(integer, smallint)
is 'less-equal-greater';

alter function pg_catalog.btint42cmp(integer, smallint)
  owner to postgres;

create function pg_catalog.btint28cmp(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint28cmp
;

comment on function pg_catalog.btint28cmp(smallint, bigint)
is 'less-equal-greater';

alter function pg_catalog.btint28cmp(smallint, bigint)
  owner to postgres;

create function pg_catalog.btint82cmp(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint82cmp
;

comment on function pg_catalog.btint82cmp(bigint, smallint)
is 'less-equal-greater';

alter function pg_catalog.btint82cmp(bigint, smallint)
  owner to postgres;

create function pg_catalog.btfloat48cmp(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat48cmp
;

comment on function pg_catalog.btfloat48cmp(real, double precision)
is 'less-equal-greater';

alter function pg_catalog.btfloat48cmp(real, double precision)
  owner to postgres;

create function pg_catalog.btfloat84cmp(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat84cmp
;

comment on function pg_catalog.btfloat84cmp(double precision, real)
is 'less-equal-greater';

alter function pg_catalog.btfloat84cmp(double precision, real)
  owner to postgres;

create function pg_catalog.inet_client_addr()
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.inet_client_addr
;

comment on function pg_catalog.inet_client_addr()
is 'inet address of the client';

alter function pg_catalog.inet_client_addr()
  owner to postgres;

create function pg_catalog.inet_client_port()
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.inet_client_port
;

comment on function pg_catalog.inet_client_port()
is 'client''s port number for this connection';

alter function pg_catalog.inet_client_port()
  owner to postgres;

create function pg_catalog.inet_server_addr()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_server_addr
;

comment on function pg_catalog.inet_server_addr()
is 'inet address of the server';

alter function pg_catalog.inet_server_addr()
  owner to postgres;

create function pg_catalog.inet_server_port()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_server_port
;

comment on function pg_catalog.inet_server_port()
is 'server''s port number for this connection';

alter function pg_catalog.inet_server_port()
  owner to postgres;

create function pg_catalog.regprocedurein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocedurein
;

comment on function pg_catalog.regprocedurein(cstring)
is 'I/O';

alter function pg_catalog.regprocedurein(cstring)
  owner to postgres;

create function pg_catalog.regprocedureout(regprocedure)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocedureout
;

comment on function pg_catalog.regprocedureout(regprocedure)
is 'I/O';

alter function pg_catalog.regprocedureout(regprocedure)
  owner to postgres;

create function pg_catalog.regoperin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperin
;

comment on function pg_catalog.regoperin(cstring)
is 'I/O';

alter function pg_catalog.regoperin(cstring)
  owner to postgres;

create function pg_catalog.regoperout(regoper)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperout
;

comment on function pg_catalog.regoperout(regoper)
is 'I/O';

alter function pg_catalog.regoperout(regoper)
  owner to postgres;

create function pg_catalog.regoperatorin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorin
;

comment on function pg_catalog.regoperatorin(cstring)
is 'I/O';

alter function pg_catalog.regoperatorin(cstring)
  owner to postgres;

create function pg_catalog.regoperatorout(regoperator)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorout
;

comment on function pg_catalog.regoperatorout(regoperator)
is 'I/O';

alter function pg_catalog.regoperatorout(regoperator)
  owner to postgres;

create function pg_catalog.regclassin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclassin
;

comment on function pg_catalog.regclassin(cstring)
is 'I/O';

alter function pg_catalog.regclassin(cstring)
  owner to postgres;

create function pg_catalog.regclassout(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclassout
;

comment on function pg_catalog.regclassout(regclass)
is 'I/O';

alter function pg_catalog.regclassout(regclass)
  owner to postgres;

create function pg_catalog.regtypein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtypein
;

comment on function pg_catalog.regtypein(cstring)
is 'I/O';

alter function pg_catalog.regtypein(cstring)
  owner to postgres;

create function pg_catalog.regtypeout(regtype)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtypeout
;

comment on function pg_catalog.regtypeout(regtype)
is 'I/O';

alter function pg_catalog.regtypeout(regtype)
  owner to postgres;

create function pg_catalog.pg_stat_clear_snapshot()
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_clear_snapshot
;

comment on function pg_catalog.pg_stat_clear_snapshot()
is 'statistics: discard current transaction''s statistics snapshot';

alter function pg_catalog.pg_stat_clear_snapshot()
  owner to postgres;

create function pg_catalog.pg_get_function_identity_arguments(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_identity_arguments
;

comment on function pg_catalog.pg_get_function_identity_arguments(oid)
is 'identity argument list of a function';

alter function pg_catalog.pg_get_function_identity_arguments(oid)
  owner to postgres;

create function pg_catalog.fmgr_internal_validator(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fmgr_internal_validator
;

comment on function pg_catalog.fmgr_internal_validator(oid)
is '(internal)';

alter function pg_catalog.fmgr_internal_validator(oid)
  owner to postgres;

create function pg_catalog.fmgr_c_validator(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fmgr_c_validator
;

comment on function pg_catalog.fmgr_c_validator(oid)
is '(internal)';

alter function pg_catalog.fmgr_c_validator(oid)
  owner to postgres;

create function pg_catalog.fmgr_sql_validator(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fmgr_sql_validator
;

comment on function pg_catalog.fmgr_sql_validator(oid)
is '(internal)';

alter function pg_catalog.fmgr_sql_validator(oid)
  owner to postgres;

create function pg_catalog.has_database_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(name, text, text)
is 'user privilege on database by username, database name';

alter function pg_catalog.has_database_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_database_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(name, oid, text)
is 'user privilege on database by username, database oid';

alter function pg_catalog.has_database_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_database_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(oid, text, text)
is 'user privilege on database by user oid, database name';

alter function pg_catalog.has_database_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_database_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(oid, oid, text)
is 'user privilege on database by user oid, database oid';

alter function pg_catalog.has_database_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_database_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(text, text)
is 'current user privilege on database by database name';

alter function pg_catalog.has_database_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_database_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(oid, text)
is 'current user privilege on database by database oid';

alter function pg_catalog.has_database_privilege(oid, text)
  owner to postgres;

create function pg_catalog.has_function_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(name, text, text)
is 'user privilege on function by username, function name';

alter function pg_catalog.has_function_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_function_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(name, oid, text)
is 'user privilege on function by username, function oid';

alter function pg_catalog.has_function_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_function_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(oid, text, text)
is 'user privilege on function by user oid, function name';

alter function pg_catalog.has_function_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_function_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(oid, oid, text)
is 'user privilege on function by user oid, function oid';

alter function pg_catalog.has_function_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_function_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(text, text)
is 'current user privilege on function by function name';

alter function pg_catalog.has_function_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_function_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(oid, text)
is 'current user privilege on function by function oid';

alter function pg_catalog.has_function_privilege(oid, text)
  owner to postgres;

create function pg_catalog.has_language_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(name, text, text)
is 'user privilege on language by username, language name';

alter function pg_catalog.has_language_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_language_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(name, oid, text)
is 'user privilege on language by username, language oid';

alter function pg_catalog.has_language_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_language_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(oid, text, text)
is 'user privilege on language by user oid, language name';

alter function pg_catalog.has_language_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_language_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(oid, oid, text)
is 'user privilege on language by user oid, language oid';

alter function pg_catalog.has_language_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_language_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(text, text)
is 'current user privilege on language by language name';

alter function pg_catalog.has_language_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_language_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(oid, text)
is 'current user privilege on language by language oid';

alter function pg_catalog.has_language_privilege(oid, text)
  owner to postgres;

create function pg_catalog.has_schema_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(name, text, text)
is 'user privilege on schema by username, schema name';

alter function pg_catalog.has_schema_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_schema_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(name, oid, text)
is 'user privilege on schema by username, schema oid';

alter function pg_catalog.has_schema_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_schema_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(oid, text, text)
is 'user privilege on schema by user oid, schema name';

alter function pg_catalog.has_schema_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_schema_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(oid, oid, text)
is 'user privilege on schema by user oid, schema oid';

alter function pg_catalog.has_schema_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_schema_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(text, text)
is 'current user privilege on schema by schema name';

alter function pg_catalog.has_schema_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_schema_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(oid, text)
is 'current user privilege on schema by schema oid';

alter function pg_catalog.has_schema_privilege(oid, text)
  owner to postgres;

create function pg_catalog.pg_stat_reset()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset
;

comment on function pg_catalog.pg_stat_reset()
is 'statistics: reset collected statistics for current database';

alter function pg_catalog.pg_stat_reset()
  owner to postgres;

create function pg_catalog.regexp_replace(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_replace
;

comment on function pg_catalog.regexp_replace(text, text, text)
is 'replace text using regexp';

alter function pg_catalog.regexp_replace(text, text, text)
  owner to postgres;

create function pg_catalog.regexp_replace(text, text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_replace
;

comment on function pg_catalog.regexp_replace(text, text, text, text)
is 'replace text using regexp';

alter function pg_catalog.regexp_replace(text, text, text, text)
  owner to postgres;

create function pg_catalog.pg_total_relation_size(regclass)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_total_relation_size
;

comment on function pg_catalog.pg_total_relation_size(regclass)
is 'total disk space usage for the specified table and associated indexes';

alter function pg_catalog.pg_total_relation_size(regclass)
  owner to postgres;

create function pg_catalog.pg_size_pretty(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_size_pretty
;

comment on function pg_catalog.pg_size_pretty(bigint)
is 'convert a long int to a human readable text using size units';

alter function pg_catalog.pg_size_pretty(bigint)
  owner to postgres;

create function pg_catalog.pg_options_to_table(options_array text [], out option_name text, out option_value text)
stable
strict
parallel safe
cost 1
rows 3
language internal
as
-- missing source code for pg_catalog.pg_options_to_table
;

comment on function pg_catalog.pg_options_to_table(text [], out text, out text)
is 'convert generic options array to name/value table';

alter function pg_catalog.pg_options_to_table(text [], out text, out text)
  owner to postgres;

create function pg_catalog.record_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_in
;

comment on function pg_catalog.record_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.record_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.record_out(record)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_out
;

comment on function pg_catalog.record_out(record)
is 'I/O';

alter function pg_catalog.record_out(record)
  owner to postgres;

create function pg_catalog.cstring_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_in
;

comment on function pg_catalog.cstring_in(cstring)
is 'I/O';

alter function pg_catalog.cstring_in(cstring)
  owner to postgres;

create function pg_catalog.cstring_out(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_out
;

comment on function pg_catalog.cstring_out(cstring)
is 'I/O';

alter function pg_catalog.cstring_out(cstring)
  owner to postgres;

create function pg_catalog.any_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.any_in
;

comment on function pg_catalog.any_in(cstring)
is 'I/O';

alter function pg_catalog.any_in(cstring)
  owner to postgres;

create function pg_catalog.any_out("any")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.any_out
;

comment on function pg_catalog.any_out("any")
is 'I/O';

alter function pg_catalog.any_out("any")
  owner to postgres;

create function pg_catalog.anyarray_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_in
;

comment on function pg_catalog.anyarray_in(cstring)
is 'I/O';

alter function pg_catalog.anyarray_in(cstring)
  owner to postgres;

create function pg_catalog.anyarray_out(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_out
;

comment on function pg_catalog.anyarray_out(anyarray)
is 'I/O';

alter function pg_catalog.anyarray_out(anyarray)
  owner to postgres;

create function pg_catalog.void_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_in
;

comment on function pg_catalog.void_in(cstring)
is 'I/O';

alter function pg_catalog.void_in(cstring)
  owner to postgres;

create function pg_catalog.void_out(void)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_out
;

comment on function pg_catalog.void_out(void)
is 'I/O';

alter function pg_catalog.void_out(void)
  owner to postgres;

create function pg_catalog.trigger_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trigger_in
;

comment on function pg_catalog.trigger_in(cstring)
is 'I/O';

alter function pg_catalog.trigger_in(cstring)
  owner to postgres;

create function pg_catalog.trigger_out(trigger)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trigger_out
;

comment on function pg_catalog.trigger_out(trigger)
is 'I/O';

alter function pg_catalog.trigger_out(trigger)
  owner to postgres;

create function pg_catalog.language_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.language_handler_in
;

comment on function pg_catalog.language_handler_in(cstring)
is 'I/O';

alter function pg_catalog.language_handler_in(cstring)
  owner to postgres;

create function pg_catalog.language_handler_out(language_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.language_handler_out
;

comment on function pg_catalog.language_handler_out(language_handler)
is 'I/O';

alter function pg_catalog.language_handler_out(language_handler)
  owner to postgres;

create function pg_catalog.internal_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.internal_in
;

comment on function pg_catalog.internal_in(cstring)
is 'I/O';

alter function pg_catalog.internal_in(cstring)
  owner to postgres;

create function pg_catalog.internal_out(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.internal_out
;

comment on function pg_catalog.internal_out(internal)
is 'I/O';

alter function pg_catalog.internal_out(internal)
  owner to postgres;

create function pg_catalog.opaque_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.opaque_in
;

comment on function pg_catalog.opaque_in(cstring)
is 'I/O';

alter function pg_catalog.opaque_in(cstring)
  owner to postgres;

create function pg_catalog.opaque_out(opaque)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.opaque_out
;

comment on function pg_catalog.opaque_out(opaque)
is 'I/O';

alter function pg_catalog.opaque_out(opaque)
  owner to postgres;

create function pg_catalog.ceil(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceil
;

comment on function pg_catalog.ceil(double precision)
is 'nearest integer >= value';

alter function pg_catalog.ceil(double precision)
  owner to postgres;

create function pg_catalog.floor(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.floor
;

comment on function pg_catalog.floor(double precision)
is 'nearest integer <= value';

alter function pg_catalog.floor(double precision)
  owner to postgres;

create function pg_catalog.sign(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sign
;

comment on function pg_catalog.sign(double precision)
is 'sign of value';

alter function pg_catalog.sign(double precision)
  owner to postgres;

create function pg_catalog.md5(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.md5
;

comment on function pg_catalog.md5(text)
is 'MD5 hash';

alter function pg_catalog.md5(text)
  owner to postgres;

create function pg_catalog.anyelement_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyelement_in
;

comment on function pg_catalog.anyelement_in(cstring)
is 'I/O';

alter function pg_catalog.anyelement_in(cstring)
  owner to postgres;

create function pg_catalog.anyelement_out(anyelement)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyelement_out
;

comment on function pg_catalog.anyelement_out(anyelement)
is 'I/O';

alter function pg_catalog.anyelement_out(anyelement)
  owner to postgres;

create function pg_catalog.postgresql_fdw_validator(text [], oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.postgresql_fdw_validator
;

comment on function pg_catalog.postgresql_fdw_validator(text [], oid)
is '(internal)';

alter function pg_catalog.postgresql_fdw_validator(text [], oid)
  owner to postgres;

create function pg_catalog.pg_encoding_max_length(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_encoding_max_length
;

comment on function pg_catalog.pg_encoding_max_length(integer)
is 'maximum octet length of a character in given encoding';

alter function pg_catalog.pg_encoding_max_length(integer)
  owner to postgres;

create function pg_catalog.ceiling(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceiling
;

comment on function pg_catalog.ceiling(double precision)
is 'nearest integer >= value';

alter function pg_catalog.ceiling(double precision)
  owner to postgres;

create function pg_catalog.md5(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.md5
;

comment on function pg_catalog.md5(bytea)
is 'MD5 hash';

alter function pg_catalog.md5(bytea)
  owner to postgres;

create function pg_catalog.pg_tablespace_size(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_size
;

comment on function pg_catalog.pg_tablespace_size(oid)
is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(oid)
  owner to postgres;

create function pg_catalog.pg_tablespace_size(name)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_size
;

comment on function pg_catalog.pg_tablespace_size(name)
is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(name)
  owner to postgres;

create function pg_catalog.pg_database_size(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_database_size
;

comment on function pg_catalog.pg_database_size(oid)
is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(oid)
  owner to postgres;

create function pg_catalog.pg_relation_size(regclass)
  returns bigint
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.pg_relation_size($1, 'main')
$$;

comment on function pg_catalog.pg_relation_size(regclass)
is 'disk space usage for the main fork of the specified table or index';

alter function pg_catalog.pg_relation_size(regclass)
  owner to postgres;

create function pg_catalog.unnest(anyarray)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.unnest
;

comment on function pg_catalog.unnest(anyarray)
is 'expand array to set of rows';

alter function pg_catalog.unnest(anyarray)
  owner to postgres;

create function pg_catalog.pg_relation_size(regclass, text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_size
;

comment on function pg_catalog.pg_relation_size(regclass, text)
is 'disk space usage for the specified fork of a table or index';

alter function pg_catalog.pg_relation_size(regclass, text)
  owner to postgres;

create function pg_catalog.array_agg_transfn(internal, anynonarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_transfn
;

comment on function pg_catalog.array_agg_transfn(internal, anynonarray)
is 'aggregate transition function';

alter function pg_catalog.array_agg_transfn(internal, anynonarray)
  owner to postgres;

create function pg_catalog.array_agg_finalfn(internal, anynonarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_finalfn
;

comment on function pg_catalog.array_agg_finalfn(internal, anynonarray)
is 'aggregate final function';

alter function pg_catalog.array_agg_finalfn(internal, anynonarray)
  owner to postgres;

create function pg_catalog.date_lt_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_lt_timestamp
;

comment on function pg_catalog.date_lt_timestamp(date, timestamp)
is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamp(date, timestamp)
  owner to postgres;

create function pg_catalog.date_le_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_le_timestamp
;

comment on function pg_catalog.date_le_timestamp(date, timestamp)
is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamp(date, timestamp)
  owner to postgres;

create function pg_catalog.date_eq_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_eq_timestamp
;

comment on function pg_catalog.date_eq_timestamp(date, timestamp)
is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamp(date, timestamp)
  owner to postgres;

create function pg_catalog.date_gt_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_gt_timestamp
;

comment on function pg_catalog.date_gt_timestamp(date, timestamp)
is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamp(date, timestamp)
  owner to postgres;

create function pg_catalog.date_ge_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ge_timestamp
;

comment on function pg_catalog.date_ge_timestamp(date, timestamp)
is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamp(date, timestamp)
  owner to postgres;

create function pg_catalog.date_ne_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ne_timestamp
;

comment on function pg_catalog.date_ne_timestamp(date, timestamp)
is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamp(date, timestamp)
  owner to postgres;

create function pg_catalog.date_cmp_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_cmp_timestamp
;

comment on function pg_catalog.date_cmp_timestamp(date, timestamp)
is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamp(date, timestamp)
  owner to postgres;

create function pg_catalog.date_lt_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_lt_timestamptz
;

comment on function pg_catalog.date_lt_timestamptz(date, timestamp with time zone)
is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamptz(date, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_le_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_le_timestamptz
;

comment on function pg_catalog.date_le_timestamptz(date, timestamp with time zone)
is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamptz(date, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_eq_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_eq_timestamptz
;

comment on function pg_catalog.date_eq_timestamptz(date, timestamp with time zone)
is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamptz(date, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_gt_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_gt_timestamptz
;

comment on function pg_catalog.date_gt_timestamptz(date, timestamp with time zone)
is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamptz(date, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_ge_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ge_timestamptz
;

comment on function pg_catalog.date_ge_timestamptz(date, timestamp with time zone)
is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamptz(date, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_ne_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ne_timestamptz
;

comment on function pg_catalog.date_ne_timestamptz(date, timestamp with time zone)
is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamptz(date, timestamp with time zone)
  owner to postgres;

create function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_cmp_timestamptz
;

comment on function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone)
is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamp_lt_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_lt_date
;

comment on function pg_catalog.timestamp_lt_date(timestamp, date)
is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_date(timestamp, date)
  owner to postgres;

create function pg_catalog.timestamp_le_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_le_date
;

comment on function pg_catalog.timestamp_le_date(timestamp, date)
is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_date(timestamp, date)
  owner to postgres;

create function pg_catalog.timestamp_eq_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_eq_date
;

comment on function pg_catalog.timestamp_eq_date(timestamp, date)
is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_date(timestamp, date)
  owner to postgres;

create function pg_catalog.timestamp_gt_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_gt_date
;

comment on function pg_catalog.timestamp_gt_date(timestamp, date)
is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_date(timestamp, date)
  owner to postgres;

create function pg_catalog.timestamp_ge_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ge_date
;

comment on function pg_catalog.timestamp_ge_date(timestamp, date)
is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_date(timestamp, date)
  owner to postgres;

create function pg_catalog.timestamp_ne_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ne_date
;

comment on function pg_catalog.timestamp_ne_date(timestamp, date)
is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_date(timestamp, date)
  owner to postgres;

create function pg_catalog.timestamp_cmp_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_cmp_date
;

comment on function pg_catalog.timestamp_cmp_date(timestamp, date)
is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_date(timestamp, date)
  owner to postgres;

create function pg_catalog.timestamptz_lt_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_lt_date
;

comment on function pg_catalog.timestamptz_lt_date(timestamp with time zone, date)
is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_date(timestamp with time zone, date)
  owner to postgres;

create function pg_catalog.timestamptz_le_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_le_date
;

comment on function pg_catalog.timestamptz_le_date(timestamp with time zone, date)
is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_date(timestamp with time zone, date)
  owner to postgres;

create function pg_catalog.timestamptz_eq_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_eq_date
;

comment on function pg_catalog.timestamptz_eq_date(timestamp with time zone, date)
is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_date(timestamp with time zone, date)
  owner to postgres;

create function pg_catalog.timestamptz_gt_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_gt_date
;

comment on function pg_catalog.timestamptz_gt_date(timestamp with time zone, date)
is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_date(timestamp with time zone, date)
  owner to postgres;

create function pg_catalog.timestamptz_ge_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ge_date
;

comment on function pg_catalog.timestamptz_ge_date(timestamp with time zone, date)
is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_date(timestamp with time zone, date)
  owner to postgres;

create function pg_catalog.timestamptz_ne_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ne_date
;

comment on function pg_catalog.timestamptz_ne_date(timestamp with time zone, date)
is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_date(timestamp with time zone, date)
  owner to postgres;

create function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_cmp_date
;

comment on function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date)
is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date)
  owner to postgres;

create function pg_catalog.has_tablespace_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(name, text, text)
is 'user privilege on tablespace by username, tablespace name';

alter function pg_catalog.has_tablespace_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_tablespace_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(name, oid, text)
is 'user privilege on tablespace by username, tablespace oid';

alter function pg_catalog.has_tablespace_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_tablespace_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(oid, text, text)
is 'user privilege on tablespace by user oid, tablespace name';

alter function pg_catalog.has_tablespace_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_tablespace_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(oid, oid, text)
is 'user privilege on tablespace by user oid, tablespace oid';

alter function pg_catalog.has_tablespace_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_tablespace_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(text, text)
is 'current user privilege on tablespace by tablespace name';

alter function pg_catalog.has_tablespace_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_tablespace_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(oid, text)
is 'current user privilege on tablespace by tablespace oid';

alter function pg_catalog.has_tablespace_privilege(oid, text)
  owner to postgres;

create function pg_catalog.shell_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.shell_in
;

comment on function pg_catalog.shell_in(cstring)
is 'I/O';

alter function pg_catalog.shell_in(cstring)
  owner to postgres;

create function pg_catalog.shell_out(opaque)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.shell_out
;

comment on function pg_catalog.shell_out(opaque)
is 'I/O';

alter function pg_catalog.shell_out(opaque)
  owner to postgres;

create function pg_catalog.array_recv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_recv
;

comment on function pg_catalog.array_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.array_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.array_send(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_send
;

comment on function pg_catalog.array_send(anyarray)
is 'I/O';

alter function pg_catalog.array_send(anyarray)
  owner to postgres;

create function pg_catalog.record_recv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_recv
;

comment on function pg_catalog.record_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.record_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.record_send(record)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_send
;

comment on function pg_catalog.record_send(record)
is 'I/O';

alter function pg_catalog.record_send(record)
  owner to postgres;

create function pg_catalog.int2recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2recv
;

comment on function pg_catalog.int2recv(internal)
is 'I/O';

alter function pg_catalog.int2recv(internal)
  owner to postgres;

create function pg_catalog.int2send(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2send
;

comment on function pg_catalog.int2send(smallint)
is 'I/O';

alter function pg_catalog.int2send(smallint)
  owner to postgres;

create function pg_catalog.int4recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4recv
;

comment on function pg_catalog.int4recv(internal)
is 'I/O';

alter function pg_catalog.int4recv(internal)
  owner to postgres;

create function pg_catalog.int4send(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4send
;

comment on function pg_catalog.int4send(integer)
is 'I/O';

alter function pg_catalog.int4send(integer)
  owner to postgres;

create function pg_catalog.int8recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8recv
;

comment on function pg_catalog.int8recv(internal)
is 'I/O';

alter function pg_catalog.int8recv(internal)
  owner to postgres;

create function pg_catalog.int8send(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8send
;

comment on function pg_catalog.int8send(bigint)
is 'I/O';

alter function pg_catalog.int8send(bigint)
  owner to postgres;

create function pg_catalog.int2vectorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorrecv
;

comment on function pg_catalog.int2vectorrecv(internal)
is 'I/O';

alter function pg_catalog.int2vectorrecv(internal)
  owner to postgres;

create function pg_catalog.int2vectorsend(int2vector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorsend
;

comment on function pg_catalog.int2vectorsend(int2vector)
is 'I/O';

alter function pg_catalog.int2vectorsend(int2vector)
  owner to postgres;

create function pg_catalog.bytearecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytearecv
;

comment on function pg_catalog.bytearecv(internal)
is 'I/O';

alter function pg_catalog.bytearecv(internal)
  owner to postgres;

create function pg_catalog.byteasend(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteasend
;

comment on function pg_catalog.byteasend(bytea)
is 'I/O';

alter function pg_catalog.byteasend(bytea)
  owner to postgres;

create function pg_catalog.textrecv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textrecv
;

comment on function pg_catalog.textrecv(internal)
is 'I/O';

alter function pg_catalog.textrecv(internal)
  owner to postgres;

create function pg_catalog.textsend(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textsend
;

comment on function pg_catalog.textsend(text)
is 'I/O';

alter function pg_catalog.textsend(text)
  owner to postgres;

create function pg_catalog.unknownrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownrecv
;

comment on function pg_catalog.unknownrecv(internal)
is 'I/O';

alter function pg_catalog.unknownrecv(internal)
  owner to postgres;

create function pg_catalog.unknownsend(unknown)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownsend
;

comment on function pg_catalog.unknownsend(unknown)
is 'I/O';

alter function pg_catalog.unknownsend(unknown)
  owner to postgres;

create function pg_catalog.oidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidrecv
;

comment on function pg_catalog.oidrecv(internal)
is 'I/O';

alter function pg_catalog.oidrecv(internal)
  owner to postgres;

create function pg_catalog.oidsend(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidsend
;

comment on function pg_catalog.oidsend(oid)
is 'I/O';

alter function pg_catalog.oidsend(oid)
  owner to postgres;

create function pg_catalog.oidvectorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorrecv
;

comment on function pg_catalog.oidvectorrecv(internal)
is 'I/O';

alter function pg_catalog.oidvectorrecv(internal)
  owner to postgres;

create function pg_catalog.oidvectorsend(oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorsend
;

comment on function pg_catalog.oidvectorsend(oidvector)
is 'I/O';

alter function pg_catalog.oidvectorsend(oidvector)
  owner to postgres;

create function pg_catalog.namerecv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namerecv
;

comment on function pg_catalog.namerecv(internal)
is 'I/O';

alter function pg_catalog.namerecv(internal)
  owner to postgres;

create function pg_catalog.namesend(name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namesend
;

comment on function pg_catalog.namesend(name)
is 'I/O';

alter function pg_catalog.namesend(name)
  owner to postgres;

create function pg_catalog.float4recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4recv
;

comment on function pg_catalog.float4recv(internal)
is 'I/O';

alter function pg_catalog.float4recv(internal)
  owner to postgres;

create function pg_catalog.float4send(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4send
;

comment on function pg_catalog.float4send(real)
is 'I/O';

alter function pg_catalog.float4send(real)
  owner to postgres;

create function pg_catalog.float8recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8recv
;

comment on function pg_catalog.float8recv(internal)
is 'I/O';

alter function pg_catalog.float8recv(internal)
  owner to postgres;

create function pg_catalog.float8send(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8send
;

comment on function pg_catalog.float8send(double precision)
is 'I/O';

alter function pg_catalog.float8send(double precision)
  owner to postgres;

create function pg_catalog.point_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_recv
;

comment on function pg_catalog.point_recv(internal)
is 'I/O';

alter function pg_catalog.point_recv(internal)
  owner to postgres;

create function pg_catalog.point_send(point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_send
;

comment on function pg_catalog.point_send(point)
is 'I/O';

alter function pg_catalog.point_send(point)
  owner to postgres;

create function pg_catalog.bpcharrecv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharrecv
;

comment on function pg_catalog.bpcharrecv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.bpcharrecv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.bpcharsend(char)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharsend
;

comment on function pg_catalog.bpcharsend(char)
is 'I/O';

alter function pg_catalog.bpcharsend(char)
  owner to postgres;

create function pg_catalog.varcharrecv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharrecv
;

comment on function pg_catalog.varcharrecv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.varcharrecv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.varcharsend(varchar)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharsend
;

comment on function pg_catalog.varcharsend(varchar)
is 'I/O';

alter function pg_catalog.varcharsend(varchar)
  owner to postgres;

create function pg_catalog.charrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charrecv
;

comment on function pg_catalog.charrecv(internal)
is 'I/O';

alter function pg_catalog.charrecv(internal)
  owner to postgres;

create function pg_catalog.charsend("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charsend
;

comment on function pg_catalog.charsend("char")
is 'I/O';

alter function pg_catalog.charsend("char")
  owner to postgres;

create function pg_catalog.boolrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolrecv
;

comment on function pg_catalog.boolrecv(internal)
is 'I/O';

alter function pg_catalog.boolrecv(internal)
  owner to postgres;

create function pg_catalog.boolsend(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolsend
;

comment on function pg_catalog.boolsend(boolean)
is 'I/O';

alter function pg_catalog.boolsend(boolean)
  owner to postgres;

create function pg_catalog.tidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidrecv
;

comment on function pg_catalog.tidrecv(internal)
is 'I/O';

alter function pg_catalog.tidrecv(internal)
  owner to postgres;

create function pg_catalog.tidsend(tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidsend
;

comment on function pg_catalog.tidsend(tid)
is 'I/O';

alter function pg_catalog.tidsend(tid)
  owner to postgres;

create function pg_catalog.xidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidrecv
;

comment on function pg_catalog.xidrecv(internal)
is 'I/O';

alter function pg_catalog.xidrecv(internal)
  owner to postgres;

create function pg_catalog.xidsend(xid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidsend
;

comment on function pg_catalog.xidsend(xid)
is 'I/O';

alter function pg_catalog.xidsend(xid)
  owner to postgres;

create function pg_catalog.cidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidrecv
;

comment on function pg_catalog.cidrecv(internal)
is 'I/O';

alter function pg_catalog.cidrecv(internal)
  owner to postgres;

create function pg_catalog.cidsend(cid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidsend
;

comment on function pg_catalog.cidsend(cid)
is 'I/O';

alter function pg_catalog.cidsend(cid)
  owner to postgres;

create function pg_catalog.regprocrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocrecv
;

comment on function pg_catalog.regprocrecv(internal)
is 'I/O';

alter function pg_catalog.regprocrecv(internal)
  owner to postgres;

create function pg_catalog.regprocsend(regproc)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocsend
;

comment on function pg_catalog.regprocsend(regproc)
is 'I/O';

alter function pg_catalog.regprocsend(regproc)
  owner to postgres;

create function pg_catalog.regprocedurerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocedurerecv
;

comment on function pg_catalog.regprocedurerecv(internal)
is 'I/O';

alter function pg_catalog.regprocedurerecv(internal)
  owner to postgres;

create function pg_catalog.regproceduresend(regprocedure)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regproceduresend
;

comment on function pg_catalog.regproceduresend(regprocedure)
is 'I/O';

alter function pg_catalog.regproceduresend(regprocedure)
  owner to postgres;

create function pg_catalog.regoperrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperrecv
;

comment on function pg_catalog.regoperrecv(internal)
is 'I/O';

alter function pg_catalog.regoperrecv(internal)
  owner to postgres;

create function pg_catalog.regopersend(regoper)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regopersend
;

comment on function pg_catalog.regopersend(regoper)
is 'I/O';

alter function pg_catalog.regopersend(regoper)
  owner to postgres;

create function pg_catalog.regoperatorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorrecv
;

comment on function pg_catalog.regoperatorrecv(internal)
is 'I/O';

alter function pg_catalog.regoperatorrecv(internal)
  owner to postgres;

create function pg_catalog.regoperatorsend(regoperator)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorsend
;

comment on function pg_catalog.regoperatorsend(regoperator)
is 'I/O';

alter function pg_catalog.regoperatorsend(regoperator)
  owner to postgres;

create function pg_catalog.regclassrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclassrecv
;

comment on function pg_catalog.regclassrecv(internal)
is 'I/O';

alter function pg_catalog.regclassrecv(internal)
  owner to postgres;

create function pg_catalog.regclasssend(regclass)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclasssend
;

comment on function pg_catalog.regclasssend(regclass)
is 'I/O';

alter function pg_catalog.regclasssend(regclass)
  owner to postgres;

create function pg_catalog.regtyperecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtyperecv
;

comment on function pg_catalog.regtyperecv(internal)
is 'I/O';

alter function pg_catalog.regtyperecv(internal)
  owner to postgres;

create function pg_catalog.regtypesend(regtype)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtypesend
;

comment on function pg_catalog.regtypesend(regtype)
is 'I/O';

alter function pg_catalog.regtypesend(regtype)
  owner to postgres;

create function pg_catalog.bit_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_recv
;

comment on function pg_catalog.bit_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.bit_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.bit_send(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_send
;

comment on function pg_catalog.bit_send(bit)
is 'I/O';

alter function pg_catalog.bit_send(bit)
  owner to postgres;

create function pg_catalog.varbit_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_recv
;

comment on function pg_catalog.varbit_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.varbit_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.varbit_send(bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_send
;

comment on function pg_catalog.varbit_send(bit varying)
is 'I/O';

alter function pg_catalog.varbit_send(bit varying)
  owner to postgres;

create function pg_catalog.numeric_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_recv
;

comment on function pg_catalog.numeric_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.numeric_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.numeric_send(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_send
;

comment on function pg_catalog.numeric_send(numeric)
is 'I/O';

alter function pg_catalog.numeric_send(numeric)
  owner to postgres;

create function pg_catalog.abstimerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimerecv
;

comment on function pg_catalog.abstimerecv(internal)
is 'I/O';

alter function pg_catalog.abstimerecv(internal)
  owner to postgres;

create function pg_catalog.abstimesend(abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimesend
;

comment on function pg_catalog.abstimesend(abstime)
is 'I/O';

alter function pg_catalog.abstimesend(abstime)
  owner to postgres;

create function pg_catalog.reltimerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimerecv
;

comment on function pg_catalog.reltimerecv(internal)
is 'I/O';

alter function pg_catalog.reltimerecv(internal)
  owner to postgres;

create function pg_catalog.reltimesend(reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimesend
;

comment on function pg_catalog.reltimesend(reltime)
is 'I/O';

alter function pg_catalog.reltimesend(reltime)
  owner to postgres;

create function pg_catalog.tintervalrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalrecv
;

comment on function pg_catalog.tintervalrecv(internal)
is 'I/O';

alter function pg_catalog.tintervalrecv(internal)
  owner to postgres;

create function pg_catalog.tintervalsend(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalsend
;

comment on function pg_catalog.tintervalsend(tinterval)
is 'I/O';

alter function pg_catalog.tintervalsend(tinterval)
  owner to postgres;

create function pg_catalog.date_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_recv
;

comment on function pg_catalog.date_recv(internal)
is 'I/O';

alter function pg_catalog.date_recv(internal)
  owner to postgres;

create function pg_catalog.date_send(date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_send
;

comment on function pg_catalog.date_send(date)
is 'I/O';

alter function pg_catalog.date_send(date)
  owner to postgres;

create function pg_catalog.time_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_recv
;

comment on function pg_catalog.time_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.time_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.time_send(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_send
;

comment on function pg_catalog.time_send(time)
is 'I/O';

alter function pg_catalog.time_send(time)
  owner to postgres;

create function pg_catalog.timetz_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_recv
;

comment on function pg_catalog.timetz_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.timetz_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.timetz_send(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_send
;

comment on function pg_catalog.timetz_send(time with time zone)
is 'I/O';

alter function pg_catalog.timetz_send(time with time zone)
  owner to postgres;

create function pg_catalog.timestamp_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_recv
;

comment on function pg_catalog.timestamp_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.timestamp_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.timestamp_send(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_send
;

comment on function pg_catalog.timestamp_send(timestamp)
is 'I/O';

alter function pg_catalog.timestamp_send(timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_recv
;

comment on function pg_catalog.timestamptz_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.timestamptz_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.timestamptz_send(timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_send
;

comment on function pg_catalog.timestamptz_send(timestamp with time zone)
is 'I/O';

alter function pg_catalog.timestamptz_send(timestamp with time zone)
  owner to postgres;

create function pg_catalog.interval_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_recv
;

comment on function pg_catalog.interval_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.interval_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.interval_send(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_send
;

comment on function pg_catalog.interval_send(interval)
is 'I/O';

alter function pg_catalog.interval_send(interval)
  owner to postgres;

create function pg_catalog.lseg_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_recv
;

comment on function pg_catalog.lseg_recv(internal)
is 'I/O';

alter function pg_catalog.lseg_recv(internal)
  owner to postgres;

create function pg_catalog.lseg_send(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_send
;

comment on function pg_catalog.lseg_send(lseg)
is 'I/O';

alter function pg_catalog.lseg_send(lseg)
  owner to postgres;

create function pg_catalog.path_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_recv
;

comment on function pg_catalog.path_recv(internal)
is 'I/O';

alter function pg_catalog.path_recv(internal)
  owner to postgres;

create function pg_catalog.path_send(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_send
;

comment on function pg_catalog.path_send(path)
is 'I/O';

alter function pg_catalog.path_send(path)
  owner to postgres;

create function pg_catalog.box_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_recv
;

comment on function pg_catalog.box_recv(internal)
is 'I/O';

alter function pg_catalog.box_recv(internal)
  owner to postgres;

create function pg_catalog.box_send(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_send
;

comment on function pg_catalog.box_send(box)
is 'I/O';

alter function pg_catalog.box_send(box)
  owner to postgres;

create function pg_catalog.poly_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_recv
;

comment on function pg_catalog.poly_recv(internal)
is 'I/O';

alter function pg_catalog.poly_recv(internal)
  owner to postgres;

create function pg_catalog.poly_send(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_send
;

comment on function pg_catalog.poly_send(polygon)
is 'I/O';

alter function pg_catalog.poly_send(polygon)
  owner to postgres;

create function pg_catalog.line_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_recv
;

comment on function pg_catalog.line_recv(internal)
is 'I/O';

alter function pg_catalog.line_recv(internal)
  owner to postgres;

create function pg_catalog.line_send(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_send
;

comment on function pg_catalog.line_send(line)
is 'I/O';

alter function pg_catalog.line_send(line)
  owner to postgres;

create function pg_catalog.circle_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_recv
;

comment on function pg_catalog.circle_recv(internal)
is 'I/O';

alter function pg_catalog.circle_recv(internal)
  owner to postgres;

create function pg_catalog.circle_send(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_send
;

comment on function pg_catalog.circle_send(circle)
is 'I/O';

alter function pg_catalog.circle_send(circle)
  owner to postgres;

create function pg_catalog.cash_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_recv
;

comment on function pg_catalog.cash_recv(internal)
is 'I/O';

alter function pg_catalog.cash_recv(internal)
  owner to postgres;

create function pg_catalog.cash_send(money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_send
;

comment on function pg_catalog.cash_send(money)
is 'I/O';

alter function pg_catalog.cash_send(money)
  owner to postgres;

create function pg_catalog.macaddr_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_recv
;

comment on function pg_catalog.macaddr_recv(internal)
is 'I/O';

alter function pg_catalog.macaddr_recv(internal)
  owner to postgres;

create function pg_catalog.macaddr_send(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_send
;

comment on function pg_catalog.macaddr_send(macaddr)
is 'I/O';

alter function pg_catalog.macaddr_send(macaddr)
  owner to postgres;

create function pg_catalog.inet_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_recv
;

comment on function pg_catalog.inet_recv(internal)
is 'I/O';

alter function pg_catalog.inet_recv(internal)
  owner to postgres;

create function pg_catalog.inet_send(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_send
;

comment on function pg_catalog.inet_send(inet)
is 'I/O';

alter function pg_catalog.inet_send(inet)
  owner to postgres;

create function pg_catalog.cidr_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_recv
;

comment on function pg_catalog.cidr_recv(internal)
is 'I/O';

alter function pg_catalog.cidr_recv(internal)
  owner to postgres;

create function pg_catalog.cidr_send(cidr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_send
;

comment on function pg_catalog.cidr_send(cidr)
is 'I/O';

alter function pg_catalog.cidr_send(cidr)
  owner to postgres;

create function pg_catalog.cstring_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_recv
;

comment on function pg_catalog.cstring_recv(internal)
is 'I/O';

alter function pg_catalog.cstring_recv(internal)
  owner to postgres;

create function pg_catalog.cstring_send(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_send
;

comment on function pg_catalog.cstring_send(cstring)
is 'I/O';

alter function pg_catalog.cstring_send(cstring)
  owner to postgres;

create function pg_catalog.anyarray_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_recv
;

comment on function pg_catalog.anyarray_recv(internal)
is 'I/O';

alter function pg_catalog.anyarray_recv(internal)
  owner to postgres;

create function pg_catalog.anyarray_send(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_send
;

comment on function pg_catalog.anyarray_send(anyarray)
is 'I/O';

alter function pg_catalog.anyarray_send(anyarray)
  owner to postgres;

create function pg_catalog.pg_get_ruledef(oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_ruledef
;

comment on function pg_catalog.pg_get_ruledef(oid, boolean)
is 'source text of a rule with pretty-print option';

alter function pg_catalog.pg_get_ruledef(oid, boolean)
  owner to postgres;

create function pg_catalog.pg_get_viewdef(text, boolean)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(text, boolean)
is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(text, boolean)
  owner to postgres;

create function pg_catalog.pg_get_viewdef(oid, boolean)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(oid, boolean)
is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(oid, boolean)
  owner to postgres;

create function pg_catalog.pg_get_indexdef(oid, integer, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_indexdef
;

comment on function pg_catalog.pg_get_indexdef(oid, integer, boolean)
is 'index description (full create statement or single expression) with pretty-print option';

alter function pg_catalog.pg_get_indexdef(oid, integer, boolean)
  owner to postgres;

create function pg_catalog.pg_get_constraintdef(oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_constraintdef
;

comment on function pg_catalog.pg_get_constraintdef(oid, boolean)
is 'constraint description with pretty-print option';

alter function pg_catalog.pg_get_constraintdef(oid, boolean)
  owner to postgres;

create function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_expr
;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean)
is 'deparse an encoded expression with pretty-print option';

alter function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean)
  owner to postgres;

create function pg_catalog.pg_prepared_statement(out name            text, out statement text,
                                                 out prepare_time    timestamp with time zone,
                                                 out parameter_types regtype [], out from_sql boolean)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_prepared_statement
;

comment on function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype [],
                                                     out boolean)
is 'get the prepared statements for this session';

alter function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype [], out boolean)
  owner to postgres;

create function pg_catalog.pg_cursor(out name          text, out statement text, out is_holdable boolean,
                                     out is_binary     boolean, out is_scrollable boolean,
                                     out creation_time timestamp with time zone)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_cursor
;

comment on function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean,
                                         out timestamp with time zone)
is 'get the open cursors for this session';

alter function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.float8_var_pop(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_var_pop
;

comment on function pg_catalog.float8_var_pop(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_var_pop(double precision [])
  owner to postgres;

create function pg_catalog.float8_stddev_pop(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_stddev_pop
;

comment on function pg_catalog.float8_stddev_pop(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_stddev_pop(double precision [])
  owner to postgres;

create function pg_catalog.numeric_var_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_var_pop
;

comment on function pg_catalog.numeric_var_pop(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_var_pop(internal)
  owner to postgres;

create function pg_catalog.booland_statefunc(boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.booland_statefunc
;

comment on function pg_catalog.booland_statefunc(boolean, boolean)
is 'aggregate transition function';

alter function pg_catalog.booland_statefunc(boolean, boolean)
  owner to postgres;

create function pg_catalog.boolor_statefunc(boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolor_statefunc
;

comment on function pg_catalog.boolor_statefunc(boolean, boolean)
is 'aggregate transition function';

alter function pg_catalog.boolor_statefunc(boolean, boolean)
  owner to postgres;

create function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_lt_timestamptz
;

comment on function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone)
is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_le_timestamptz
;

comment on function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone)
is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_eq_timestamptz
;

comment on function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone)
is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_gt_timestamptz
;

comment on function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone)
is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ge_timestamptz
;

comment on function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone)
is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ne_timestamptz
;

comment on function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone)
is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_cmp_timestamptz
;

comment on function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone)
is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone)
  owner to postgres;

create function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_lt_timestamp
;

comment on function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp)
is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_le_timestamp
;

comment on function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp)
is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_eq_timestamp
;

comment on function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp)
is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_gt_timestamp
;

comment on function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp)
is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ge_timestamp
;

comment on function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp)
is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ne_timestamp
;

comment on function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp)
is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp)
  owner to postgres;

create function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_cmp_timestamp
;

comment on function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp)
is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp)
  owner to postgres;

create function pg_catalog.interval_pl_date(interval, date)
  returns timestamp without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_date(interval, date)
is 'implementation of + operator';

alter function pg_catalog.interval_pl_date(interval, date)
  owner to postgres;

create function pg_catalog.interval_pl_timetz(interval, time with time zone)
  returns time with time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timetz(interval, time with time zone)
is 'implementation of + operator';

alter function pg_catalog.interval_pl_timetz(interval, time with time zone)
  owner to postgres;

create function pg_catalog.interval_pl_timestamp(interval, timestamp without time zone)
  returns timestamp without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timestamp(interval, timestamp)
is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamp(interval, timestamp)
  owner to postgres;

create function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone)
  returns timestamp with time zone
stable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone)
is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone)
  owner to postgres;

create function pg_catalog.integer_pl_date(integer, date)
  returns date
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.integer_pl_date(integer, date)
is 'implementation of + operator';

alter function pg_catalog.integer_pl_date(integer, date)
  owner to postgres;

create function pg_catalog.pg_tablespace_databases(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_databases
;

comment on function pg_catalog.pg_tablespace_databases(oid)
is 'get OIDs of databases in a tablespace';

alter function pg_catalog.pg_tablespace_databases(oid)
  owner to postgres;

create function pg_catalog.bool(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool
;

comment on function pg_catalog.bool(integer)
is 'convert int4 to boolean';

alter function pg_catalog.bool(integer)
  owner to postgres;

create function pg_catalog.int4(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(boolean)
is 'convert boolean to int4';

alter function pg_catalog.int4(boolean)
  owner to postgres;

create function pg_catalog.lastval()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lastval
;

comment on function pg_catalog.lastval()
is 'current value from last used sequence';

alter function pg_catalog.lastval()
  owner to postgres;

create function pg_catalog.pg_postmaster_start_time()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_postmaster_start_time
;

comment on function pg_catalog.pg_postmaster_start_time()
is 'postmaster start time';

alter function pg_catalog.pg_postmaster_start_time()
  owner to postgres;

create function pg_catalog.pg_blocking_pids(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_blocking_pids
;

comment on function pg_catalog.pg_blocking_pids(integer)
is 'get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock';

alter function pg_catalog.pg_blocking_pids(integer)
  owner to postgres;

create function pg_catalog.box_below(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_below
;

comment on function pg_catalog.box_below(box, box)
is 'implementation of <<| operator';

alter function pg_catalog.box_below(box, box)
  owner to postgres;

create function pg_catalog.box_overbelow(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overbelow
;

comment on function pg_catalog.box_overbelow(box, box)
is 'implementation of &<| operator';

alter function pg_catalog.box_overbelow(box, box)
  owner to postgres;

create function pg_catalog.box_overabove(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overabove
;

comment on function pg_catalog.box_overabove(box, box)
is 'implementation of |&> operator';

alter function pg_catalog.box_overabove(box, box)
  owner to postgres;

create function pg_catalog.box_above(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_above
;

comment on function pg_catalog.box_above(box, box)
is 'implementation of |>> operator';

alter function pg_catalog.box_above(box, box)
  owner to postgres;

create function pg_catalog.poly_below(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_below
;

comment on function pg_catalog.poly_below(polygon, polygon)
is 'implementation of <<| operator';

alter function pg_catalog.poly_below(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_overbelow(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overbelow
;

comment on function pg_catalog.poly_overbelow(polygon, polygon)
is 'implementation of &<| operator';

alter function pg_catalog.poly_overbelow(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_overabove(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overabove
;

comment on function pg_catalog.poly_overabove(polygon, polygon)
is 'implementation of |&> operator';

alter function pg_catalog.poly_overabove(polygon, polygon)
  owner to postgres;

create function pg_catalog.poly_above(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_above
;

comment on function pg_catalog.poly_above(polygon, polygon)
is 'implementation of |>> operator';

alter function pg_catalog.poly_above(polygon, polygon)
  owner to postgres;

create function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_consistent
;

comment on function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.gist_box_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_compress
;

comment on function pg_catalog.gist_box_compress(internal)
is 'GiST support';

alter function pg_catalog.gist_box_compress(internal)
  owner to postgres;

create function pg_catalog.gist_box_decompress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_decompress
;

comment on function pg_catalog.gist_box_decompress(internal)
is 'GiST support';

alter function pg_catalog.gist_box_decompress(internal)
  owner to postgres;

create function pg_catalog.gist_box_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_penalty
;

comment on function pg_catalog.gist_box_penalty(internal, internal, internal)
is 'GiST support';

alter function pg_catalog.gist_box_penalty(internal, internal, internal)
  owner to postgres;

create function pg_catalog.gist_box_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_picksplit
;

comment on function pg_catalog.gist_box_picksplit(internal, internal)
is 'GiST support';

alter function pg_catalog.gist_box_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.gist_box_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_union
;

comment on function pg_catalog.gist_box_union(internal, internal)
is 'GiST support';

alter function pg_catalog.gist_box_union(internal, internal)
  owner to postgres;

create function pg_catalog.gist_box_same(box, box, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_same
;

comment on function pg_catalog.gist_box_same(box, box, internal)
is 'GiST support';

alter function pg_catalog.gist_box_same(box, box, internal)
  owner to postgres;

create function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_poly_consistent
;

comment on function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.gist_poly_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_poly_compress
;

comment on function pg_catalog.gist_poly_compress(internal)
is 'GiST support';

alter function pg_catalog.gist_poly_compress(internal)
  owner to postgres;

create function pg_catalog.circle_overbelow(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overbelow
;

comment on function pg_catalog.circle_overbelow(circle, circle)
is 'implementation of &<| operator';

alter function pg_catalog.circle_overbelow(circle, circle)
  owner to postgres;

create function pg_catalog.circle_overabove(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overabove
;

comment on function pg_catalog.circle_overabove(circle, circle)
is 'implementation of |&> operator';

alter function pg_catalog.circle_overabove(circle, circle)
  owner to postgres;

create function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_circle_consistent
;

comment on function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.gist_circle_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_circle_compress
;

comment on function pg_catalog.gist_circle_compress(internal)
is 'GiST support';

alter function pg_catalog.gist_circle_compress(internal)
  owner to postgres;

create function pg_catalog.numeric_stddev_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_stddev_pop
;

comment on function pg_catalog.numeric_stddev_pop(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_stddev_pop(internal)
  owner to postgres;

create function pg_catalog.domain_in(cstring, oid, integer)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.domain_in
;

comment on function pg_catalog.domain_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.domain_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.domain_recv(internal, oid, integer)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.domain_recv
;

comment on function pg_catalog.domain_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.domain_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.pg_timezone_abbrevs(out abbrev text, out utc_offset interval, out is_dst boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_timezone_abbrevs
;

comment on function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean)
is 'get the available time zone abbreviations';

alter function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean)
  owner to postgres;

create function pg_catalog.xmlexists(text, xml)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlexists
;

comment on function pg_catalog.xmlexists(text, xml)
is 'test XML value against XPath expression';

alter function pg_catalog.xmlexists(text, xml)
  owner to postgres;

create function pg_catalog.pg_reload_conf()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_reload_conf
;

comment on function pg_catalog.pg_reload_conf()
is 'reload configuration files';

alter function pg_catalog.pg_reload_conf()
  owner to postgres;

create function pg_catalog.pg_rotate_logfile()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_rotate_logfile
;

comment on function pg_catalog.pg_rotate_logfile()
is 'rotate log file';

alter function pg_catalog.pg_rotate_logfile()
  owner to postgres;

create function pg_catalog.pg_stat_file(filename text, out size bigint, out access timestamp with time zone,
                                                       out modification timestamp with time zone,
                                                       out change timestamp with time zone,
                                                       out creation timestamp with time zone, out isdir boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_file
;

comment on function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone,
                                                  out timestamp with time zone, out timestamp with time zone,
                                                  out timestamp with time zone, out boolean)
is 'get information about file';

alter function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean)
  owner to postgres;

create function pg_catalog.pg_read_file(text, bigint, bigint)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_file
;

comment on function pg_catalog.pg_read_file(text, bigint, bigint)
is 'read text from a file';

alter function pg_catalog.pg_read_file(text, bigint, bigint)
  owner to postgres;

create function pg_catalog.pg_ls_dir(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ls_dir
;

comment on function pg_catalog.pg_ls_dir(text)
is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir(text)
  owner to postgres;

create function pg_catalog.pg_sleep(double precision)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_sleep
;

comment on function pg_catalog.pg_sleep(double precision)
is 'sleep for the specified time in seconds';

alter function pg_catalog.pg_sleep(double precision)
  owner to postgres;

create function pg_catalog.inetnot(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetnot
;

comment on function pg_catalog.inetnot(inet)
is 'implementation of ~ operator';

alter function pg_catalog.inetnot(inet)
  owner to postgres;

create function pg_catalog.inetand(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetand
;

comment on function pg_catalog.inetand(inet, inet)
is 'implementation of & operator';

alter function pg_catalog.inetand(inet, inet)
  owner to postgres;

create function pg_catalog.inetor(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetor
;

comment on function pg_catalog.inetor(inet, inet)
is 'implementation of | operator';

alter function pg_catalog.inetor(inet, inet)
  owner to postgres;

create function pg_catalog.inetpl(inet, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetpl
;

comment on function pg_catalog.inetpl(inet, bigint)
is 'implementation of + operator';

alter function pg_catalog.inetpl(inet, bigint)
  owner to postgres;

create function pg_catalog.int8pl_inet(bigint, inet)
  returns inet
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.int8pl_inet(bigint, inet)
is 'implementation of + operator';

alter function pg_catalog.int8pl_inet(bigint, inet)
  owner to postgres;

create function pg_catalog.inetmi_int8(inet, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetmi_int8
;

comment on function pg_catalog.inetmi_int8(inet, bigint)
is 'implementation of - operator';

alter function pg_catalog.inetmi_int8(inet, bigint)
  owner to postgres;

create function pg_catalog.inetmi(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetmi
;

comment on function pg_catalog.inetmi(inet, inet)
is 'implementation of - operator';

alter function pg_catalog.inetmi(inet, inet)
  owner to postgres;

create function pg_catalog.transaction_timestamp()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.transaction_timestamp
;

comment on function pg_catalog.transaction_timestamp()
is 'current transaction time';

alter function pg_catalog.transaction_timestamp()
  owner to postgres;

create function pg_catalog.statement_timestamp()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.statement_timestamp
;

comment on function pg_catalog.statement_timestamp()
is 'current statement time';

alter function pg_catalog.statement_timestamp()
  owner to postgres;

create function pg_catalog.clock_timestamp()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.clock_timestamp
;

comment on function pg_catalog.clock_timestamp()
is 'current clock time';

alter function pg_catalog.clock_timestamp()
  owner to postgres;

create function pg_catalog.gin_cmp_prefix(text, text, smallint, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_cmp_prefix
;

comment on function pg_catalog.gin_cmp_prefix(text, text, smallint, internal)
is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_prefix(text, text, smallint, internal)
  owner to postgres;

create function pg_catalog.pg_has_role(name, name, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(name, name, text)
is 'user privilege on role by username, role name';

alter function pg_catalog.pg_has_role(name, name, text)
  owner to postgres;

create function pg_catalog.pg_has_role(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(name, oid, text)
is 'user privilege on role by username, role oid';

alter function pg_catalog.pg_has_role(name, oid, text)
  owner to postgres;

create function pg_catalog.pg_has_role(oid, name, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(oid, name, text)
is 'user privilege on role by user oid, role name';

alter function pg_catalog.pg_has_role(oid, name, text)
  owner to postgres;

create function pg_catalog.pg_has_role(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(oid, oid, text)
is 'user privilege on role by user oid, role oid';

alter function pg_catalog.pg_has_role(oid, oid, text)
  owner to postgres;

create function pg_catalog.pg_has_role(name, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(name, text)
is 'current user privilege on role by role name';

alter function pg_catalog.pg_has_role(name, text)
  owner to postgres;

create function pg_catalog.pg_has_role(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(oid, text)
is 'current user privilege on role by role oid';

alter function pg_catalog.pg_has_role(oid, text)
  owner to postgres;

create function pg_catalog.justify_interval(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.justify_interval
;

comment on function pg_catalog.justify_interval(interval)
is 'promote groups of 24 hours to numbers of days and promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_interval(interval)
  owner to postgres;

create function pg_catalog.pg_get_triggerdef(oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_triggerdef
;

comment on function pg_catalog.pg_get_triggerdef(oid, boolean)
is 'trigger description with pretty-print option';

alter function pg_catalog.pg_get_triggerdef(oid, boolean)
  owner to postgres;

create function pg_catalog.asind(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.asind
;

comment on function pg_catalog.asind(double precision)
is 'arcsine, degrees';

alter function pg_catalog.asind(double precision)
  owner to postgres;

create function pg_catalog.acosd(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.acosd
;

comment on function pg_catalog.acosd(double precision)
is 'arccosine, degrees';

alter function pg_catalog.acosd(double precision)
  owner to postgres;

create function pg_catalog.atand(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atand
;

comment on function pg_catalog.atand(double precision)
is 'arctangent, degrees';

alter function pg_catalog.atand(double precision)
  owner to postgres;

create function pg_catalog.atan2d(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atan2d
;

comment on function pg_catalog.atan2d(double precision, double precision)
is 'arctangent, two arguments, degrees';

alter function pg_catalog.atan2d(double precision, double precision)
  owner to postgres;

create function pg_catalog.sind(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sind
;

comment on function pg_catalog.sind(double precision)
is 'sine, degrees';

alter function pg_catalog.sind(double precision)
  owner to postgres;

create function pg_catalog.cosd(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cosd
;

comment on function pg_catalog.cosd(double precision)
is 'cosine, degrees';

alter function pg_catalog.cosd(double precision)
  owner to postgres;

create function pg_catalog.tand(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tand
;

comment on function pg_catalog.tand(double precision)
is 'tangent, degrees';

alter function pg_catalog.tand(double precision)
  owner to postgres;

create function pg_catalog.cotd(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cotd
;

comment on function pg_catalog.cotd(double precision)
is 'cotangent, degrees';

alter function pg_catalog.cotd(double precision)
  owner to postgres;

create function pg_catalog.pg_stop_backup(exclusive boolean, wait_for_archive boolean default true, out lsn pg_lsn,
                                                                                                    out labelfile text,
                                                                                                    out spcmapfile text)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stop_backup
;

comment on function pg_catalog.pg_stop_backup(boolean, boolean, out pg_lsn, out text, out text)
is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup(boolean, boolean, out pg_lsn, out text, out text)
  owner to postgres;

create function pg_catalog.numeric_avg_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_serialize
;

comment on function pg_catalog.numeric_avg_serialize(internal)
is 'aggregate serial function';

alter function pg_catalog.numeric_avg_serialize(internal)
  owner to postgres;

create function pg_catalog.numeric_avg_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_deserialize
;

comment on function pg_catalog.numeric_avg_deserialize(bytea, internal)
is 'aggregate deserial function';

alter function pg_catalog.numeric_avg_deserialize(bytea, internal)
  owner to postgres;

create function pg_catalog.ginarrayextract(anyarray, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarrayextract
;

comment on function pg_catalog.ginarrayextract(anyarray, internal, internal)
is 'GIN array support';

alter function pg_catalog.ginarrayextract(anyarray, internal, internal)
  owner to postgres;

create function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal,
                                              internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarrayconsistent
;

comment on function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal,
                                                  internal)
is 'GIN array support';

alter function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.int8_avg_accum(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_accum
;

comment on function pg_catalog.int8_avg_accum(internal, bigint)
is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum(internal, bigint)
  owner to postgres;

create function pg_catalog.arrayoverlap(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arrayoverlap
;

comment on function pg_catalog.arrayoverlap(anyarray, anyarray)
is 'implementation of && operator';

alter function pg_catalog.arrayoverlap(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.arraycontains(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontains
;

comment on function pg_catalog.arraycontains(anyarray, anyarray)
is 'implementation of @> operator';

alter function pg_catalog.arraycontains(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.arraycontained(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontained
;

comment on function pg_catalog.arraycontained(anyarray, anyarray)
is 'implementation of <@ operator';

alter function pg_catalog.arraycontained(anyarray, anyarray)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_returned(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_returned
;

comment on function pg_catalog.pg_stat_get_db_tuples_returned(oid)
is 'statistics: tuples returned for database';

alter function pg_catalog.pg_stat_get_db_tuples_returned(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_fetched
;

comment on function pg_catalog.pg_stat_get_db_tuples_fetched(oid)
is 'statistics: tuples fetched for database';

alter function pg_catalog.pg_stat_get_db_tuples_fetched(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_inserted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_inserted
;

comment on function pg_catalog.pg_stat_get_db_tuples_inserted(oid)
is 'statistics: tuples inserted in database';

alter function pg_catalog.pg_stat_get_db_tuples_inserted(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_updated(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_updated
;

comment on function pg_catalog.pg_stat_get_db_tuples_updated(oid)
is 'statistics: tuples updated in database';

alter function pg_catalog.pg_stat_get_db_tuples_updated(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_deleted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_deleted
;

comment on function pg_catalog.pg_stat_get_db_tuples_deleted(oid)
is 'statistics: tuples deleted in database';

alter function pg_catalog.pg_stat_get_db_tuples_deleted(oid)
  owner to postgres;

create function pg_catalog.regexp_matches(text, text)
immutable
strict
parallel safe
cost 1
rows 1
language internal
as
-- missing source code for pg_catalog.regexp_matches
;

comment on function pg_catalog.regexp_matches(text, text)
is 'find match(es) for regexp';

alter function pg_catalog.regexp_matches(text, text)
  owner to postgres;

create function pg_catalog.regexp_matches(text, text, text)
immutable
strict
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.regexp_matches
;

comment on function pg_catalog.regexp_matches(text, text, text)
is 'find match(es) for regexp';

alter function pg_catalog.regexp_matches(text, text, text)
  owner to postgres;

create function pg_catalog.regexp_split_to_table(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_table
;

comment on function pg_catalog.regexp_split_to_table(text, text)
is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table(text, text)
  owner to postgres;

create function pg_catalog.regexp_split_to_table(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_table
;

comment on function pg_catalog.regexp_split_to_table(text, text, text)
is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table(text, text, text)
  owner to postgres;

create function pg_catalog.regexp_split_to_array(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_array
;

comment on function pg_catalog.regexp_split_to_array(text, text)
is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array(text, text)
  owner to postgres;

create function pg_catalog.regexp_split_to_array(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_array
;

comment on function pg_catalog.regexp_split_to_array(text, text, text)
is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array(text, text, text)
  owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_timed_checkpoints
;

comment on function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()
is 'statistics: number of timed checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()
  owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_requested_checkpoints
;

comment on function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()
is 'statistics: number of backend requested checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()
  owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints
;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()
is 'statistics: number of buffers written by the bgwriter during checkpoints';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()
  owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_buf_written_clean()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_buf_written_clean
;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_clean()
is 'statistics: number of buffers written by the bgwriter for cleaning dirty buffers';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_clean()
  owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_maxwritten_clean
;

comment on function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()
is 'statistics: number of times the bgwriter stopped processing when it had written too many buffers while cleaning';

alter function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()
  owner to postgres;

create function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginqueryarrayextract
;

comment on function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal,
                                                    internal)
is 'GIN array support';

alter function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.pg_stat_get_buf_written_backend()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_buf_written_backend
;

comment on function pg_catalog.pg_stat_get_buf_written_backend()
is 'statistics: number of buffers written by backends';

alter function pg_catalog.pg_stat_get_buf_written_backend()
  owner to postgres;

create function pg_catalog.anynonarray_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anynonarray_in
;

comment on function pg_catalog.anynonarray_in(cstring)
is 'I/O';

alter function pg_catalog.anynonarray_in(cstring)
  owner to postgres;

create function pg_catalog.anynonarray_out(anynonarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anynonarray_out
;

comment on function pg_catalog.anynonarray_out(anynonarray)
is 'I/O';

alter function pg_catalog.anynonarray_out(anynonarray)
  owner to postgres;

create function pg_catalog.pg_stat_get_last_vacuum_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_vacuum_time
;

comment on function pg_catalog.pg_stat_get_last_vacuum_time(oid)
is 'statistics: last manual vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_vacuum_time(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_last_autovacuum_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_autovacuum_time
;

comment on function pg_catalog.pg_stat_get_last_autovacuum_time(oid)
is 'statistics: last auto vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_autovacuum_time(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_last_analyze_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_analyze_time
;

comment on function pg_catalog.pg_stat_get_last_analyze_time(oid)
is 'statistics: last manual analyze time for a table';

alter function pg_catalog.pg_stat_get_last_analyze_time(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_last_autoanalyze_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_autoanalyze_time
;

comment on function pg_catalog.pg_stat_get_last_autoanalyze_time(oid)
is 'statistics: last auto analyze time for a table';

alter function pg_catalog.pg_stat_get_last_autoanalyze_time(oid)
  owner to postgres;

create function pg_catalog.int8_avg_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_combine
;

comment on function pg_catalog.int8_avg_combine(internal, internal)
is 'aggregate combine function';

alter function pg_catalog.int8_avg_combine(internal, internal)
  owner to postgres;

create function pg_catalog.int8_avg_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_serialize
;

comment on function pg_catalog.int8_avg_serialize(internal)
is 'aggregate serial function';

alter function pg_catalog.int8_avg_serialize(internal)
  owner to postgres;

create function pg_catalog.int8_avg_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_deserialize
;

comment on function pg_catalog.int8_avg_deserialize(bytea, internal)
is 'aggregate deserial function';

alter function pg_catalog.int8_avg_deserialize(bytea, internal)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_wait_event_type(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_wait_event_type
;

comment on function pg_catalog.pg_stat_get_backend_wait_event_type(integer)
is 'statistics: wait event type on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event_type(integer)
  owner to postgres;

create function pg_catalog.tidgt(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidgt
;

comment on function pg_catalog.tidgt(tid, tid)
is 'implementation of > operator';

alter function pg_catalog.tidgt(tid, tid)
  owner to postgres;

create function pg_catalog.tidlt(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidlt
;

comment on function pg_catalog.tidlt(tid, tid)
is 'implementation of < operator';

alter function pg_catalog.tidlt(tid, tid)
  owner to postgres;

create function pg_catalog.tidge(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidge
;

comment on function pg_catalog.tidge(tid, tid)
is 'implementation of >= operator';

alter function pg_catalog.tidge(tid, tid)
  owner to postgres;

create function pg_catalog.tidle(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidle
;

comment on function pg_catalog.tidle(tid, tid)
is 'implementation of <= operator';

alter function pg_catalog.tidle(tid, tid)
  owner to postgres;

create function pg_catalog.bttidcmp(tid, tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttidcmp
;

comment on function pg_catalog.bttidcmp(tid, tid)
is 'less-equal-greater';

alter function pg_catalog.bttidcmp(tid, tid)
  owner to postgres;

create function pg_catalog.tidlarger(tid, tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidlarger
;

comment on function pg_catalog.tidlarger(tid, tid)
is 'larger of two';

alter function pg_catalog.tidlarger(tid, tid)
  owner to postgres;

create function pg_catalog.tidsmaller(tid, tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidsmaller
;

comment on function pg_catalog.tidsmaller(tid, tid)
is 'smaller of two';

alter function pg_catalog.tidsmaller(tid, tid)
  owner to postgres;

create function pg_catalog.int8inc_any(bigint, "any")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8inc_any
;

comment on function pg_catalog.int8inc_any(bigint, "any")
is 'increment, ignores second argument';

alter function pg_catalog.int8inc_any(bigint, "any")
  owner to postgres;

create function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8inc_float8_float8
;

comment on function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision)
is 'aggregate transition function';

alter function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision)
  owner to postgres;

create function pg_catalog.float8_regr_accum(double precision [], double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_accum
;

comment on function pg_catalog.float8_regr_accum(double precision [], double precision, double precision)
is 'aggregate transition function';

alter function pg_catalog.float8_regr_accum(double precision [], double precision, double precision)
  owner to postgres;

create function pg_catalog.float8_regr_sxx(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_sxx
;

comment on function pg_catalog.float8_regr_sxx(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_sxx(double precision [])
  owner to postgres;

create function pg_catalog.float8_regr_syy(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_syy
;

comment on function pg_catalog.float8_regr_syy(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_syy(double precision [])
  owner to postgres;

create function pg_catalog.float8_regr_sxy(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_sxy
;

comment on function pg_catalog.float8_regr_sxy(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_sxy(double precision [])
  owner to postgres;

create function pg_catalog.float8_regr_avgx(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_avgx
;

comment on function pg_catalog.float8_regr_avgx(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_avgx(double precision [])
  owner to postgres;

create function pg_catalog.float8_regr_avgy(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_avgy
;

comment on function pg_catalog.float8_regr_avgy(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_avgy(double precision [])
  owner to postgres;

create function pg_catalog.float8_regr_r2(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_r2
;

comment on function pg_catalog.float8_regr_r2(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_r2(double precision [])
  owner to postgres;

create function pg_catalog.float8_regr_slope(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_slope
;

comment on function pg_catalog.float8_regr_slope(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_slope(double precision [])
  owner to postgres;

create function pg_catalog.float8_regr_intercept(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_intercept
;

comment on function pg_catalog.float8_regr_intercept(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_regr_intercept(double precision [])
  owner to postgres;

create function pg_catalog.float8_covar_pop(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_covar_pop
;

comment on function pg_catalog.float8_covar_pop(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_covar_pop(double precision [])
  owner to postgres;

create function pg_catalog.float8_covar_samp(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_covar_samp
;

comment on function pg_catalog.float8_covar_samp(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_covar_samp(double precision [])
  owner to postgres;

create function pg_catalog.float8_corr(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_corr
;

comment on function pg_catalog.float8_corr(double precision [])
is 'aggregate final function';

alter function pg_catalog.float8_corr(double precision [])
  owner to postgres;

create function pg_catalog.pg_stat_get_db_blk_read_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blk_read_time
;

comment on function pg_catalog.pg_stat_get_db_blk_read_time(oid)
is 'statistics: block read time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_blk_read_time(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_blk_write_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blk_write_time
;

comment on function pg_catalog.pg_stat_get_db_blk_write_time(oid)
is 'statistics: block write time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_blk_write_time(oid)
  owner to postgres;

create function pg_catalog.pg_switch_wal()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_switch_wal
;

comment on function pg_catalog.pg_switch_wal()
is 'switch to new wal file';

alter function pg_catalog.pg_switch_wal()
  owner to postgres;

create function pg_catalog.pg_current_wal_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_wal_lsn
;

comment on function pg_catalog.pg_current_wal_lsn()
is 'current wal write location';

alter function pg_catalog.pg_current_wal_lsn()
  owner to postgres;

create function pg_catalog.pg_walfile_name_offset(lsn pg_lsn, out file_name text, out file_offset integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_walfile_name_offset
;

comment on function pg_catalog.pg_walfile_name_offset(pg_lsn, out text, out integer)
is 'wal filename and byte offset, given a wal location';

alter function pg_catalog.pg_walfile_name_offset(pg_lsn, out text, out integer)
  owner to postgres;

create function pg_catalog.pg_walfile_name(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_walfile_name
;

comment on function pg_catalog.pg_walfile_name(pg_lsn)
is 'wal filename, given a wal location';

alter function pg_catalog.pg_walfile_name(pg_lsn)
  owner to postgres;

create function pg_catalog.pg_current_wal_insert_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_wal_insert_lsn
;

comment on function pg_catalog.pg_current_wal_insert_lsn()
is 'current wal insert location';

alter function pg_catalog.pg_current_wal_insert_lsn()
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_wait_event(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_wait_event
;

comment on function pg_catalog.pg_stat_get_backend_wait_event(integer)
is 'statistics: wait event on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event(integer)
  owner to postgres;

create function pg_catalog.pg_my_temp_schema()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_my_temp_schema
;

comment on function pg_catalog.pg_my_temp_schema()
is 'get OID of current session''s temp schema, if any';

alter function pg_catalog.pg_my_temp_schema()
  owner to postgres;

create function pg_catalog.pg_is_other_temp_schema(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_other_temp_schema
;

comment on function pg_catalog.pg_is_other_temp_schema(oid)
is 'is schema another session''s temp schema?';

alter function pg_catalog.pg_is_other_temp_schema(oid)
  owner to postgres;

create function pg_catalog.pg_timezone_names(out name   text, out abbrev text, out utc_offset interval,
                                             out is_dst boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_timezone_names
;

comment on function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean)
is 'get the available time zone names';

alter function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean)
  owner to postgres;

create function pg_catalog.pg_stat_get_backend_xact_start(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_xact_start
;

comment on function pg_catalog.pg_stat_get_backend_xact_start(integer)
is 'statistics: start time for backend''s current transaction';

alter function pg_catalog.pg_stat_get_backend_xact_start(integer)
  owner to postgres;

create function pg_catalog.numeric_avg_accum(internal, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_accum
;

comment on function pg_catalog.numeric_avg_accum(internal, numeric)
is 'aggregate transition function';

alter function pg_catalog.numeric_avg_accum(internal, numeric)
  owner to postgres;

create function pg_catalog.pg_stat_get_buf_alloc()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_buf_alloc
;

comment on function pg_catalog.pg_stat_get_buf_alloc()
is 'statistics: number of buffer allocations';

alter function pg_catalog.pg_stat_get_buf_alloc()
  owner to postgres;

create function pg_catalog.pg_stat_get_live_tuples(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_live_tuples
;

comment on function pg_catalog.pg_stat_get_live_tuples(oid)
is 'statistics: number of live tuples';

alter function pg_catalog.pg_stat_get_live_tuples(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_dead_tuples(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_dead_tuples
;

comment on function pg_catalog.pg_stat_get_dead_tuples(oid)
is 'statistics: number of dead tuples';

alter function pg_catalog.pg_stat_get_dead_tuples(oid)
  owner to postgres;

create function pg_catalog.pg_advisory_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock
;

comment on function pg_catalog.pg_advisory_lock(bigint)
is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock(bigint)
  owner to postgres;

create function pg_catalog.pg_advisory_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock_shared
;

comment on function pg_catalog.pg_advisory_lock_shared(bigint)
is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared(bigint)
  owner to postgres;

create function pg_catalog.pg_try_advisory_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock
;

comment on function pg_catalog.pg_try_advisory_lock(bigint)
is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock(bigint)
  owner to postgres;

create function pg_catalog.pg_try_advisory_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock_shared
;

comment on function pg_catalog.pg_try_advisory_lock_shared(bigint)
is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared(bigint)
  owner to postgres;

create function pg_catalog.pg_advisory_unlock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock
;

comment on function pg_catalog.pg_advisory_unlock(bigint)
is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock(bigint)
  owner to postgres;

create function pg_catalog.pg_advisory_unlock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock_shared
;

comment on function pg_catalog.pg_advisory_unlock_shared(bigint)
is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared(bigint)
  owner to postgres;

create function pg_catalog.pg_advisory_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock
;

comment on function pg_catalog.pg_advisory_lock(integer, integer)
is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock(integer, integer)
  owner to postgres;

create function pg_catalog.pg_advisory_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock_shared
;

comment on function pg_catalog.pg_advisory_lock_shared(integer, integer)
is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared(integer, integer)
  owner to postgres;

create function pg_catalog.pg_try_advisory_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock
;

comment on function pg_catalog.pg_try_advisory_lock(integer, integer)
is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock(integer, integer)
  owner to postgres;

create function pg_catalog.pg_try_advisory_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock_shared
;

comment on function pg_catalog.pg_try_advisory_lock_shared(integer, integer)
is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared(integer, integer)
  owner to postgres;

create function pg_catalog.pg_advisory_unlock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock
;

comment on function pg_catalog.pg_advisory_unlock(integer, integer)
is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock(integer, integer)
  owner to postgres;

create function pg_catalog.pg_advisory_unlock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock_shared
;

comment on function pg_catalog.pg_advisory_unlock_shared(integer, integer)
is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared(integer, integer)
  owner to postgres;

create function pg_catalog.pg_advisory_unlock_all()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock_all
;

comment on function pg_catalog.pg_advisory_unlock_all()
is 'release all advisory locks';

alter function pg_catalog.pg_advisory_unlock_all()
  owner to postgres;

create function pg_catalog.xml_in(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_in
;

comment on function pg_catalog.xml_in(cstring)
is 'I/O';

alter function pg_catalog.xml_in(cstring)
  owner to postgres;

create function pg_catalog.xml_out(xml)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_out
;

comment on function pg_catalog.xml_out(xml)
is 'I/O';

alter function pg_catalog.xml_out(xml)
  owner to postgres;

create function pg_catalog.xmlcomment(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlcomment
;

comment on function pg_catalog.xmlcomment(text)
is 'generate XML comment';

alter function pg_catalog.xmlcomment(text)
  owner to postgres;

create function pg_catalog.xml(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml
;

comment on function pg_catalog.xml(text)
is 'perform a non-validating parse of a character string to produce an XML value';

alter function pg_catalog.xml(text)
  owner to postgres;

create function pg_catalog.xmlvalidate(xml, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlvalidate
;

comment on function pg_catalog.xmlvalidate(xml, text)
is 'validate an XML value';

alter function pg_catalog.xmlvalidate(xml, text)
  owner to postgres;

create function pg_catalog.xml_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_recv
;

comment on function pg_catalog.xml_recv(internal)
is 'I/O';

alter function pg_catalog.xml_recv(internal)
  owner to postgres;

create function pg_catalog.xml_send(xml)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_send
;

comment on function pg_catalog.xml_send(xml)
is 'I/O';

alter function pg_catalog.xml_send(xml)
  owner to postgres;

create function pg_catalog.xmlconcat2(xml, xml)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlconcat2
;

comment on function pg_catalog.xmlconcat2(xml, xml)
is 'aggregate transition function';

alter function pg_catalog.xmlconcat2(xml, xml)
  owner to postgres;

create function pg_catalog.varbittypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbittypmodin
;

comment on function pg_catalog.varbittypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.varbittypmodin(cstring [])
  owner to postgres;

create function pg_catalog.intervaltypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.intervaltypmodin
;

comment on function pg_catalog.intervaltypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.intervaltypmodin(cstring [])
  owner to postgres;

create function pg_catalog.intervaltypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.intervaltypmodout
;

comment on function pg_catalog.intervaltypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.intervaltypmodout(integer)
  owner to postgres;

create function pg_catalog.timestamptypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptypmodin
;

comment on function pg_catalog.timestamptypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.timestamptypmodin(cstring [])
  owner to postgres;

create function pg_catalog.timestamptypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptypmodout
;

comment on function pg_catalog.timestamptypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.timestamptypmodout(integer)
  owner to postgres;

create function pg_catalog.timestamptztypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptztypmodin
;

comment on function pg_catalog.timestamptztypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.timestamptztypmodin(cstring [])
  owner to postgres;

create function pg_catalog.timestamptztypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptztypmodout
;

comment on function pg_catalog.timestamptztypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.timestamptztypmodout(integer)
  owner to postgres;

create function pg_catalog.timetypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetypmodin
;

comment on function pg_catalog.timetypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.timetypmodin(cstring [])
  owner to postgres;

create function pg_catalog.timetypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetypmodout
;

comment on function pg_catalog.timetypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.timetypmodout(integer)
  owner to postgres;

create function pg_catalog.timetztypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetztypmodin
;

comment on function pg_catalog.timetztypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.timetztypmodin(cstring [])
  owner to postgres;

create function pg_catalog.timetztypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetztypmodout
;

comment on function pg_catalog.timetztypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.timetztypmodout(integer)
  owner to postgres;

create function pg_catalog.bpchartypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchartypmodin
;

comment on function pg_catalog.bpchartypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.bpchartypmodin(cstring [])
  owner to postgres;

create function pg_catalog.bpchartypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchartypmodout
;

comment on function pg_catalog.bpchartypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.bpchartypmodout(integer)
  owner to postgres;

create function pg_catalog.varchartypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchartypmodin
;

comment on function pg_catalog.varchartypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.varchartypmodin(cstring [])
  owner to postgres;

create function pg_catalog.varchartypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchartypmodout
;

comment on function pg_catalog.varchartypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.varchartypmodout(integer)
  owner to postgres;

create function pg_catalog.numerictypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numerictypmodin
;

comment on function pg_catalog.numerictypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.numerictypmodin(cstring [])
  owner to postgres;

create function pg_catalog.numerictypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numerictypmodout
;

comment on function pg_catalog.numerictypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.numerictypmodout(integer)
  owner to postgres;

create function pg_catalog.bittypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bittypmodin
;

comment on function pg_catalog.bittypmodin(cstring [])
is 'I/O typmod';

alter function pg_catalog.bittypmodin(cstring [])
  owner to postgres;

create function pg_catalog.bittypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bittypmodout
;

comment on function pg_catalog.bittypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.bittypmodout(integer)
  owner to postgres;

create function pg_catalog.varbittypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbittypmodout
;

comment on function pg_catalog.varbittypmodout(integer)
is 'I/O typmod';

alter function pg_catalog.varbittypmodout(integer)
  owner to postgres;

create function pg_catalog.text(xml)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(xml)
is 'serialize an XML value to a character string';

alter function pg_catalog.text(xml)
  owner to postgres;

create function pg_catalog.table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.table_to_xml
;

comment on function pg_catalog.table_to_xml(regclass, boolean, boolean, text)
is 'map table contents to XML';

alter function pg_catalog.table_to_xml(regclass, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.query_to_xml
;

comment on function pg_catalog.query_to_xml(text, boolean, boolean, text)
is 'map query result to XML';

alter function pg_catalog.query_to_xml(text, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.cursor_to_xml(cursor   refcursor, count integer, nulls boolean, tableforest boolean,
                                         targetns text)
strict
language internal
as
-- missing source code for pg_catalog.cursor_to_xml
;

comment on function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text)
is 'map rows from cursor to XML';

alter function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.table_to_xmlschema
;

comment on function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text)
is 'map table structure to XML Schema';

alter function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.query_to_xmlschema
;

comment on function pg_catalog.query_to_xmlschema(text, boolean, boolean, text)
is 'map query result structure to XML Schema';

alter function pg_catalog.query_to_xmlschema(text, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.cursor_to_xmlschema
;

comment on function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text)
is 'map cursor structure to XML Schema';

alter function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.table_to_xml_and_xmlschema
;

comment on function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text)
is 'map table contents and structure to XML and XML Schema';

alter function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.query_to_xml_and_xmlschema
;

comment on function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text)
is 'map query result and structure to XML and XML Schema';

alter function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.xpath(text, xml, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xpath
;

comment on function pg_catalog.xpath(text, xml, text [])
is 'evaluate XPath expression, with namespaces support';

alter function pg_catalog.xpath(text, xml, text [])
  owner to postgres;

create function pg_catalog.xpath(text, xml)
  returns xml []
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.xpath($1, $2, '{}' :: pg_catalog.text [])
$$;

comment on function pg_catalog.xpath(text, xml)
is 'evaluate XPath expression';

alter function pg_catalog.xpath(text, xml)
  owner to postgres;

create function pg_catalog.schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.schema_to_xml
;

comment on function pg_catalog.schema_to_xml(name, boolean, boolean, text)
is 'map schema contents to XML';

alter function pg_catalog.schema_to_xml(name, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.schema_to_xmlschema
;

comment on function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text)
is 'map schema structure to XML Schema';

alter function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.schema_to_xml_and_xmlschema
;

comment on function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text)
is 'map schema contents and structure to XML and XML Schema';

alter function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text)
  owner to postgres;

create function pg_catalog.database_to_xml(nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.database_to_xml
;

comment on function pg_catalog.database_to_xml(boolean, boolean, text)
is 'map database contents to XML';

alter function pg_catalog.database_to_xml(boolean, boolean, text)
  owner to postgres;

create function pg_catalog.database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.database_to_xmlschema
;

comment on function pg_catalog.database_to_xmlschema(boolean, boolean, text)
is 'map database structure to XML Schema';

alter function pg_catalog.database_to_xmlschema(boolean, boolean, text)
  owner to postgres;

create function pg_catalog.database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.database_to_xml_and_xmlschema
;

comment on function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text)
is 'map database contents and structure to XML and XML Schema';

alter function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text)
  owner to postgres;

create function pg_catalog.txid_snapshot_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_in
;

comment on function pg_catalog.txid_snapshot_in(cstring)
is 'I/O';

alter function pg_catalog.txid_snapshot_in(cstring)
  owner to postgres;

create function pg_catalog.txid_snapshot_out(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_out
;

comment on function pg_catalog.txid_snapshot_out(txid_snapshot)
is 'I/O';

alter function pg_catalog.txid_snapshot_out(txid_snapshot)
  owner to postgres;

create function pg_catalog.txid_snapshot_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_recv
;

comment on function pg_catalog.txid_snapshot_recv(internal)
is 'I/O';

alter function pg_catalog.txid_snapshot_recv(internal)
  owner to postgres;

create function pg_catalog.txid_snapshot_send(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_send
;

comment on function pg_catalog.txid_snapshot_send(txid_snapshot)
is 'I/O';

alter function pg_catalog.txid_snapshot_send(txid_snapshot)
  owner to postgres;

create function pg_catalog.txid_current()
stable
strict
cost 1
language internal
as
-- missing source code for pg_catalog.txid_current
;

comment on function pg_catalog.txid_current()
is 'get current transaction ID';

alter function pg_catalog.txid_current()
  owner to postgres;

create function pg_catalog.txid_current_snapshot()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_current_snapshot
;

comment on function pg_catalog.txid_current_snapshot()
is 'get current snapshot';

alter function pg_catalog.txid_current_snapshot()
  owner to postgres;

create function pg_catalog.txid_snapshot_xmin(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_xmin
;

comment on function pg_catalog.txid_snapshot_xmin(txid_snapshot)
is 'get xmin of snapshot';

alter function pg_catalog.txid_snapshot_xmin(txid_snapshot)
  owner to postgres;

create function pg_catalog.txid_snapshot_xmax(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_xmax
;

comment on function pg_catalog.txid_snapshot_xmax(txid_snapshot)
is 'get xmax of snapshot';

alter function pg_catalog.txid_snapshot_xmax(txid_snapshot)
  owner to postgres;

create function pg_catalog.txid_snapshot_xip(txid_snapshot)
immutable
strict
parallel safe
cost 1
rows 50
language internal
as
-- missing source code for pg_catalog.txid_snapshot_xip
;

comment on function pg_catalog.txid_snapshot_xip(txid_snapshot)
is 'get set of in-progress txids in snapshot';

alter function pg_catalog.txid_snapshot_xip(txid_snapshot)
  owner to postgres;

create function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_visible_in_snapshot
;

comment on function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot)
is 'is txid visible in snapshot?';

alter function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot)
  owner to postgres;

create function pg_catalog.uuid_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_in
;

comment on function pg_catalog.uuid_in(cstring)
is 'I/O';

alter function pg_catalog.uuid_in(cstring)
  owner to postgres;

create function pg_catalog.uuid_out(uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_out
;

comment on function pg_catalog.uuid_out(uuid)
is 'I/O';

alter function pg_catalog.uuid_out(uuid)
  owner to postgres;

create function pg_catalog.uuid_lt(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_lt
;

comment on function pg_catalog.uuid_lt(uuid, uuid)
is 'implementation of < operator';

alter function pg_catalog.uuid_lt(uuid, uuid)
  owner to postgres;

create function pg_catalog.uuid_le(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_le
;

comment on function pg_catalog.uuid_le(uuid, uuid)
is 'implementation of <= operator';

alter function pg_catalog.uuid_le(uuid, uuid)
  owner to postgres;

create function pg_catalog.uuid_eq(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_eq
;

comment on function pg_catalog.uuid_eq(uuid, uuid)
is 'implementation of = operator';

alter function pg_catalog.uuid_eq(uuid, uuid)
  owner to postgres;

create function pg_catalog.uuid_ge(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_ge
;

comment on function pg_catalog.uuid_ge(uuid, uuid)
is 'implementation of >= operator';

alter function pg_catalog.uuid_ge(uuid, uuid)
  owner to postgres;

create function pg_catalog.uuid_gt(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_gt
;

comment on function pg_catalog.uuid_gt(uuid, uuid)
is 'implementation of > operator';

alter function pg_catalog.uuid_gt(uuid, uuid)
  owner to postgres;

create function pg_catalog.uuid_ne(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_ne
;

comment on function pg_catalog.uuid_ne(uuid, uuid)
is 'implementation of <> operator';

alter function pg_catalog.uuid_ne(uuid, uuid)
  owner to postgres;

create function pg_catalog.uuid_cmp(uuid, uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_cmp
;

comment on function pg_catalog.uuid_cmp(uuid, uuid)
is 'less-equal-greater';

alter function pg_catalog.uuid_cmp(uuid, uuid)
  owner to postgres;

create function pg_catalog.uuid_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_recv
;

comment on function pg_catalog.uuid_recv(internal)
is 'I/O';

alter function pg_catalog.uuid_recv(internal)
  owner to postgres;

create function pg_catalog.uuid_send(uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_send
;

comment on function pg_catalog.uuid_send(uuid)
is 'I/O';

alter function pg_catalog.uuid_send(uuid)
  owner to postgres;

create function pg_catalog.uuid_hash(uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_hash
;

comment on function pg_catalog.uuid_hash(uuid)
is 'hash';

alter function pg_catalog.uuid_hash(uuid)
  owner to postgres;

create function pg_catalog.text(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(boolean)
is 'convert boolean to text';

alter function pg_catalog.text(boolean)
  owner to postgres;

create function pg_catalog.pg_stat_get_function_calls(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_function_calls
;

comment on function pg_catalog.pg_stat_get_function_calls(oid)
is 'statistics: number of function calls';

alter function pg_catalog.pg_stat_get_function_calls(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_function_total_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_function_total_time
;

comment on function pg_catalog.pg_stat_get_function_total_time(oid)
is 'statistics: total execution time of function, in milliseconds';

alter function pg_catalog.pg_stat_get_function_total_time(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_function_self_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_function_self_time
;

comment on function pg_catalog.pg_stat_get_function_self_time(oid)
is 'statistics: self execution time of function, in milliseconds';

alter function pg_catalog.pg_stat_get_function_self_time(oid)
  owner to postgres;

create function pg_catalog.record_eq(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_eq
;

comment on function pg_catalog.record_eq(record, record)
is 'implementation of = operator';

alter function pg_catalog.record_eq(record, record)
  owner to postgres;

create function pg_catalog.record_ne(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_ne
;

comment on function pg_catalog.record_ne(record, record)
is 'implementation of <> operator';

alter function pg_catalog.record_ne(record, record)
  owner to postgres;

create function pg_catalog.record_lt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_lt
;

comment on function pg_catalog.record_lt(record, record)
is 'implementation of < operator';

alter function pg_catalog.record_lt(record, record)
  owner to postgres;

create function pg_catalog.record_gt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_gt
;

comment on function pg_catalog.record_gt(record, record)
is 'implementation of > operator';

alter function pg_catalog.record_gt(record, record)
  owner to postgres;

create function pg_catalog.record_le(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_le
;

comment on function pg_catalog.record_le(record, record)
is 'implementation of <= operator';

alter function pg_catalog.record_le(record, record)
  owner to postgres;

create function pg_catalog.record_ge(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_ge
;

comment on function pg_catalog.record_ge(record, record)
is 'implementation of >= operator';

alter function pg_catalog.record_ge(record, record)
  owner to postgres;

create function pg_catalog.btrecordcmp(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrecordcmp
;

comment on function pg_catalog.btrecordcmp(record, record)
is 'less-equal-greater';

alter function pg_catalog.btrecordcmp(record, record)
  owner to postgres;

create function pg_catalog.pg_table_size(regclass)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_table_size
;

comment on function pg_catalog.pg_table_size(regclass)
is 'disk space usage for the specified table, including TOAST, free space and visibility map';

alter function pg_catalog.pg_table_size(regclass)
  owner to postgres;

create function pg_catalog.pg_indexes_size(regclass)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_indexes_size
;

comment on function pg_catalog.pg_indexes_size(regclass)
is 'disk space usage for all indexes attached to the specified table';

alter function pg_catalog.pg_indexes_size(regclass)
  owner to postgres;

create function pg_catalog.pg_relation_filenode(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_filenode
;

comment on function pg_catalog.pg_relation_filenode(regclass)
is 'filenode identifier of relation';

alter function pg_catalog.pg_relation_filenode(regclass)
  owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text)
is 'user privilege on foreign data wrapper by username, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text)
is 'user privilege on foreign data wrapper by username, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text)
is 'user privilege on foreign data wrapper by user oid, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text)
is 'user privilege on foreign data wrapper by user oid, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(text, text)
is 'current user privilege on foreign data wrapper by foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text)
is 'current user privilege on foreign data wrapper by foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, text)
  owner to postgres;

create function pg_catalog.has_server_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(name, text, text)
is 'user privilege on server by username, server name';

alter function pg_catalog.has_server_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_server_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(name, oid, text)
is 'user privilege on server by username, server oid';

alter function pg_catalog.has_server_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_server_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(oid, text, text)
is 'user privilege on server by user oid, server name';

alter function pg_catalog.has_server_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_server_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(oid, oid, text)
is 'user privilege on server by user oid, server oid';

alter function pg_catalog.has_server_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_server_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(text, text)
is 'current user privilege on server by server name';

alter function pg_catalog.has_server_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_server_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(oid, text)
is 'current user privilege on server by server oid';

alter function pg_catalog.has_server_privilege(oid, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(name, text, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, text, text, text)
is 'user privilege on column by username, rel name, col name';

alter function pg_catalog.has_column_privilege(name, text, text, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(name, text, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, text, smallint, text)
is 'user privilege on column by username, rel name, col attnum';

alter function pg_catalog.has_column_privilege(name, text, smallint, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(name, oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, oid, text, text)
is 'user privilege on column by username, rel oid, col name';

alter function pg_catalog.has_column_privilege(name, oid, text, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(name, oid, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, oid, smallint, text)
is 'user privilege on column by username, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(name, oid, smallint, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(oid, text, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, text, text, text)
is 'user privilege on column by user oid, rel name, col name';

alter function pg_catalog.has_column_privilege(oid, text, text, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(oid, text, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, text, smallint, text)
is 'user privilege on column by user oid, rel name, col attnum';

alter function pg_catalog.has_column_privilege(oid, text, smallint, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(oid, oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, oid, text, text)
is 'user privilege on column by user oid, rel oid, col name';

alter function pg_catalog.has_column_privilege(oid, oid, text, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(oid, oid, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, oid, smallint, text)
is 'user privilege on column by user oid, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(oid, oid, smallint, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(text, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(text, text, text)
is 'current user privilege on column by rel name, col name';

alter function pg_catalog.has_column_privilege(text, text, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(text, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(text, smallint, text)
is 'current user privilege on column by rel name, col attnum';

alter function pg_catalog.has_column_privilege(text, smallint, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, text, text)
is 'current user privilege on column by rel oid, col name';

alter function pg_catalog.has_column_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_column_privilege(oid, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, smallint, text)
is 'current user privilege on column by rel oid, col attnum';

alter function pg_catalog.has_column_privilege(oid, smallint, text)
  owner to postgres;

create function pg_catalog.has_any_column_privilege(name, text, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(name, text, text)
is 'user privilege on any column by username, rel name';

alter function pg_catalog.has_any_column_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_any_column_privilege(name, oid, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(name, oid, text)
is 'user privilege on any column by username, rel oid';

alter function pg_catalog.has_any_column_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_any_column_privilege(oid, text, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(oid, text, text)
is 'user privilege on any column by user oid, rel name';

alter function pg_catalog.has_any_column_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_any_column_privilege(oid, oid, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(oid, oid, text)
is 'user privilege on any column by user oid, rel oid';

alter function pg_catalog.has_any_column_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_any_column_privilege(text, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(text, text)
is 'current user privilege on any column by rel name';

alter function pg_catalog.has_any_column_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_any_column_privilege(oid, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(oid, text)
is 'current user privilege on any column by rel oid';

alter function pg_catalog.has_any_column_privilege(oid, text)
  owner to postgres;

create function pg_catalog.overlay(bit, bit, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bit, bit, integer, integer)
is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit, integer, integer)
  owner to postgres;

create function pg_catalog.overlay(bit, bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bit, bit, integer)
is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit, integer)
  owner to postgres;

create function pg_catalog.get_bit(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_bit
;

comment on function pg_catalog.get_bit(bit, integer)
is 'get bit';

alter function pg_catalog.get_bit(bit, integer)
  owner to postgres;

create function pg_catalog.set_bit(bit, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_bit
;

comment on function pg_catalog.set_bit(bit, integer, integer)
is 'set bit';

alter function pg_catalog.set_bit(bit, integer, integer)
  owner to postgres;

create function pg_catalog.pg_relation_filepath(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_filepath
;

comment on function pg_catalog.pg_relation_filepath(regclass)
is 'file path of relation';

alter function pg_catalog.pg_relation_filepath(regclass)
  owner to postgres;

create function pg_catalog.pg_listening_channels()
stable
strict
parallel restricted
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.pg_listening_channels
;

comment on function pg_catalog.pg_listening_channels()
is 'get the channels that the current backend listens to';

alter function pg_catalog.pg_listening_channels()
  owner to postgres;

create function pg_catalog.pg_notify(text, text)
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_notify
;

comment on function pg_catalog.pg_notify(text, text)
is 'send a notification event';

alter function pg_catalog.pg_notify(text, text)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_numscans(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_numscans
;

comment on function pg_catalog.pg_stat_get_xact_numscans(oid)
is 'statistics: number of scans done for table/index in current transaction';

alter function pg_catalog.pg_stat_get_xact_numscans(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_returned(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_returned
;

comment on function pg_catalog.pg_stat_get_xact_tuples_returned(oid)
is 'statistics: number of tuples read by seqscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_returned(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_fetched(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_fetched
;

comment on function pg_catalog.pg_stat_get_xact_tuples_fetched(oid)
is 'statistics: number of tuples fetched by idxscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_fetched(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_inserted(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_inserted
;

comment on function pg_catalog.pg_stat_get_xact_tuples_inserted(oid)
is 'statistics: number of tuples inserted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_inserted(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_updated(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_updated
;

comment on function pg_catalog.pg_stat_get_xact_tuples_updated(oid)
is 'statistics: number of tuples updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_updated(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_deleted(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_deleted
;

comment on function pg_catalog.pg_stat_get_xact_tuples_deleted(oid)
is 'statistics: number of tuples deleted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_deleted(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_hot_updated
;

comment on function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid)
is 'statistics: number of tuples hot updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_blocks_fetched(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_blocks_fetched
;

comment on function pg_catalog.pg_stat_get_xact_blocks_fetched(oid)
is 'statistics: number of blocks fetched in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_fetched(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_blocks_hit(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_blocks_hit
;

comment on function pg_catalog.pg_stat_get_xact_blocks_hit(oid)
is 'statistics: number of blocks found in cache in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_hit(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_calls(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_function_calls
;

comment on function pg_catalog.pg_stat_get_xact_function_calls(oid)
is 'statistics: number of function calls in current transaction';

alter function pg_catalog.pg_stat_get_xact_function_calls(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_total_time(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_function_total_time
;

comment on function pg_catalog.pg_stat_get_xact_function_total_time(oid)
is 'statistics: total execution time of function in current transaction, in milliseconds';

alter function pg_catalog.pg_stat_get_xact_function_total_time(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_self_time(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_function_self_time
;

comment on function pg_catalog.pg_stat_get_xact_function_self_time(oid)
is 'statistics: self execution time of function in current transaction, in milliseconds';

alter function pg_catalog.pg_stat_get_xact_function_self_time(oid)
  owner to postgres;

create function pg_catalog.xpath_exists(text, xml, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xpath_exists
;

comment on function pg_catalog.xpath_exists(text, xml, text [])
is 'test XML value against XPath expression, with namespace support';

alter function pg_catalog.xpath_exists(text, xml, text [])
  owner to postgres;

create function pg_catalog.xpath_exists(text, xml)
  returns boolean
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.xpath_exists($1, $2, '{}' :: pg_catalog.text [])
$$;

comment on function pg_catalog.xpath_exists(text, xml)
is 'test XML value against XPath expression';

alter function pg_catalog.xpath_exists(text, xml)
  owner to postgres;

create function pg_catalog.xml_is_well_formed(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_is_well_formed
;

comment on function pg_catalog.xml_is_well_formed(text)
is 'determine if a string is well formed XML';

alter function pg_catalog.xml_is_well_formed(text)
  owner to postgres;

create function pg_catalog.xml_is_well_formed_document(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_is_well_formed_document
;

comment on function pg_catalog.xml_is_well_formed_document(text)
is 'determine if a string is well formed XML document';

alter function pg_catalog.xml_is_well_formed_document(text)
  owner to postgres;

create function pg_catalog.xml_is_well_formed_content(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_is_well_formed_content
;

comment on function pg_catalog.xml_is_well_formed_content(text)
is 'determine if a string is well formed XML content';

alter function pg_catalog.xml_is_well_formed_content(text)
  owner to postgres;

create function pg_catalog.pg_stat_get_vacuum_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_vacuum_count
;

comment on function pg_catalog.pg_stat_get_vacuum_count(oid)
is 'statistics: number of manual vacuums for a table';

alter function pg_catalog.pg_stat_get_vacuum_count(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_autovacuum_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_autovacuum_count
;

comment on function pg_catalog.pg_stat_get_autovacuum_count(oid)
is 'statistics: number of auto vacuums for a table';

alter function pg_catalog.pg_stat_get_autovacuum_count(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_analyze_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_analyze_count
;

comment on function pg_catalog.pg_stat_get_analyze_count(oid)
is 'statistics: number of manual analyzes for a table';

alter function pg_catalog.pg_stat_get_analyze_count(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_autoanalyze_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_autoanalyze_count
;

comment on function pg_catalog.pg_stat_get_autoanalyze_count(oid)
is 'statistics: number of auto analyzes for a table';

alter function pg_catalog.pg_stat_get_autoanalyze_count(oid)
  owner to postgres;

create function pg_catalog.concat("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.concat
;

comment on function pg_catalog.concat("any")
is 'concatenate values';

alter function pg_catalog.concat("any")
  owner to postgres;

create function pg_catalog.concat_ws(text, "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.concat_ws
;

comment on function pg_catalog.concat_ws(text, "any")
is 'concatenate values with separators';

alter function pg_catalog.concat_ws(text, "any")
  owner to postgres;

create function pg_catalog."left"(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."left"
;

comment on function pg_catalog."left"(text, integer)
is 'extract the first n characters';

alter function pg_catalog."left"(text, integer)
  owner to postgres;

create function pg_catalog."right"(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."right"
;

comment on function pg_catalog."right"(text, integer)
is 'extract the last n characters';

alter function pg_catalog."right"(text, integer)
  owner to postgres;

create function pg_catalog.reverse(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reverse
;

comment on function pg_catalog.reverse(text)
is 'reverse text';

alter function pg_catalog.reverse(text)
  owner to postgres;

create function pg_catalog.pg_stat_get_buf_fsync_backend()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_buf_fsync_backend
;

comment on function pg_catalog.pg_stat_get_buf_fsync_backend()
is 'statistics: number of backend buffer writes that did their own fsync';

alter function pg_catalog.pg_stat_get_buf_fsync_backend()
  owner to postgres;

create function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_distance
;

comment on function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_tablespace(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_tablespace
;

comment on function pg_catalog.pg_stat_get_db_conflict_tablespace(oid)
is 'statistics: recovery conflicts in database caused by drop tablespace';

alter function pg_catalog.pg_stat_get_db_conflict_tablespace(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_lock(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_lock
;

comment on function pg_catalog.pg_stat_get_db_conflict_lock(oid)
is 'statistics: recovery conflicts in database caused by relation lock';

alter function pg_catalog.pg_stat_get_db_conflict_lock(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_snapshot(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_snapshot
;

comment on function pg_catalog.pg_stat_get_db_conflict_snapshot(oid)
is 'statistics: recovery conflicts in database caused by snapshot expiry';

alter function pg_catalog.pg_stat_get_db_conflict_snapshot(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_bufferpin
;

comment on function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid)
is 'statistics: recovery conflicts in database caused by shared buffer pin';

alter function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_startup_deadlock
;

comment on function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid)
is 'statistics: recovery conflicts in database caused by buffer deadlock';

alter function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_all(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_all
;

comment on function pg_catalog.pg_stat_get_db_conflict_all(oid)
is 'statistics: recovery conflicts in database';

alter function pg_catalog.pg_stat_get_db_conflict_all(oid)
  owner to postgres;

create function pg_catalog.pg_wal_replay_pause()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_wal_replay_pause
;

comment on function pg_catalog.pg_wal_replay_pause()
is 'pause wal replay';

alter function pg_catalog.pg_wal_replay_pause()
  owner to postgres;

create function pg_catalog.pg_wal_replay_resume()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_wal_replay_resume
;

comment on function pg_catalog.pg_wal_replay_resume()
is 'resume wal replay, if it was paused';

alter function pg_catalog.pg_wal_replay_resume()
  owner to postgres;

create function pg_catalog.pg_is_wal_replay_paused()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_wal_replay_paused
;

comment on function pg_catalog.pg_is_wal_replay_paused()
is 'true if wal replay is paused';

alter function pg_catalog.pg_is_wal_replay_paused()
  owner to postgres;

create function pg_catalog.pg_stat_get_db_stat_reset_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_stat_reset_time
;

comment on function pg_catalog.pg_stat_get_db_stat_reset_time(oid)
is 'statistics: last reset for a database';

alter function pg_catalog.pg_stat_get_db_stat_reset_time(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_stat_reset_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_stat_reset_time
;

comment on function pg_catalog.pg_stat_get_bgwriter_stat_reset_time()
is 'statistics: last reset for the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_stat_reset_time()
  owner to postgres;

create function pg_catalog.ginarrayextract(anyarray, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarrayextract
;

comment on function pg_catalog.ginarrayextract(anyarray, internal)
is 'GIN array support (obsolete)';

alter function pg_catalog.ginarrayextract(anyarray, internal)
  owner to postgres;

create function pg_catalog.gin_extract_tsvector(tsvector, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsvector
;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal)
is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsvector(tsvector, internal)
  owner to postgres;

create function pg_catalog.pg_sequence_parameters(sequence_oid oid, out start_value bigint, out minimum_value bigint,
                                                                    out maximum_value bigint, out increment bigint,
                                                                    out cycle_option boolean, out cache_size bigint,
                                                                    out data_type oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_sequence_parameters
;

comment on function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean,
                                                           out bigint, out oid)
is 'sequence parameters, for use by information schema';

alter function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean, out bigint, out oid)
  owner to postgres;

create function pg_catalog.pg_available_extensions(out name name, out default_version text, out comment text)
stable
strict
parallel safe
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_available_extensions
;

comment on function pg_catalog.pg_available_extensions(out name, out text, out text)
is 'list available extensions';

alter function pg_catalog.pg_available_extensions(out name, out text, out text)
  owner to postgres;

create function pg_catalog.pg_available_extension_versions(out name        name, out version text,
                                                           out superuser   boolean, out relocatable boolean,
                                                           out schema      name, out requires name [], out comment text)
stable
strict
parallel safe
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_available_extension_versions
;

comment on function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out name,
                                                               out name [], out text)
is 'list available extension versions';

alter function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out name, out name [], out text)
  owner to postgres;

create function pg_catalog.pg_extension_update_paths(name name, out source text, out target text, out path text)
stable
strict
parallel safe
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_extension_update_paths
;

comment on function pg_catalog.pg_extension_update_paths(name, out text, out text, out text)
is 'list an extension''s version update paths';

alter function pg_catalog.pg_extension_update_paths(name, out text, out text, out text)
  owner to postgres;

create function pg_catalog.pg_extension_config_dump(regclass, text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_extension_config_dump
;

comment on function pg_catalog.pg_extension_config_dump(regclass, text)
is 'flag an extension''s table contents to be emitted by pg_dump';

alter function pg_catalog.pg_extension_config_dump(regclass, text)
  owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsquery
;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal)
is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal)
  owner to postgres;

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_consistent
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal)
is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal)
  owner to postgres;

create function pg_catalog.pg_advisory_xact_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock
;

comment on function pg_catalog.pg_advisory_xact_lock(bigint)
is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock(bigint)
  owner to postgres;

create function pg_catalog.pg_advisory_xact_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_advisory_xact_lock_shared(bigint)
is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared(bigint)
  owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock
;

comment on function pg_catalog.pg_try_advisory_xact_lock(bigint)
is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock(bigint)
  owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(bigint)
is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared(bigint)
  owner to postgres;

create function pg_catalog.pg_advisory_xact_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock
;

comment on function pg_catalog.pg_advisory_xact_lock(integer, integer)
is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock(integer, integer)
  owner to postgres;

create function pg_catalog.pg_advisory_xact_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_advisory_xact_lock_shared(integer, integer)
is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared(integer, integer)
  owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock
;

comment on function pg_catalog.pg_try_advisory_xact_lock(integer, integer)
is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock(integer, integer)
  owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer)
is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer)
  owner to postgres;

create function pg_catalog.varchar_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchar_transform
;

comment on function pg_catalog.varchar_transform(internal)
is 'transform a varchar length coercion';

alter function pg_catalog.varchar_transform(internal)
  owner to postgres;

create function pg_catalog.pg_create_restore_point(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_create_restore_point
;

comment on function pg_catalog.pg_create_restore_point(text)
is 'create a named restore point';

alter function pg_catalog.pg_create_restore_point(text)
  owner to postgres;

create function pg_catalog.pg_stat_get_wal_senders(out pid        integer, out state text, out sent_lsn pg_lsn,
                                                   out write_lsn  pg_lsn, out flush_lsn pg_lsn, out replay_lsn pg_lsn,
                                                   out write_lag  interval, out flush_lag interval,
                                                   out replay_lag interval, out sync_priority integer,
                                                   out sync_state text)
stable
parallel restricted
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.pg_stat_get_wal_senders
;

comment on function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn,
                                                       out pg_lsn, out interval, out interval, out interval,
                                                       out integer, out text)
is 'statistics: information about currently active replication';

alter function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn, out pg_lsn, out interval, out interval, out interval, out integer, out text)
  owner to postgres;

create function pg_catalog.row_number()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_number
;

comment on function pg_catalog.row_number()
is 'row number within partition';

alter function pg_catalog.row_number()
  owner to postgres;

create function pg_catalog.rank()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rank
;

comment on function pg_catalog.rank()
is 'integer rank with gaps';

alter function pg_catalog.rank()
  owner to postgres;

create function pg_catalog.dense_rank()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dense_rank
;

comment on function pg_catalog.dense_rank()
is 'integer rank without gaps';

alter function pg_catalog.dense_rank()
  owner to postgres;

create function pg_catalog.percent_rank()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percent_rank
;

comment on function pg_catalog.percent_rank()
is 'fractional rank within partition';

alter function pg_catalog.percent_rank()
  owner to postgres;

create function pg_catalog.cume_dist()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cume_dist
;

comment on function pg_catalog.cume_dist()
is 'fractional row number within partition';

alter function pg_catalog.cume_dist()
  owner to postgres;

create function pg_catalog.ntile(integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ntile
;

comment on function pg_catalog.ntile(integer)
is 'split rows into N groups';

alter function pg_catalog.ntile(integer)
  owner to postgres;

create function pg_catalog.lag(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lag
;

comment on function pg_catalog.lag(anyelement)
is 'fetch the preceding row value';

alter function pg_catalog.lag(anyelement)
  owner to postgres;

create function pg_catalog.lag(anyelement, integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lag
;

comment on function pg_catalog.lag(anyelement, integer)
is 'fetch the Nth preceding row value';

alter function pg_catalog.lag(anyelement, integer)
  owner to postgres;

create function pg_catalog.lag(anyelement, integer, anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lag
;

comment on function pg_catalog.lag(anyelement, integer, anyelement)
is 'fetch the Nth preceding row value with default';

alter function pg_catalog.lag(anyelement, integer, anyelement)
  owner to postgres;

create function pg_catalog.lead(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lead
;

comment on function pg_catalog.lead(anyelement)
is 'fetch the following row value';

alter function pg_catalog.lead(anyelement)
  owner to postgres;

create function pg_catalog.lead(anyelement, integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lead
;

comment on function pg_catalog.lead(anyelement, integer)
is 'fetch the Nth following row value';

alter function pg_catalog.lead(anyelement, integer)
  owner to postgres;

create function pg_catalog.lead(anyelement, integer, anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lead
;

comment on function pg_catalog.lead(anyelement, integer, anyelement)
is 'fetch the Nth following row value with default';

alter function pg_catalog.lead(anyelement, integer, anyelement)
  owner to postgres;

create function pg_catalog.first_value(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.first_value
;

comment on function pg_catalog.first_value(anyelement)
is 'fetch the first row value';

alter function pg_catalog.first_value(anyelement)
  owner to postgres;

create function pg_catalog.last_value(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.last_value
;

comment on function pg_catalog.last_value(anyelement)
is 'fetch the last row value';

alter function pg_catalog.last_value(anyelement)
  owner to postgres;

create function pg_catalog.nth_value(anyelement, integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nth_value
;

comment on function pg_catalog.nth_value(anyelement, integer)
is 'fetch the Nth row value';

alter function pg_catalog.nth_value(anyelement, integer)
  owner to postgres;

create function pg_catalog.fdw_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fdw_handler_in
;

comment on function pg_catalog.fdw_handler_in(cstring)
is 'I/O';

alter function pg_catalog.fdw_handler_in(cstring)
  owner to postgres;

create function pg_catalog.fdw_handler_out(fdw_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fdw_handler_out
;

comment on function pg_catalog.fdw_handler_out(fdw_handler)
is 'I/O';

alter function pg_catalog.fdw_handler_out(fdw_handler)
  owner to postgres;

create function pg_catalog.void_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_recv
;

comment on function pg_catalog.void_recv(internal)
is 'I/O';

alter function pg_catalog.void_recv(internal)
  owner to postgres;

create function pg_catalog.void_send(void)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_send
;

comment on function pg_catalog.void_send(void)
is 'I/O';

alter function pg_catalog.void_send(void)
  owner to postgres;

create function pg_catalog.btint2sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint2sortsupport
;

comment on function pg_catalog.btint2sortsupport(internal)
is 'sort support';

alter function pg_catalog.btint2sortsupport(internal)
  owner to postgres;

create function pg_catalog.btint4sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint4sortsupport
;

comment on function pg_catalog.btint4sortsupport(internal)
is 'sort support';

alter function pg_catalog.btint4sortsupport(internal)
  owner to postgres;

create function pg_catalog.btint8sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint8sortsupport
;

comment on function pg_catalog.btint8sortsupport(internal)
is 'sort support';

alter function pg_catalog.btint8sortsupport(internal)
  owner to postgres;

create function pg_catalog.btfloat4sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat4sortsupport
;

comment on function pg_catalog.btfloat4sortsupport(internal)
is 'sort support';

alter function pg_catalog.btfloat4sortsupport(internal)
  owner to postgres;

create function pg_catalog.btfloat8sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat8sortsupport
;

comment on function pg_catalog.btfloat8sortsupport(internal)
is 'sort support';

alter function pg_catalog.btfloat8sortsupport(internal)
  owner to postgres;

create function pg_catalog.btoidsortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btoidsortsupport
;

comment on function pg_catalog.btoidsortsupport(internal)
is 'sort support';

alter function pg_catalog.btoidsortsupport(internal)
  owner to postgres;

create function pg_catalog.btnamesortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btnamesortsupport
;

comment on function pg_catalog.btnamesortsupport(internal)
is 'sort support';

alter function pg_catalog.btnamesortsupport(internal)
  owner to postgres;

create function pg_catalog.date_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_sortsupport
;

comment on function pg_catalog.date_sortsupport(internal)
is 'sort support';

alter function pg_catalog.date_sortsupport(internal)
  owner to postgres;

create function pg_catalog.timestamp_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_sortsupport
;

comment on function pg_catalog.timestamp_sortsupport(internal)
is 'sort support';

alter function pg_catalog.timestamp_sortsupport(internal)
  owner to postgres;

create function pg_catalog.has_type_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(name, text, text)
is 'user privilege on type by username, type name';

alter function pg_catalog.has_type_privilege(name, text, text)
  owner to postgres;

create function pg_catalog.has_type_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(name, oid, text)
is 'user privilege on type by username, type oid';

alter function pg_catalog.has_type_privilege(name, oid, text)
  owner to postgres;

create function pg_catalog.has_type_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(oid, text, text)
is 'user privilege on type by user oid, type name';

alter function pg_catalog.has_type_privilege(oid, text, text)
  owner to postgres;

create function pg_catalog.has_type_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(oid, oid, text)
is 'user privilege on type by user oid, type oid';

alter function pg_catalog.has_type_privilege(oid, oid, text)
  owner to postgres;

create function pg_catalog.has_type_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(text, text)
is 'current user privilege on type by type name';

alter function pg_catalog.has_type_privilege(text, text)
  owner to postgres;

create function pg_catalog.has_type_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(oid, text)
is 'current user privilege on type by type oid';

alter function pg_catalog.has_type_privilege(oid, text)
  owner to postgres;

create function pg_catalog.macaddr_not(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_not
;

comment on function pg_catalog.macaddr_not(macaddr)
is 'implementation of ~ operator';

alter function pg_catalog.macaddr_not(macaddr)
  owner to postgres;

create function pg_catalog.macaddr_and(macaddr, macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_and
;

comment on function pg_catalog.macaddr_and(macaddr, macaddr)
is 'implementation of & operator';

alter function pg_catalog.macaddr_and(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.macaddr_or(macaddr, macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_or
;

comment on function pg_catalog.macaddr_or(macaddr, macaddr)
is 'implementation of | operator';

alter function pg_catalog.macaddr_or(macaddr, macaddr)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_temp_files(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_temp_files
;

comment on function pg_catalog.pg_stat_get_db_temp_files(oid)
is 'statistics: number of temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_files(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_temp_bytes(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_temp_bytes
;

comment on function pg_catalog.pg_stat_get_db_temp_bytes(oid)
is 'statistics: number of bytes in temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_bytes(oid)
  owner to postgres;

create function pg_catalog.pg_stat_get_db_deadlocks(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_deadlocks
;

comment on function pg_catalog.pg_stat_get_db_deadlocks(oid)
is 'statistics: deadlocks detected in database';

alter function pg_catalog.pg_stat_get_db_deadlocks(oid)
  owner to postgres;

create function pg_catalog.array_to_json(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_json
;

comment on function pg_catalog.array_to_json(anyarray)
is 'map array to json';

alter function pg_catalog.array_to_json(anyarray)
  owner to postgres;

create function pg_catalog.array_to_json(anyarray, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_json
;

comment on function pg_catalog.array_to_json(anyarray, boolean)
is 'map array to json with optional pretty printing';

alter function pg_catalog.array_to_json(anyarray, boolean)
  owner to postgres;

create function pg_catalog.row_to_json(record)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_to_json
;

comment on function pg_catalog.row_to_json(record)
is 'map row to json';

alter function pg_catalog.row_to_json(record)
  owner to postgres;

create function pg_catalog.row_to_json(record, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_to_json
;

comment on function pg_catalog.row_to_json(record, boolean)
is 'map row to json with optional pretty printing';

alter function pg_catalog.row_to_json(record, boolean)
  owner to postgres;

create function pg_catalog.numeric_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_transform
;

comment on function pg_catalog.numeric_transform(internal)
is 'transform a numeric length coercion';

alter function pg_catalog.numeric_transform(internal)
  owner to postgres;

create function pg_catalog.varbit_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_transform
;

comment on function pg_catalog.varbit_transform(internal)
is 'transform a varbit length coercion';

alter function pg_catalog.varbit_transform(internal)
  owner to postgres;

create function pg_catalog.pg_get_viewdef(oid, integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(oid, integer)
is 'select statement of a view with pretty-printing and specified line wrapping';

alter function pg_catalog.pg_get_viewdef(oid, integer)
  owner to postgres;

create function pg_catalog.pg_stat_get_checkpoint_write_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_checkpoint_write_time
;

comment on function pg_catalog.pg_stat_get_checkpoint_write_time()
is 'statistics: checkpoint time spent writing buffers to disk, in milliseconds';

alter function pg_catalog.pg_stat_get_checkpoint_write_time()
  owner to postgres;

create function pg_catalog.pg_stat_get_checkpoint_sync_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_checkpoint_sync_time
;

comment on function pg_catalog.pg_stat_get_checkpoint_sync_time()
is 'statistics: checkpoint time spent synchronizing buffers to disk, in milliseconds';

alter function pg_catalog.pg_stat_get_checkpoint_sync_time()
  owner to postgres;

create function pg_catalog.pg_collation_for("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_collation_for
;

comment on function pg_catalog.pg_collation_for("any")
is 'collation of the argument; implementation of the COLLATION FOR expression';

alter function pg_catalog.pg_collation_for("any")
  owner to postgres;

create function pg_catalog.pg_trigger_depth()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_trigger_depth
;

comment on function pg_catalog.pg_trigger_depth()
is 'current trigger depth';

alter function pg_catalog.pg_trigger_depth()
  owner to postgres;

create function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_wal_lsn_diff
;

comment on function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn)
is 'difference in bytes, given two wal locations';

alter function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_size_pretty(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_size_pretty
;

comment on function pg_catalog.pg_size_pretty(numeric)
is 'convert a numeric to a human readable text using size units';

alter function pg_catalog.pg_size_pretty(numeric)
  owner to postgres;

create function pg_catalog.array_remove(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_remove
;

comment on function pg_catalog.array_remove(anyarray, anyelement)
is 'remove any occurrences of an element from an array';

alter function pg_catalog.array_remove(anyarray, anyelement)
  owner to postgres;

create function pg_catalog.array_replace(anyarray, anyelement, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_replace
;

comment on function pg_catalog.array_replace(anyarray, anyelement, anyelement)
is 'replace any occurrences of an element in an array';

alter function pg_catalog.array_replace(anyarray, anyelement, anyelement)
  owner to postgres;

create function pg_catalog.rangesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rangesel
;

comment on function pg_catalog.rangesel(internal, oid, internal, integer)
is 'restriction selectivity for range operators';

alter function pg_catalog.rangesel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.lo_lseek64(integer, bigint, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_lseek64
;

comment on function pg_catalog.lo_lseek64(integer, bigint, integer)
is 'large object seek (64 bit)';

alter function pg_catalog.lo_lseek64(integer, bigint, integer)
  owner to postgres;

create function pg_catalog.lo_tell64(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_tell64
;

comment on function pg_catalog.lo_tell64(integer)
is 'large object position (64 bit)';

alter function pg_catalog.lo_tell64(integer)
  owner to postgres;

create function pg_catalog.lo_truncate64(integer, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_truncate64
;

comment on function pg_catalog.lo_truncate64(integer, bigint)
is 'truncate large object (64 bit)';

alter function pg_catalog.lo_truncate64(integer, bigint)
  owner to postgres;

create function pg_catalog.json_agg_transfn(internal, anyelement)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_agg_transfn
;

comment on function pg_catalog.json_agg_transfn(internal, anyelement)
is 'json aggregate transition function';

alter function pg_catalog.json_agg_transfn(internal, anyelement)
  owner to postgres;

create function pg_catalog.json_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_agg_finalfn
;

comment on function pg_catalog.json_agg_finalfn(internal)
is 'json aggregate final function';

alter function pg_catalog.json_agg_finalfn(internal)
  owner to postgres;

create function pg_catalog.to_json(anyelement)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_json
;

comment on function pg_catalog.to_json(anyelement)
is 'map input to json';

alter function pg_catalog.to_json(anyelement)
  owner to postgres;

create function pg_catalog.pg_stat_get_mod_since_analyze(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_mod_since_analyze
;

comment on function pg_catalog.pg_stat_get_mod_since_analyze(oid)
is 'statistics: number of tuples changed since last analyze';

alter function pg_catalog.pg_stat_get_mod_since_analyze(oid)
  owner to postgres;

create function pg_catalog.numeric_sum(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sum
;

comment on function pg_catalog.numeric_sum(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_sum(internal)
  owner to postgres;

create function pg_catalog.cardinality(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cardinality
;

comment on function pg_catalog.cardinality(anyarray)
is 'array cardinality';

alter function pg_catalog.cardinality(anyarray)
  owner to postgres;

create function pg_catalog.json_object_agg_transfn(internal, "any", "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_agg_transfn
;

comment on function pg_catalog.json_object_agg_transfn(internal, "any", "any")
is 'json object aggregate transition function';

alter function pg_catalog.json_object_agg_transfn(internal, "any", "any")
  owner to postgres;

create function pg_catalog.record_image_eq(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_eq
;

comment on function pg_catalog.record_image_eq(record, record)
is 'implementation of *= operator';

alter function pg_catalog.record_image_eq(record, record)
  owner to postgres;

create function pg_catalog.record_image_ne(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_ne
;

comment on function pg_catalog.record_image_ne(record, record)
is 'implementation of *<> operator';

alter function pg_catalog.record_image_ne(record, record)
  owner to postgres;

create function pg_catalog.record_image_lt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_lt
;

comment on function pg_catalog.record_image_lt(record, record)
is 'implementation of *< operator';

alter function pg_catalog.record_image_lt(record, record)
  owner to postgres;

create function pg_catalog.record_image_gt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_gt
;

comment on function pg_catalog.record_image_gt(record, record)
is 'implementation of *> operator';

alter function pg_catalog.record_image_gt(record, record)
  owner to postgres;

create function pg_catalog.record_image_le(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_le
;

comment on function pg_catalog.record_image_le(record, record)
is 'implementation of *<= operator';

alter function pg_catalog.record_image_le(record, record)
  owner to postgres;

create function pg_catalog.record_image_ge(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_ge
;

comment on function pg_catalog.record_image_ge(record, record)
is 'implementation of *>= operator';

alter function pg_catalog.record_image_ge(record, record)
  owner to postgres;

create function pg_catalog.btrecordimagecmp(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrecordimagecmp
;

comment on function pg_catalog.btrecordimagecmp(record, record)
is 'less-equal-greater based on byte images';

alter function pg_catalog.btrecordimagecmp(record, record)
  owner to postgres;

create function pg_catalog.pg_stat_get_archiver(out archived_count     bigint, out last_archived_wal text,
                                                out last_archived_time timestamp with time zone,
                                                out failed_count       bigint, out last_failed_wal text,
                                                out last_failed_time   timestamp with time zone,
                                                out stats_reset        timestamp with time zone)
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_archiver
;

comment on function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint,
                                                    out text, out timestamp with time zone,
                                                    out timestamp with time zone)
is 'statistics: information about WAL archiver';

alter function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint, out text, out timestamp with time zone, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.json_object_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_agg_finalfn
;

comment on function pg_catalog.json_object_agg_finalfn(internal)
is 'json object aggregate final function';

alter function pg_catalog.json_object_agg_finalfn(internal)
  owner to postgres;

create function pg_catalog.json_build_array("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_array
;

comment on function pg_catalog.json_build_array("any")
is 'build a json array from any inputs';

alter function pg_catalog.json_build_array("any")
  owner to postgres;

create function pg_catalog.json_build_array()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_array
;

comment on function pg_catalog.json_build_array()
is 'build an empty json array';

alter function pg_catalog.json_build_array()
  owner to postgres;

create function pg_catalog.json_build_object("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_object
;

comment on function pg_catalog.json_build_object("any")
is 'build a json object from pairwise key/value inputs';

alter function pg_catalog.json_build_object("any")
  owner to postgres;

create function pg_catalog.json_build_object()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_object
;

comment on function pg_catalog.json_build_object()
is 'build an empty json object';

alter function pg_catalog.json_build_object()
  owner to postgres;

create function pg_catalog.json_object(text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object
;

comment on function pg_catalog.json_object(text [])
is 'map text array of key value pairs to json object';

alter function pg_catalog.json_object(text [])
  owner to postgres;

create function pg_catalog.json_object(text [], text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object
;

comment on function pg_catalog.json_object(text [], text [])
is 'map text arrays of keys and values to json object';

alter function pg_catalog.json_object(text [], text [])
  owner to postgres;

create function pg_catalog.json_to_record(json)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_to_record
;

comment on function pg_catalog.json_to_record(json)
is 'get record fields from a json object';

alter function pg_catalog.json_to_record(json)
  owner to postgres;

create function pg_catalog.json_to_recordset(json)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_to_recordset
;

comment on function pg_catalog.json_to_recordset(json)
is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_to_recordset(json)
  owner to postgres;

create function pg_catalog.jsonb_array_length(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_array_length
;

comment on function pg_catalog.jsonb_array_length(jsonb)
is 'length of jsonb array';

alter function pg_catalog.jsonb_array_length(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_each(from_json jsonb, out key text, out value jsonb)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_each
;

comment on function pg_catalog.jsonb_each(jsonb, out text, out jsonb)
is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each(jsonb, out text, out jsonb)
  owner to postgres;

create function pg_catalog.jsonb_populate_record(anyelement, jsonb)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_populate_record
;

comment on function pg_catalog.jsonb_populate_record(anyelement, jsonb)
is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_populate_record(anyelement, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_typeof(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_typeof
;

comment on function pg_catalog.jsonb_typeof(jsonb)
is 'get the type of a jsonb value';

alter function pg_catalog.jsonb_typeof(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_object_field_text(from_json jsonb, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_field_text
;

comment on function pg_catalog.jsonb_object_field_text(jsonb, text)
is 'implementation of ->> operator';

alter function pg_catalog.jsonb_object_field_text(jsonb, text)
  owner to postgres;

create function pg_catalog.jsonb_array_element(from_json jsonb, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_array_element
;

comment on function pg_catalog.jsonb_array_element(jsonb, integer)
is 'implementation of -> operator';

alter function pg_catalog.jsonb_array_element(jsonb, integer)
  owner to postgres;

create function pg_catalog.jsonb_array_element_text(from_json jsonb, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_array_element_text
;

comment on function pg_catalog.jsonb_array_element_text(jsonb, integer)
is 'implementation of ->> operator';

alter function pg_catalog.jsonb_array_element_text(jsonb, integer)
  owner to postgres;

create function pg_catalog.jsonb_extract_path(from_json jsonb, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_extract_path
;

comment on function pg_catalog.jsonb_extract_path(jsonb, text [])
is 'get value from jsonb with path elements';

alter function pg_catalog.jsonb_extract_path(jsonb, text [])
  owner to postgres;

create function pg_catalog.width_bucket(anyelement, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width_bucket
;

comment on function pg_catalog.width_bucket(anyelement, anyarray)
is 'bucket number of operand given a sorted array of bucket lower bounds';

alter function pg_catalog.width_bucket(anyelement, anyarray)
  owner to postgres;

create function pg_catalog.jsonb_array_elements(from_json jsonb, out value jsonb)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_array_elements
;

comment on function pg_catalog.jsonb_array_elements(jsonb, out jsonb)
is 'elements of a jsonb array';

alter function pg_catalog.jsonb_array_elements(jsonb, out jsonb)
  owner to postgres;

create function pg_catalog.pg_lsn_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_in
;

comment on function pg_catalog.pg_lsn_in(cstring)
is 'I/O';

alter function pg_catalog.pg_lsn_in(cstring)
  owner to postgres;

create function pg_catalog.pg_lsn_out(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_out
;

comment on function pg_catalog.pg_lsn_out(pg_lsn)
is 'I/O';

alter function pg_catalog.pg_lsn_out(pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_lt
;

comment on function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn)
is 'implementation of < operator';

alter function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_le
;

comment on function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn)
is 'implementation of <= operator';

alter function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_eq
;

comment on function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn)
is 'implementation of = operator';

alter function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_ge
;

comment on function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn)
is 'implementation of >= operator';

alter function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_gt
;

comment on function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn)
is 'implementation of > operator';

alter function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_ne
;

comment on function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn)
is 'implementation of <> operator';

alter function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_mi
;

comment on function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn)
is 'implementation of - operator';

alter function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_recv
;

comment on function pg_catalog.pg_lsn_recv(internal)
is 'I/O';

alter function pg_catalog.pg_lsn_recv(internal)
  owner to postgres;

create function pg_catalog.pg_lsn_send(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_send
;

comment on function pg_catalog.pg_lsn_send(pg_lsn)
is 'I/O';

alter function pg_catalog.pg_lsn_send(pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_cmp
;

comment on function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn)
is 'less-equal-greater';

alter function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_lsn_hash(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_hash
;

comment on function pg_catalog.pg_lsn_hash(pg_lsn)
is 'hash';

alter function pg_catalog.pg_lsn_hash(pg_lsn)
  owner to postgres;

create function pg_catalog.bttextsortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttextsortsupport
;

comment on function pg_catalog.bttextsortsupport(internal)
is 'sort support';

alter function pg_catalog.bttextsortsupport(internal)
  owner to postgres;

create function pg_catalog.generate_series(numeric, numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(numeric, numeric, numeric)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric, numeric)
  owner to postgres;

create function pg_catalog.generate_series(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(numeric, numeric)
is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric)
  owner to postgres;

create function pg_catalog.json_strip_nulls(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_strip_nulls
;

comment on function pg_catalog.json_strip_nulls(json)
is 'remove object fields with null values from json';

alter function pg_catalog.json_strip_nulls(json)
  owner to postgres;

create function pg_catalog.jsonb_strip_nulls(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_strip_nulls
;

comment on function pg_catalog.jsonb_strip_nulls(jsonb)
is 'remove object fields with null values from jsonb';

alter function pg_catalog.jsonb_strip_nulls(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_object(text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object
;

comment on function pg_catalog.jsonb_object(text [])
is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object(text [])
  owner to postgres;

create function pg_catalog.jsonb_object(text [], text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object
;

comment on function pg_catalog.jsonb_object(text [], text [])
is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object(text [], text [])
  owner to postgres;

create function pg_catalog.jsonb_agg_transfn(internal, anyelement)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_agg_transfn
;

comment on function pg_catalog.jsonb_agg_transfn(internal, anyelement)
is 'jsonb aggregate transition function';

alter function pg_catalog.jsonb_agg_transfn(internal, anyelement)
  owner to postgres;

create function pg_catalog.jsonb_agg_finalfn(internal)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_agg_finalfn
;

comment on function pg_catalog.jsonb_agg_finalfn(internal)
is 'jsonb aggregate final function';

alter function pg_catalog.jsonb_agg_finalfn(internal)
  owner to postgres;

create function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_agg_transfn
;

comment on function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any")
is 'jsonb object aggregate transition function';

alter function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any")
  owner to postgres;

create function pg_catalog.jsonb_object_agg_finalfn(internal)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_agg_finalfn
;

comment on function pg_catalog.jsonb_object_agg_finalfn(internal)
is 'jsonb object aggregate final function';

alter function pg_catalog.jsonb_object_agg_finalfn(internal)
  owner to postgres;

create function pg_catalog.jsonb_build_array("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_array
;

comment on function pg_catalog.jsonb_build_array("any")
is 'build a jsonb array from any inputs';

alter function pg_catalog.jsonb_build_array("any")
  owner to postgres;

create function pg_catalog.jsonb_build_array()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_array
;

comment on function pg_catalog.jsonb_build_array()
is 'build an empty jsonb array';

alter function pg_catalog.jsonb_build_array()
  owner to postgres;

create function pg_catalog.jsonb_build_object("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_object
;

comment on function pg_catalog.jsonb_build_object("any")
is 'build a jsonb object from pairwise key/value inputs';

alter function pg_catalog.jsonb_build_object("any")
  owner to postgres;

create function pg_catalog.jsonb_build_object()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_object
;

comment on function pg_catalog.jsonb_build_object()
is 'build an empty jsonb object';

alter function pg_catalog.jsonb_build_object()
  owner to postgres;

create function pg_catalog.dist_ppoly(point, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_ppoly
;

comment on function pg_catalog.dist_ppoly(point, polygon)
is 'implementation of <-> operator';

alter function pg_catalog.dist_ppoly(point, polygon)
  owner to postgres;

create function pg_catalog.array_position(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_position
;

comment on function pg_catalog.array_position(anyarray, anyelement)
is 'returns an offset of value in array';

alter function pg_catalog.array_position(anyarray, anyelement)
  owner to postgres;

create function pg_catalog.array_position(anyarray, anyelement, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_position
;

comment on function pg_catalog.array_position(anyarray, anyelement, integer)
is 'returns an offset of value in array with start index';

alter function pg_catalog.array_position(anyarray, anyelement, integer)
  owner to postgres;

create function pg_catalog.array_positions(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_positions
;

comment on function pg_catalog.array_positions(anyarray, anyelement)
is 'returns an array of offsets of some value in array';

alter function pg_catalog.array_positions(anyarray, anyelement)
  owner to postgres;

create function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_circle_distance
;

comment on function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.gist_box_fetch(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_fetch
;

comment on function pg_catalog.gist_box_fetch(internal)
is 'GiST support';

alter function pg_catalog.gist_box_fetch(internal)
  owner to postgres;

create function pg_catalog.gist_point_fetch(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_fetch
;

comment on function pg_catalog.gist_point_fetch(internal)
is 'GiST support';

alter function pg_catalog.gist_point_fetch(internal)
  owner to postgres;

create function pg_catalog.numeric_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sortsupport
;

comment on function pg_catalog.numeric_sortsupport(internal)
is 'sort support';

alter function pg_catalog.numeric_sortsupport(internal)
  owner to postgres;

create function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_poly_distance
;

comment on function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.dist_cpoint(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_cpoint
;

comment on function pg_catalog.dist_cpoint(circle, point)
is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoint(circle, point)
  owner to postgres;

create function pg_catalog.dist_polyp(polygon, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_polyp
;

comment on function pg_catalog.dist_polyp(polygon, point)
is 'implementation of <-> operator';

alter function pg_catalog.dist_polyp(polygon, point)
  owner to postgres;

create function pg_catalog.pg_read_file(text, bigint, bigint, boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_file
;

comment on function pg_catalog.pg_read_file(text, bigint, bigint, boolean)
is 'read text from a file';

alter function pg_catalog.pg_read_file(text, bigint, bigint, boolean)
  owner to postgres;

create function pg_catalog.current_setting(text, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_setting
;

comment on function pg_catalog.current_setting(text, boolean)
is 'SHOW X as a function, optionally no error for missing variable';

alter function pg_catalog.current_setting(text, boolean)
  owner to postgres;

create function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_binary_file
;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean)
is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean)
  owner to postgres;

create function pg_catalog.pg_notification_queue_usage()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_notification_queue_usage
;

comment on function pg_catalog.pg_notification_queue_usage()
is 'get the fraction of the asynchronous notification queue currently in use';

alter function pg_catalog.pg_notification_queue_usage()
  owner to postgres;

create function pg_catalog.pg_ls_dir(text, boolean, boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ls_dir
;

comment on function pg_catalog.pg_ls_dir(text, boolean, boolean)
is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir(text, boolean, boolean)
  owner to postgres;

create function pg_catalog.row_security_active(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_security_active
;

comment on function pg_catalog.row_security_active(oid)
is 'row security for current context active on table by table oid';

alter function pg_catalog.row_security_active(oid)
  owner to postgres;

create function pg_catalog.row_security_active(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_security_active
;

comment on function pg_catalog.row_security_active(text)
is 'row security for current context active on table by table name';

alter function pg_catalog.row_security_active(text)
  owner to postgres;

create function pg_catalog.uuid_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_sortsupport
;

comment on function pg_catalog.uuid_sortsupport(internal)
is 'sort support';

alter function pg_catalog.uuid_sortsupport(internal)
  owner to postgres;

create function pg_catalog.jsonb_concat(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_concat
;

comment on function pg_catalog.jsonb_concat(jsonb, jsonb)
is 'implementation of || operator';

alter function pg_catalog.jsonb_concat(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_delete(jsonb, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete
;

comment on function pg_catalog.jsonb_delete(jsonb, text)
is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, text)
  owner to postgres;

create function pg_catalog.jsonb_delete(jsonb, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete
;

comment on function pg_catalog.jsonb_delete(jsonb, integer)
is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, integer)
  owner to postgres;

create function pg_catalog.jsonb_delete_path(jsonb, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete_path
;

comment on function pg_catalog.jsonb_delete_path(jsonb, text [])
is 'implementation of #- operator';

alter function pg_catalog.jsonb_delete_path(jsonb, text [])
  owner to postgres;

create function pg_catalog.jsonb_set(jsonb_in          jsonb, path text [], replacement jsonb,
                                     create_if_missing boolean default true)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_set
;

comment on function pg_catalog.jsonb_set(jsonb, text [], jsonb, boolean)
is 'Set part of a jsonb';

alter function pg_catalog.jsonb_set(jsonb, text [], jsonb, boolean)
  owner to postgres;

create function pg_catalog.jsonb_pretty(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_pretty
;

comment on function pg_catalog.jsonb_pretty(jsonb)
is 'Indented text from jsonb';

alter function pg_catalog.jsonb_pretty(jsonb)
  owner to postgres;

create function pg_catalog.pg_stat_file(filename text, missing_ok boolean, out size bigint,
                                                                           out access timestamp with time zone,
                                                                           out modification timestamp with time zone,
                                                                           out change timestamp with time zone,
                                                                           out creation timestamp with time zone,
                                                                           out isdir boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_file
;

comment on function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone,
                                                           out timestamp with time zone, out timestamp with time zone,
                                                           out timestamp with time zone, out boolean)
is 'get information about file';

alter function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean)
  owner to postgres;

create function pg_catalog.xidneq(xid, xid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidneq
;

comment on function pg_catalog.xidneq(xid, xid)
is 'implementation of <> operator';

alter function pg_catalog.xidneq(xid, xid)
  owner to postgres;

create function pg_catalog.xidneqint4(xid, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidneqint4
;

comment on function pg_catalog.xidneqint4(xid, integer)
is 'implementation of <> operator';

alter function pg_catalog.xidneqint4(xid, integer)
  owner to postgres;

create function pg_catalog.tsm_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsm_handler_in
;

comment on function pg_catalog.tsm_handler_in(cstring)
is 'I/O';

alter function pg_catalog.tsm_handler_in(cstring)
  owner to postgres;

create function pg_catalog.tsm_handler_out(tsm_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsm_handler_out
;

comment on function pg_catalog.tsm_handler_out(tsm_handler)
is 'I/O';

alter function pg_catalog.tsm_handler_out(tsm_handler)
  owner to postgres;

create function pg_catalog.bernoulli(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bernoulli
;

comment on function pg_catalog.bernoulli(internal)
is 'BERNOULLI tablesample method handler';

alter function pg_catalog.bernoulli(internal)
  owner to postgres;

create function pg_catalog.system(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.system
;

comment on function pg_catalog.system(internal)
is 'SYSTEM tablesample method handler';

alter function pg_catalog.system(internal)
  owner to postgres;

create function pg_catalog.pg_stat_get_wal_receiver(out pid                   integer, out status text,
                                                    out receive_start_lsn     pg_lsn, out receive_start_tli integer,
                                                    out received_lsn          pg_lsn, out received_tli integer,
                                                    out last_msg_send_time    timestamp with time zone,
                                                    out last_msg_receipt_time timestamp with time zone,
                                                    out latest_end_lsn        pg_lsn,
                                                    out latest_end_time       timestamp with time zone,
                                                    out slot_name             text, out conninfo text)
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_wal_receiver
;

comment on function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn,
                                                        out integer, out timestamp with time zone,
                                                        out timestamp with time zone, out pg_lsn,
                                                        out timestamp with time zone, out text, out text)
is 'statistics: information about WAL receiver';

alter function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn, out integer, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone, out text, out text)
  owner to postgres;

create function pg_catalog.pg_stat_get_progress_info(cmdtype text, out pid integer, out datid oid, out relid oid,
                                                                   out param1 bigint, out param2 bigint,
                                                                   out param3 bigint, out param4 bigint,
                                                                   out param5 bigint, out param6 bigint,
                                                                   out param7 bigint, out param8 bigint,
                                                                   out param9 bigint, out param10 bigint)
stable
strict
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_stat_get_progress_info
;

comment on function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint,
                                                               out bigint, out bigint, out bigint, out bigint,
                                                               out bigint, out bigint, out bigint, out bigint)
is 'statistics: information about progress of backends running maintenance command';

alter function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint)
  owner to postgres;

create function pg_catalog.ts_filter(tsvector, "char" [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_filter
;

comment on function pg_catalog.ts_filter(tsvector, "char" [])
is 'delete lexemes that do not have one of the given weights';

alter function pg_catalog.ts_filter(tsvector, "char" [])
  owner to postgres;

create function pg_catalog.setweight(tsvector, "char", text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.setweight
;

comment on function pg_catalog.setweight(tsvector, "char", text [])
is 'set given weight for given lexemes';

alter function pg_catalog.setweight(tsvector, "char", text [])
  owner to postgres;

create function pg_catalog.ts_delete(tsvector, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_delete
;

comment on function pg_catalog.ts_delete(tsvector, text)
is 'delete lexeme';

alter function pg_catalog.ts_delete(tsvector, text)
  owner to postgres;

create function pg_catalog.unnest(tsvector tsvector, out lexeme text, out positions smallint [], out weights text [])
immutable
strict
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.unnest
;

comment on function pg_catalog.unnest(tsvector, out text, out smallint [], out text [])
is 'expand tsvector to set of rows';

alter function pg_catalog.unnest(tsvector, out text, out smallint [], out text [])
  owner to postgres;

create function pg_catalog.ts_delete(tsvector, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_delete
;

comment on function pg_catalog.ts_delete(tsvector, text [])
is 'delete given lexemes';

alter function pg_catalog.ts_delete(tsvector, text [])
  owner to postgres;

create function pg_catalog.int4_avg_combine(bigint [], bigint [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_avg_combine
;

comment on function pg_catalog.int4_avg_combine(bigint [], bigint [])
is 'aggregate combine function';

alter function pg_catalog.int4_avg_combine(bigint [], bigint [])
  owner to postgres;

create function pg_catalog.interval_combine(interval [], interval [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_combine
;

comment on function pg_catalog.interval_combine(interval [], interval [])
is 'aggregate combine function';

alter function pg_catalog.interval_combine(interval [], interval [])
  owner to postgres;

create function pg_catalog.tsvector_to_array(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_to_array
;

comment on function pg_catalog.tsvector_to_array(tsvector)
is 'convert tsvector to array of lexemes';

alter function pg_catalog.tsvector_to_array(tsvector)
  owner to postgres;

create function pg_catalog.array_to_tsvector(text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_tsvector
;

comment on function pg_catalog.array_to_tsvector(text [])
is 'build tsvector from array of lexemes';

alter function pg_catalog.array_to_tsvector(text [])
  owner to postgres;

create function pg_catalog.bpchar_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_sortsupport
;

comment on function pg_catalog.bpchar_sortsupport(internal)
is 'sort support';

alter function pg_catalog.bpchar_sortsupport(internal)
  owner to postgres;

create function pg_catalog.pg_show_all_file_settings(out sourcefile text, out sourceline integer, out seqno integer,
                                                     out name       text, out setting text, out applied boolean,
                                                     out error      text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_show_all_file_settings
;

comment on function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text,
                                                         out boolean, out text)
is 'show config file settings';

alter function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text, out boolean, out text)
  owner to postgres;

create function pg_catalog.pg_current_wal_flush_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_wal_flush_lsn
;

comment on function pg_catalog.pg_current_wal_flush_lsn()
is 'current wal flush location';

alter function pg_catalog.pg_current_wal_flush_lsn()
  owner to postgres;

create function pg_catalog.bytea_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytea_sortsupport
;

comment on function pg_catalog.bytea_sortsupport(internal)
is 'sort support';

alter function pg_catalog.bytea_sortsupport(internal)
  owner to postgres;

create function pg_catalog.bttext_pattern_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttext_pattern_sortsupport
;

comment on function pg_catalog.bttext_pattern_sortsupport(internal)
is 'sort support';

alter function pg_catalog.bttext_pattern_sortsupport(internal)
  owner to postgres;

create function pg_catalog.btbpchar_pattern_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btbpchar_pattern_sortsupport
;

comment on function pg_catalog.btbpchar_pattern_sortsupport(internal)
is 'sort support';

alter function pg_catalog.btbpchar_pattern_sortsupport(internal)
  owner to postgres;

create function pg_catalog.pg_size_bytes(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_size_bytes
;

comment on function pg_catalog.pg_size_bytes(text)
is 'convert a size in human-readable format with size units into bytes';

alter function pg_catalog.pg_size_bytes(text)
  owner to postgres;

create function pg_catalog.numeric_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_serialize
;

comment on function pg_catalog.numeric_serialize(internal)
is 'aggregate serial function';

alter function pg_catalog.numeric_serialize(internal)
  owner to postgres;

create function pg_catalog.numeric_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_deserialize
;

comment on function pg_catalog.numeric_deserialize(bytea, internal)
is 'aggregate deserial function';

alter function pg_catalog.numeric_deserialize(bytea, internal)
  owner to postgres;

create function pg_catalog.numeric_avg_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_combine
;

comment on function pg_catalog.numeric_avg_combine(internal, internal)
is 'aggregate combine function';

alter function pg_catalog.numeric_avg_combine(internal, internal)
  owner to postgres;

create function pg_catalog.numeric_poly_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_combine
;

comment on function pg_catalog.numeric_poly_combine(internal, internal)
is 'aggregate combine function';

alter function pg_catalog.numeric_poly_combine(internal, internal)
  owner to postgres;

create function pg_catalog.numeric_poly_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_serialize
;

comment on function pg_catalog.numeric_poly_serialize(internal)
is 'aggregate serial function';

alter function pg_catalog.numeric_poly_serialize(internal)
  owner to postgres;

create function pg_catalog.numeric_poly_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_deserialize
;

comment on function pg_catalog.numeric_poly_deserialize(bytea, internal)
is 'aggregate deserial function';

alter function pg_catalog.numeric_poly_deserialize(bytea, internal)
  owner to postgres;

create function pg_catalog.numeric_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_combine
;

comment on function pg_catalog.numeric_combine(internal, internal)
is 'aggregate combine function';

alter function pg_catalog.numeric_combine(internal, internal)
  owner to postgres;

create function pg_catalog.float8_regr_combine(double precision [], double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_combine
;

comment on function pg_catalog.float8_regr_combine(double precision [], double precision [])
is 'aggregate combine function';

alter function pg_catalog.float8_regr_combine(double precision [], double precision [])
  owner to postgres;

create function pg_catalog.jsonb_delete(from_json jsonb, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete
;

comment on function pg_catalog.jsonb_delete(jsonb, text [])
is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, text [])
  owner to postgres;

create function pg_catalog.cash_mul_int8(money, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_int8
;

comment on function pg_catalog.cash_mul_int8(money, bigint)
is 'implementation of * operator';

alter function pg_catalog.cash_mul_int8(money, bigint)
  owner to postgres;

create function pg_catalog.cash_div_int8(money, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_int8
;

comment on function pg_catalog.cash_div_int8(money, bigint)
is 'implementation of / operator';

alter function pg_catalog.cash_div_int8(money, bigint)
  owner to postgres;

create function pg_catalog.txid_current_if_assigned()
stable
strict
cost 1
language internal
as
-- missing source code for pg_catalog.txid_current_if_assigned
;

comment on function pg_catalog.txid_current_if_assigned()
is 'get current transaction ID';

alter function pg_catalog.txid_current_if_assigned()
  owner to postgres;

create function pg_catalog.pg_get_partkeydef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_partkeydef
;

comment on function pg_catalog.pg_get_partkeydef(oid)
is 'partition key description';

alter function pg_catalog.pg_get_partkeydef(oid)
  owner to postgres;

create function pg_catalog.pg_ls_logdir(out name text, out size bigint, out modification timestamp with time zone)
strict
parallel safe
cost 10
rows 20
language internal
as
-- missing source code for pg_catalog.pg_ls_logdir
;

comment on function pg_catalog.pg_ls_logdir(out text, out bigint, out timestamp with time zone)
is 'list files in the log directory';

alter function pg_catalog.pg_ls_logdir(out text, out bigint, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.pg_ls_waldir(out name text, out size bigint, out modification timestamp with time zone)
strict
parallel safe
cost 10
rows 20
language internal
as
-- missing source code for pg_catalog.pg_ls_waldir
;

comment on function pg_catalog.pg_ls_waldir(out text, out bigint, out timestamp with time zone)
is 'list of files in the WAL directory';

alter function pg_catalog.pg_ls_waldir(out text, out bigint, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.pg_ndistinct_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_in
;

comment on function pg_catalog.pg_ndistinct_in(cstring)
is 'I/O';

alter function pg_catalog.pg_ndistinct_in(cstring)
  owner to postgres;

create function pg_catalog.pg_ndistinct_out(pg_ndistinct)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_out
;

comment on function pg_catalog.pg_ndistinct_out(pg_ndistinct)
is 'I/O';

alter function pg_catalog.pg_ndistinct_out(pg_ndistinct)
  owner to postgres;

create function pg_catalog.pg_ndistinct_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_recv
;

comment on function pg_catalog.pg_ndistinct_recv(internal)
is 'I/O';

alter function pg_catalog.pg_ndistinct_recv(internal)
  owner to postgres;

create function pg_catalog.pg_ndistinct_send(pg_ndistinct)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_send
;

comment on function pg_catalog.pg_ndistinct_send(pg_ndistinct)
is 'I/O';

alter function pg_catalog.pg_ndistinct_send(pg_ndistinct)
  owner to postgres;

create function pg_catalog.macaddr_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_sortsupport
;

comment on function pg_catalog.macaddr_sortsupport(internal)
is 'sort support';

alter function pg_catalog.macaddr_sortsupport(internal)
  owner to postgres;

create function pg_catalog.txid_status(bigint)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_status
;

comment on function pg_catalog.txid_status(bigint)
is 'commit status of transaction';

alter function pg_catalog.txid_status(bigint)
  owner to postgres;

create function pg_catalog.pg_safe_snapshot_blocking_pids(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_safe_snapshot_blocking_pids
;

comment on function pg_catalog.pg_safe_snapshot_blocking_pids(integer)
is 'get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot';

alter function pg_catalog.pg_safe_snapshot_blocking_pids(integer)
  owner to postgres;

create function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer [])
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_isolation_test_session_is_blocked
;

comment on function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer [])
is 'isolationtester support function';

alter function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer [])
  owner to postgres;

create function pg_catalog.pg_identify_object_as_address(classid oid, objid oid, objsubid integer, out type text,
                                                                                                   out object_names text [],
                                                                                                   out object_args text [])
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_identify_object_as_address
;

comment on function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text [], out text [])
is 'get identification of SQL object for pg_get_object_address()';

alter function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text [], out text [])
  owner to postgres;

create function pg_catalog.brin_minmax_opcinfo(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_opcinfo
;

comment on function pg_catalog.brin_minmax_opcinfo(internal)
is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_opcinfo(internal)
  owner to postgres;

create function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_add_value
;

comment on function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal)
is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.brin_minmax_consistent(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_consistent
;

comment on function pg_catalog.brin_minmax_consistent(internal, internal, internal)
is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_consistent(internal, internal, internal)
  owner to postgres;

create function pg_catalog.brin_minmax_union(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_union
;

comment on function pg_catalog.brin_minmax_union(internal, internal, internal)
is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_union(internal, internal, internal)
  owner to postgres;

create function pg_catalog.int8_avg_accum_inv(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_accum_inv
;

comment on function pg_catalog.int8_avg_accum_inv(internal, bigint)
is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum_inv(internal, bigint)
  owner to postgres;

create function pg_catalog.numeric_poly_sum(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_sum
;

comment on function pg_catalog.numeric_poly_sum(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_poly_sum(internal)
  owner to postgres;

create function pg_catalog.numeric_poly_avg(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_avg
;

comment on function pg_catalog.numeric_poly_avg(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_poly_avg(internal)
  owner to postgres;

create function pg_catalog.numeric_poly_var_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_var_pop
;

comment on function pg_catalog.numeric_poly_var_pop(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_pop(internal)
  owner to postgres;

create function pg_catalog.numeric_poly_var_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_var_samp
;

comment on function pg_catalog.numeric_poly_var_samp(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_samp(internal)
  owner to postgres;

create function pg_catalog.numeric_poly_stddev_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_stddev_pop
;

comment on function pg_catalog.numeric_poly_stddev_pop(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_pop(internal)
  owner to postgres;

create function pg_catalog.numeric_poly_stddev_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_stddev_samp
;

comment on function pg_catalog.numeric_poly_stddev_samp(internal)
is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_samp(internal)
  owner to postgres;

create function pg_catalog.regexp_match(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_match
;

comment on function pg_catalog.regexp_match(text, text)
is 'find first match for regexp';

alter function pg_catalog.regexp_match(text, text)
  owner to postgres;

create function pg_catalog.regexp_match(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_match
;

comment on function pg_catalog.regexp_match(text, text, text)
is 'find first match for regexp';

alter function pg_catalog.regexp_match(text, text, text)
  owner to postgres;

create function pg_catalog.int8_mul_cash(bigint, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_mul_cash
;

comment on function pg_catalog.int8_mul_cash(bigint, money)
is 'implementation of * operator';

alter function pg_catalog.int8_mul_cash(bigint, money)
  owner to postgres;

create function pg_catalog.pg_config(out name text, out setting text)
immutable
strict
parallel restricted
cost 1
rows 23
language internal
as
-- missing source code for pg_catalog.pg_config
;

comment on function pg_catalog.pg_config(out text, out text)
is 'pg_config binary as a function';

alter function pg_catalog.pg_config(out text, out text)
  owner to postgres;

create function pg_catalog.pg_hba_file_rules(out line_number integer, out type text, out database text [],
                                             out user_name   text [], out address text, out netmask text,
                                             out auth_method text, out options text [], out error text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_hba_file_rules
;

comment on function pg_catalog.pg_hba_file_rules(out integer, out text, out text [], out text [], out text, out text,
                                                 out text, out text [], out text)
is 'show pg_hba.conf rules';

alter function pg_catalog.pg_hba_file_rules(out integer, out text, out text [], out text [], out text, out text, out text, out text [], out text)
  owner to postgres;

create function pg_catalog.pg_statistics_obj_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_statistics_obj_is_visible
;

comment on function pg_catalog.pg_statistics_obj_is_visible(oid)
is 'is statistics object visible in search path?';

alter function pg_catalog.pg_statistics_obj_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_dependencies_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_in
;

comment on function pg_catalog.pg_dependencies_in(cstring)
is 'I/O';

alter function pg_catalog.pg_dependencies_in(cstring)
  owner to postgres;

create function pg_catalog.pg_dependencies_out(pg_dependencies)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_out
;

comment on function pg_catalog.pg_dependencies_out(pg_dependencies)
is 'I/O';

alter function pg_catalog.pg_dependencies_out(pg_dependencies)
  owner to postgres;

create function pg_catalog.pg_dependencies_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_recv
;

comment on function pg_catalog.pg_dependencies_recv(internal)
is 'I/O';

alter function pg_catalog.pg_dependencies_recv(internal)
  owner to postgres;

create function pg_catalog.pg_dependencies_send(pg_dependencies)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_send
;

comment on function pg_catalog.pg_dependencies_send(pg_dependencies)
is 'I/O';

alter function pg_catalog.pg_dependencies_send(pg_dependencies)
  owner to postgres;

create function pg_catalog.pg_get_partition_constraintdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_partition_constraintdef
;

comment on function pg_catalog.pg_get_partition_constraintdef(oid)
is 'partition constraint description';

alter function pg_catalog.pg_get_partition_constraintdef(oid)
  owner to postgres;

create function pg_catalog.pg_get_statisticsobjdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_statisticsobjdef
;

comment on function pg_catalog.pg_get_statisticsobjdef(oid)
is 'extended statistics object description';

alter function pg_catalog.pg_get_statisticsobjdef(oid)
  owner to postgres;

create function pg_catalog.pg_control_system(out pg_control_version       integer, out catalog_version_no integer,
                                             out system_identifier        bigint,
                                             out pg_control_last_modified timestamp with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_system
;

comment on function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone)
is 'pg_controldata general state information as a function';

alter function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.pg_control_checkpoint(out checkpoint_lsn       pg_lsn, out prior_lsn pg_lsn,
                                                 out redo_lsn             pg_lsn, out redo_wal_file text,
                                                 out timeline_id          integer, out prev_timeline_id integer,
                                                 out full_page_writes     boolean, out next_xid text, out next_oid oid,
                                                 out next_multixact_id    xid, out next_multi_offset xid,
                                                 out oldest_xid           xid, out oldest_xid_dbid oid,
                                                 out oldest_active_xid    xid, out oldest_multi_xid xid,
                                                 out oldest_multi_dbid    oid, out oldest_commit_ts_xid xid,
                                                 out newest_commit_ts_xid xid,
                                                 out checkpoint_time      timestamp with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_checkpoint
;

comment on function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out pg_lsn, out text, out integer,
                                                     out integer, out boolean, out text, out oid, out xid, out xid,
                                                     out xid, out oid, out xid, out xid, out oid, out xid, out xid,
                                                     out timestamp with time zone)
is 'pg_controldata checkpoint state information as a function';

alter function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out pg_lsn, out text, out integer, out integer, out boolean, out text, out oid, out xid, out xid, out xid, out oid, out xid, out xid, out oid, out xid, out xid, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.pg_control_recovery(out min_recovery_end_lsn          pg_lsn,
                                               out min_recovery_end_timeline     integer, out backup_start_lsn pg_lsn,
                                               out backup_end_lsn                pg_lsn,
                                               out end_of_backup_record_required boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_recovery
;

comment on function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean)
is 'pg_controldata recovery state information as a function';

alter function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean)
  owner to postgres;

create function pg_catalog.pg_control_init(out max_data_alignment      integer, out database_block_size integer,
                                           out blocks_per_segment      integer, out wal_block_size integer,
                                           out bytes_per_wal_segment   integer, out max_identifier_length integer,
                                           out max_index_columns       integer, out max_toast_chunk_size integer,
                                           out large_object_chunk_size integer, out float4_pass_by_value boolean,
                                           out float8_pass_by_value    boolean, out data_page_checksum_version integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_init
;

comment on function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer,
                                               out integer, out integer, out integer, out integer, out boolean,
                                               out boolean, out integer)
is 'pg_controldata init state information as a function';

alter function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out boolean, out boolean, out integer)
  owner to postgres;

create function pg_catalog.pg_import_system_collations(regnamespace)
strict
language internal
as
-- missing source code for pg_catalog.pg_import_system_collations
;

comment on function pg_catalog.pg_import_system_collations(regnamespace)
is 'import collations from operating system';

alter function pg_catalog.pg_import_system_collations(regnamespace)
  owner to postgres;

create function pg_catalog.macaddr8_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_recv
;

comment on function pg_catalog.macaddr8_recv(internal)
is 'I/O';

alter function pg_catalog.macaddr8_recv(internal)
  owner to postgres;

create function pg_catalog.macaddr8_send(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_send
;

comment on function pg_catalog.macaddr8_send(macaddr8)
is 'I/O';

alter function pg_catalog.macaddr8_send(macaddr8)
  owner to postgres;

create function pg_catalog.pg_collation_actual_version(oid)
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.pg_collation_actual_version
;

comment on function pg_catalog.pg_collation_actual_version(oid)
is 'get actual version of collation from operating system';

alter function pg_catalog.pg_collation_actual_version(oid)
  owner to postgres;

create function pg_catalog.pg_filenode_relation(oid, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_filenode_relation
;

comment on function pg_catalog.pg_filenode_relation(oid, oid)
is 'relation OID for filenode and tablespace';

alter function pg_catalog.pg_filenode_relation(oid, oid)
  owner to postgres;

create function pg_catalog.lo_from_bytea(oid, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_from_bytea
;

comment on function pg_catalog.lo_from_bytea(oid, bytea)
is 'create new large object with given content';

alter function pg_catalog.lo_from_bytea(oid, bytea)
  owner to postgres;

create function pg_catalog.lo_get(oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_get
;

comment on function pg_catalog.lo_get(oid)
is 'read entire large object';

alter function pg_catalog.lo_get(oid)
  owner to postgres;

create function pg_catalog.lo_get(oid, bigint, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_get
;

comment on function pg_catalog.lo_get(oid, bigint, integer)
is 'read large object from offset for length';

alter function pg_catalog.lo_get(oid, bigint, integer)
  owner to postgres;

create function pg_catalog.lo_put(oid, bigint, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_put
;

comment on function pg_catalog.lo_put(oid, bigint, bytea)
is 'write data at offset';

alter function pg_catalog.lo_put(oid, bigint, bytea)
  owner to postgres;

create function pg_catalog.make_timestamp(year integer, month integer, mday integer, hour integer, min integer,
                                          sec  double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_timestamp
;

comment on function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision)
is 'construct timestamp';

alter function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision)
  owner to postgres;

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer,
                                            sec  double precision)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_timestamptz
;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision)
is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision)
  owner to postgres;

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer,
                                            sec  double precision, timezone text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_timestamptz
;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text)
is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text)
  owner to postgres;

create function pg_catalog.make_interval(years integer default 0, months integer default 0, weeks integer default 0,
                                         days  integer default 0, hours integer default 0, mins integer default 0,
                                         secs  double precision default 0.0)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_interval
;

comment on function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision)
is 'construct interval';

alter function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision)
  owner to postgres;

create function pg_catalog.jsonb_array_elements_text(from_json jsonb, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_array_elements_text
;

comment on function pg_catalog.jsonb_array_elements_text(jsonb, out text)
is 'elements of jsonb array';

alter function pg_catalog.jsonb_array_elements_text(jsonb, out text)
  owner to postgres;

create function pg_catalog.spg_range_quad_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_config
;

comment on function pg_catalog.spg_range_quad_config(internal, internal)
is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_config(internal, internal)
  owner to postgres;

create function pg_catalog.spg_range_quad_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_choose
;

comment on function pg_catalog.spg_range_quad_choose(internal, internal)
is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_choose(internal, internal)
  owner to postgres;

create function pg_catalog.spg_range_quad_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_picksplit
;

comment on function pg_catalog.spg_range_quad_picksplit(internal, internal)
is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.spg_range_quad_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_inner_consistent
;

comment on function pg_catalog.spg_range_quad_inner_consistent(internal, internal)
is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_inner_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.spg_range_quad_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_leaf_consistent
;

comment on function pg_catalog.spg_range_quad_leaf_consistent(internal, internal)
is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_leaf_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.jsonb_populate_recordset(anyelement, jsonb)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_populate_recordset
;

comment on function pg_catalog.jsonb_populate_recordset(anyelement, jsonb)
is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_populate_recordset(anyelement, jsonb)
  owner to postgres;

create function pg_catalog.to_regoperator(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regoperator
;

comment on function pg_catalog.to_regoperator(text)
is 'convert operator name to regoperator';

alter function pg_catalog.to_regoperator(text)
  owner to postgres;

create function pg_catalog.jsonb_object_field(from_json jsonb, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_field
;

comment on function pg_catalog.jsonb_object_field(jsonb, text)
is 'implementation of -> operator';

alter function pg_catalog.jsonb_object_field(jsonb, text)
  owner to postgres;

create function pg_catalog.to_regprocedure(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regprocedure
;

comment on function pg_catalog.to_regprocedure(text)
is 'convert proname to regprocedure';

alter function pg_catalog.to_regprocedure(text)
  owner to postgres;

create function pg_catalog.gin_compare_jsonb(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_compare_jsonb
;

comment on function pg_catalog.gin_compare_jsonb(text, text)
is 'GIN support';

alter function pg_catalog.gin_compare_jsonb(text, text)
  owner to postgres;

create function pg_catalog.gin_extract_jsonb(jsonb, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb
;

comment on function pg_catalog.gin_extract_jsonb(jsonb, internal, internal)
is 'GIN support';

alter function pg_catalog.gin_extract_jsonb(jsonb, internal, internal)
  owner to postgres;

create function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb_query
;

comment on function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal,
                                                       internal)
is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal,
                                                internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_consistent_jsonb
;

comment on function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal,
                                                    internal)
is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb_path
;

comment on function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal)
is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal)
  owner to postgres;

create function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal,
                                                        internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb_query_path
;

comment on function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal,
                                                            internal)
is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal,
                                                     internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_consistent_jsonb_path
;

comment on function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal,
                                                         internal, internal)
is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_triconsistent_jsonb
;

comment on function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal)
is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal,
                                                        internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_triconsistent_jsonb_path
;

comment on function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal,
                                                            internal)
is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal)
  owner to postgres;

create function pg_catalog.jsonb_to_record(jsonb)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_to_record
;

comment on function pg_catalog.jsonb_to_record(jsonb)
is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_to_record(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_to_recordset(jsonb)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_to_recordset
;

comment on function pg_catalog.jsonb_to_recordset(jsonb)
is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_to_recordset(jsonb)
  owner to postgres;

create function pg_catalog.to_regoper(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regoper
;

comment on function pg_catalog.to_regoper(text)
is 'convert operator name to regoper';

alter function pg_catalog.to_regoper(text)
  owner to postgres;

create function pg_catalog.to_regtype(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regtype
;

comment on function pg_catalog.to_regtype(text)
is 'convert type name to regtype';

alter function pg_catalog.to_regtype(text)
  owner to postgres;

create function pg_catalog.to_regproc(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regproc
;

comment on function pg_catalog.to_regproc(text)
is 'convert proname to regproc';

alter function pg_catalog.to_regproc(text)
  owner to postgres;

create function pg_catalog.to_regclass(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regclass
;

comment on function pg_catalog.to_regclass(text)
is 'convert classname to regclass';

alter function pg_catalog.to_regclass(text)
  owner to postgres;

create function pg_catalog.bool_accum(internal, boolean)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_accum
;

comment on function pg_catalog.bool_accum(internal, boolean)
is 'aggregate transition function';

alter function pg_catalog.bool_accum(internal, boolean)
  owner to postgres;

create function pg_catalog.bool_accum_inv(internal, boolean)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_accum_inv
;

comment on function pg_catalog.bool_accum_inv(internal, boolean)
is 'aggregate transition function';

alter function pg_catalog.bool_accum_inv(internal, boolean)
  owner to postgres;

create function pg_catalog.bool_alltrue(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_alltrue
;

comment on function pg_catalog.bool_alltrue(internal)
is 'aggregate final function';

alter function pg_catalog.bool_alltrue(internal)
  owner to postgres;

create function pg_catalog.bool_anytrue(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_anytrue
;

comment on function pg_catalog.bool_anytrue(internal)
is 'aggregate final function';

alter function pg_catalog.bool_anytrue(internal)
  owner to postgres;

create function pg_catalog.anyenum_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyenum_in
;

comment on function pg_catalog.anyenum_in(cstring)
is 'I/O';

alter function pg_catalog.anyenum_in(cstring)
  owner to postgres;

create function pg_catalog.anyenum_out(anyenum)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyenum_out
;

comment on function pg_catalog.anyenum_out(anyenum)
is 'I/O';

alter function pg_catalog.anyenum_out(anyenum)
  owner to postgres;

create function pg_catalog.enum_in(cstring, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_in
;

comment on function pg_catalog.enum_in(cstring, oid)
is 'I/O';

alter function pg_catalog.enum_in(cstring, oid)
  owner to postgres;

create function pg_catalog.enum_out(anyenum)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_out
;

comment on function pg_catalog.enum_out(anyenum)
is 'I/O';

alter function pg_catalog.enum_out(anyenum)
  owner to postgres;

create function pg_catalog.enum_eq(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_eq
;

comment on function pg_catalog.enum_eq(anyenum, anyenum)
is 'implementation of = operator';

alter function pg_catalog.enum_eq(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_ne(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_ne
;

comment on function pg_catalog.enum_ne(anyenum, anyenum)
is 'implementation of <> operator';

alter function pg_catalog.enum_ne(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_lt(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_lt
;

comment on function pg_catalog.enum_lt(anyenum, anyenum)
is 'implementation of < operator';

alter function pg_catalog.enum_lt(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_gt(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_gt
;

comment on function pg_catalog.enum_gt(anyenum, anyenum)
is 'implementation of > operator';

alter function pg_catalog.enum_gt(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_le(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_le
;

comment on function pg_catalog.enum_le(anyenum, anyenum)
is 'implementation of <= operator';

alter function pg_catalog.enum_le(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_ge(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_ge
;

comment on function pg_catalog.enum_ge(anyenum, anyenum)
is 'implementation of >= operator';

alter function pg_catalog.enum_ge(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_cmp(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_cmp
;

comment on function pg_catalog.enum_cmp(anyenum, anyenum)
is 'less-equal-greater';

alter function pg_catalog.enum_cmp(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.hashenum(anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashenum
;

comment on function pg_catalog.hashenum(anyenum)
is 'hash';

alter function pg_catalog.hashenum(anyenum)
  owner to postgres;

create function pg_catalog.enum_smaller(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_smaller
;

comment on function pg_catalog.enum_smaller(anyenum, anyenum)
is 'smaller of two';

alter function pg_catalog.enum_smaller(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_larger(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_larger
;

comment on function pg_catalog.enum_larger(anyenum, anyenum)
is 'larger of two';

alter function pg_catalog.enum_larger(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_first(anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_first
;

comment on function pg_catalog.enum_first(anyenum)
is 'first value of the input enum type';

alter function pg_catalog.enum_first(anyenum)
  owner to postgres;

create function pg_catalog.enum_last(anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_last
;

comment on function pg_catalog.enum_last(anyenum)
is 'last value of the input enum type';

alter function pg_catalog.enum_last(anyenum)
  owner to postgres;

create function pg_catalog.enum_range(anyenum, anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_range
;

comment on function pg_catalog.enum_range(anyenum, anyenum)
is 'range between the two given enum values, as an ordered array';

alter function pg_catalog.enum_range(anyenum, anyenum)
  owner to postgres;

create function pg_catalog.enum_range(anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_range
;

comment on function pg_catalog.enum_range(anyenum)
is 'range of the given enum type, as an ordered array';

alter function pg_catalog.enum_range(anyenum)
  owner to postgres;

create function pg_catalog.enum_recv(internal, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_recv
;

comment on function pg_catalog.enum_recv(internal, oid)
is 'I/O';

alter function pg_catalog.enum_recv(internal, oid)
  owner to postgres;

create function pg_catalog.enum_send(anyenum)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_send
;

comment on function pg_catalog.enum_send(anyenum)
is 'I/O';

alter function pg_catalog.enum_send(anyenum)
  owner to postgres;

create function pg_catalog.string_agg_transfn(internal, text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_agg_transfn
;

comment on function pg_catalog.string_agg_transfn(internal, text, text)
is 'aggregate transition function';

alter function pg_catalog.string_agg_transfn(internal, text, text)
  owner to postgres;

create function pg_catalog.string_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_agg_finalfn
;

comment on function pg_catalog.string_agg_finalfn(internal)
is 'aggregate final function';

alter function pg_catalog.string_agg_finalfn(internal)
  owner to postgres;

create function pg_catalog.pg_describe_object(oid, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_describe_object
;

comment on function pg_catalog.pg_describe_object(oid, oid, integer)
is 'get identification of SQL object';

alter function pg_catalog.pg_describe_object(oid, oid, integer)
  owner to postgres;

create function pg_catalog.format(text, "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.format
;

comment on function pg_catalog.format(text, "any")
is 'format text message';

alter function pg_catalog.format(text, "any")
  owner to postgres;

create function pg_catalog.format(text)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.format
;

comment on function pg_catalog.format(text)
is 'format text message';

alter function pg_catalog.format(text)
  owner to postgres;

create function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytea_string_agg_transfn
;

comment on function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea)
is 'aggregate transition function';

alter function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea)
  owner to postgres;

create function pg_catalog.bytea_string_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytea_string_agg_finalfn
;

comment on function pg_catalog.bytea_string_agg_finalfn(internal)
is 'aggregate final function';

alter function pg_catalog.bytea_string_agg_finalfn(internal)
  owner to postgres;

create function pg_catalog.int8dec(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8dec
;

comment on function pg_catalog.int8dec(bigint)
is 'decrement';

alter function pg_catalog.int8dec(bigint)
  owner to postgres;

create function pg_catalog.int8dec_any(bigint, "any")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8dec_any
;

comment on function pg_catalog.int8dec_any(bigint, "any")
is 'decrement, ignores second argument';

alter function pg_catalog.int8dec_any(bigint, "any")
  owner to postgres;

create function pg_catalog.numeric_accum_inv(internal, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_accum_inv
;

comment on function pg_catalog.numeric_accum_inv(internal, numeric)
is 'aggregate transition function';

alter function pg_catalog.numeric_accum_inv(internal, numeric)
  owner to postgres;

create function pg_catalog.interval_accum_inv(interval [], interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_accum_inv
;

comment on function pg_catalog.interval_accum_inv(interval [], interval)
is 'aggregate transition function';

alter function pg_catalog.interval_accum_inv(interval [], interval)
  owner to postgres;

create function pg_catalog.network_overlap(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_overlap
;

comment on function pg_catalog.network_overlap(inet, inet)
is 'implementation of && operator';

alter function pg_catalog.network_overlap(inet, inet)
  owner to postgres;

create function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_consistent
;

comment on function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.inet_gist_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_union
;

comment on function pg_catalog.inet_gist_union(internal, internal)
is 'GiST support';

alter function pg_catalog.inet_gist_union(internal, internal)
  owner to postgres;

create function pg_catalog.inet_gist_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_compress
;

comment on function pg_catalog.inet_gist_compress(internal)
is 'GiST support';

alter function pg_catalog.inet_gist_compress(internal)
  owner to postgres;

create function pg_catalog.inet_gist_decompress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_decompress
;

comment on function pg_catalog.inet_gist_decompress(internal)
is 'GiST support';

alter function pg_catalog.inet_gist_decompress(internal)
  owner to postgres;

create function pg_catalog.inet_gist_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_penalty
;

comment on function pg_catalog.inet_gist_penalty(internal, internal, internal)
is 'GiST support';

alter function pg_catalog.inet_gist_penalty(internal, internal, internal)
  owner to postgres;

create function pg_catalog.inet_gist_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_picksplit
;

comment on function pg_catalog.inet_gist_picksplit(internal, internal)
is 'GiST support';

alter function pg_catalog.inet_gist_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.inet_gist_same(inet, inet, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_same
;

comment on function pg_catalog.inet_gist_same(inet, inet, internal)
is 'GiST support';

alter function pg_catalog.inet_gist_same(inet, inet, internal)
  owner to postgres;

create function pg_catalog.networksel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.networksel
;

comment on function pg_catalog.networksel(internal, oid, internal, integer)
is 'restriction selectivity for network operators';

alter function pg_catalog.networksel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.networkjoinsel
;

comment on function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for network operators';

alter function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.network_larger(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_larger
;

comment on function pg_catalog.network_larger(inet, inet)
is 'larger of two';

alter function pg_catalog.network_larger(inet, inet)
  owner to postgres;

create function pg_catalog.network_smaller(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_smaller
;

comment on function pg_catalog.network_smaller(inet, inet)
is 'smaller of two';

alter function pg_catalog.network_smaller(inet, inet)
  owner to postgres;

create function pg_catalog.pg_event_trigger_dropped_objects(out classid         oid, out objid oid,
                                                            out objsubid        integer, out original boolean,
                                                            out normal          boolean, out is_temporary boolean,
                                                            out object_type     text, out schema_name text,
                                                            out object_name     text, out object_identity text,
                                                            out address_names   text [], out address_args text [])
stable
strict
parallel restricted
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_dropped_objects
;

comment on function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean,
                                                                out boolean, out text, out text, out text, out text,
                                                                out text [], out text [])
is 'list objects dropped by the current command';

alter function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean, out boolean, out text, out text, out text, out text, out text [], out text [])
  owner to postgres;

create function pg_catalog.int2_accum_inv(internal, smallint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_accum_inv
;

comment on function pg_catalog.int2_accum_inv(internal, smallint)
is 'aggregate transition function';

alter function pg_catalog.int2_accum_inv(internal, smallint)
  owner to postgres;

create function pg_catalog.int4_accum_inv(internal, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_accum_inv
;

comment on function pg_catalog.int4_accum_inv(internal, integer)
is 'aggregate transition function';

alter function pg_catalog.int4_accum_inv(internal, integer)
  owner to postgres;

create function pg_catalog.int8_accum_inv(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_accum_inv
;

comment on function pg_catalog.int8_accum_inv(internal, bigint)
is 'aggregate transition function';

alter function pg_catalog.int8_accum_inv(internal, bigint)
  owner to postgres;

create function pg_catalog.int2_avg_accum_inv(bigint [], smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_avg_accum_inv
;

comment on function pg_catalog.int2_avg_accum_inv(bigint [], smallint)
is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum_inv(bigint [], smallint)
  owner to postgres;

create function pg_catalog.int4_avg_accum_inv(bigint [], integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_avg_accum_inv
;

comment on function pg_catalog.int4_avg_accum_inv(bigint [], integer)
is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum_inv(bigint [], integer)
  owner to postgres;

create function pg_catalog.int2int4_sum(bigint [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2int4_sum
;

comment on function pg_catalog.int2int4_sum(bigint [])
is 'aggregate final function';

alter function pg_catalog.int2int4_sum(bigint [])
  owner to postgres;

create function pg_catalog.inet_gist_fetch(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_fetch
;

comment on function pg_catalog.inet_gist_fetch(internal)
is 'GiST support';

alter function pg_catalog.inet_gist_fetch(internal)
  owner to postgres;

create function pg_catalog.pg_logical_emit_message(boolean, text, text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_logical_emit_message
;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, text)
is 'emit a textual logical decoding message';

alter function pg_catalog.pg_logical_emit_message(boolean, text, text)
  owner to postgres;

create function pg_catalog.pg_logical_emit_message(boolean, text, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_logical_emit_message
;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, bytea)
is 'emit a binary logical decoding message';

alter function pg_catalog.pg_logical_emit_message(boolean, text, bytea)
  owner to postgres;

create function pg_catalog.jsonb_insert(jsonb_in     jsonb, path text [], replacement jsonb,
                                        insert_after boolean default false)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_insert
;

comment on function pg_catalog.jsonb_insert(jsonb, text [], jsonb, boolean)
is 'Insert value into a jsonb';

alter function pg_catalog.jsonb_insert(jsonb, text [], jsonb, boolean)
  owner to postgres;

create function pg_catalog.pg_xact_commit_timestamp(xid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_xact_commit_timestamp
;

comment on function pg_catalog.pg_xact_commit_timestamp(xid)
is 'get commit timestamp of a transaction';

alter function pg_catalog.pg_xact_commit_timestamp(xid)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_pg_type_oid
;

comment on function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid)
  owner to postgres;

create function pg_catalog.pg_last_committed_xact(out xid xid, out timestamp timestamp with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_committed_xact
;

comment on function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone)
is 'get transaction Id and commit timestamp of latest transaction commit';

alter function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_array_pg_type_oid
;

comment on function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_toast_pg_type_oid
;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_heap_pg_class_oid
;

comment on function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_index_pg_class_oid
;

comment on function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_toast_pg_class_oid
;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_pg_enum_oid
;

comment on function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_pg_authid_oid
;

comment on function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid)
  owner to postgres;

create function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid [], text [], text [])
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_create_empty_extension
;

comment on function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid [], text [],
                                                                     text [])
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid [], text [], text [])
  owner to postgres;

create function pg_catalog.event_trigger_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.event_trigger_in
;

comment on function pg_catalog.event_trigger_in(cstring)
is 'I/O';

alter function pg_catalog.event_trigger_in(cstring)
  owner to postgres;

create function pg_catalog.event_trigger_out(event_trigger)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.event_trigger_out
;

comment on function pg_catalog.event_trigger_out(event_trigger)
is 'I/O';

alter function pg_catalog.event_trigger_out(event_trigger)
  owner to postgres;

create function pg_catalog.tsvectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorin
;

comment on function pg_catalog.tsvectorin(cstring)
is 'I/O';

alter function pg_catalog.tsvectorin(cstring)
  owner to postgres;

create function pg_catalog.tsvectorout(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorout
;

comment on function pg_catalog.tsvectorout(tsvector)
is 'I/O';

alter function pg_catalog.tsvectorout(tsvector)
  owner to postgres;

create function pg_catalog.tsqueryin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsqueryin
;

comment on function pg_catalog.tsqueryin(cstring)
is 'I/O';

alter function pg_catalog.tsqueryin(cstring)
  owner to postgres;

create function pg_catalog.tsqueryout(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsqueryout
;

comment on function pg_catalog.tsqueryout(tsquery)
is 'I/O';

alter function pg_catalog.tsqueryout(tsquery)
  owner to postgres;

create function pg_catalog.tsvector_lt(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_lt
;

comment on function pg_catalog.tsvector_lt(tsvector, tsvector)
is 'implementation of < operator';

alter function pg_catalog.tsvector_lt(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.tsvector_le(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_le
;

comment on function pg_catalog.tsvector_le(tsvector, tsvector)
is 'implementation of <= operator';

alter function pg_catalog.tsvector_le(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.tsvector_eq(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_eq
;

comment on function pg_catalog.tsvector_eq(tsvector, tsvector)
is 'implementation of = operator';

alter function pg_catalog.tsvector_eq(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.tsvector_ne(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_ne
;

comment on function pg_catalog.tsvector_ne(tsvector, tsvector)
is 'implementation of <> operator';

alter function pg_catalog.tsvector_ne(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.tsvector_ge(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_ge
;

comment on function pg_catalog.tsvector_ge(tsvector, tsvector)
is 'implementation of >= operator';

alter function pg_catalog.tsvector_ge(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.tsvector_gt(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_gt
;

comment on function pg_catalog.tsvector_gt(tsvector, tsvector)
is 'implementation of > operator';

alter function pg_catalog.tsvector_gt(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.tsvector_cmp(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_cmp
;

comment on function pg_catalog.tsvector_cmp(tsvector, tsvector)
is 'less-equal-greater';

alter function pg_catalog.tsvector_cmp(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.strip(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.strip
;

comment on function pg_catalog.strip(tsvector)
is 'strip position information';

alter function pg_catalog.strip(tsvector)
  owner to postgres;

create function pg_catalog.setweight(tsvector, "char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.setweight
;

comment on function pg_catalog.setweight(tsvector, "char")
is 'set given weight for whole tsvector';

alter function pg_catalog.setweight(tsvector, "char")
  owner to postgres;

create function pg_catalog.tsvector_concat(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_concat
;

comment on function pg_catalog.tsvector_concat(tsvector, tsvector)
is 'implementation of || operator';

alter function pg_catalog.tsvector_concat(tsvector, tsvector)
  owner to postgres;

create function pg_catalog.ts_match_vq(tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_match_vq
;

comment on function pg_catalog.ts_match_vq(tsvector, tsquery)
is 'implementation of @@ operator';

alter function pg_catalog.ts_match_vq(tsvector, tsquery)
  owner to postgres;

create function pg_catalog.ts_match_qv(tsquery, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_match_qv
;

comment on function pg_catalog.ts_match_qv(tsquery, tsvector)
is 'implementation of @@ operator';

alter function pg_catalog.ts_match_qv(tsquery, tsvector)
  owner to postgres;

create function pg_catalog.tsvectorsend(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorsend
;

comment on function pg_catalog.tsvectorsend(tsvector)
is 'I/O';

alter function pg_catalog.tsvectorsend(tsvector)
  owner to postgres;

create function pg_catalog.tsvectorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorrecv
;

comment on function pg_catalog.tsvectorrecv(internal)
is 'I/O';

alter function pg_catalog.tsvectorrecv(internal)
  owner to postgres;

create function pg_catalog.tsquerysend(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquerysend
;

comment on function pg_catalog.tsquerysend(tsquery)
is 'I/O';

alter function pg_catalog.tsquerysend(tsquery)
  owner to postgres;

create function pg_catalog.tsqueryrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsqueryrecv
;

comment on function pg_catalog.tsqueryrecv(internal)
is 'I/O';

alter function pg_catalog.tsqueryrecv(internal)
  owner to postgres;

create function pg_catalog.gtsvectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvectorin
;

comment on function pg_catalog.gtsvectorin(cstring)
is 'I/O';

alter function pg_catalog.gtsvectorin(cstring)
  owner to postgres;

create function pg_catalog.gtsvectorout(gtsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvectorout
;

comment on function pg_catalog.gtsvectorout(gtsvector)
is 'I/O';

alter function pg_catalog.gtsvectorout(gtsvector)
  owner to postgres;

create function pg_catalog.gtsvector_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_compress
;

comment on function pg_catalog.gtsvector_compress(internal)
is 'GiST tsvector support';

alter function pg_catalog.gtsvector_compress(internal)
  owner to postgres;

create function pg_catalog.gtsvector_decompress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_decompress
;

comment on function pg_catalog.gtsvector_decompress(internal)
is 'GiST tsvector support';

alter function pg_catalog.gtsvector_decompress(internal)
  owner to postgres;

create function pg_catalog.gtsvector_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_picksplit
;

comment on function pg_catalog.gtsvector_picksplit(internal, internal)
is 'GiST tsvector support';

alter function pg_catalog.gtsvector_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.gtsvector_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_union
;

comment on function pg_catalog.gtsvector_union(internal, internal)
is 'GiST tsvector support';

alter function pg_catalog.gtsvector_union(internal, internal)
  owner to postgres;

create function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_same
;

comment on function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal)
is 'GiST tsvector support';

alter function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal)
  owner to postgres;

create function pg_catalog.gtsvector_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_penalty
;

comment on function pg_catalog.gtsvector_penalty(internal, internal, internal)
is 'GiST tsvector support';

alter function pg_catalog.gtsvector_penalty(internal, internal, internal)
  owner to postgres;

create function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_consistent
;

comment on function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal)
is 'GiST tsvector support';

alter function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.gin_extract_tsvector(tsvector, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsvector
;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal, internal)
is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsvector(tsvector, internal, internal)
  owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsquery
;

comment on function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal)
is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal,
                                                  internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_consistent
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal,
                                                      internal, internal)
is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.tsquery_lt(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_lt
;

comment on function pg_catalog.tsquery_lt(tsquery, tsquery)
is 'implementation of < operator';

alter function pg_catalog.tsquery_lt(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_le(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_le
;

comment on function pg_catalog.tsquery_le(tsquery, tsquery)
is 'implementation of <= operator';

alter function pg_catalog.tsquery_le(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_eq(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_eq
;

comment on function pg_catalog.tsquery_eq(tsquery, tsquery)
is 'implementation of = operator';

alter function pg_catalog.tsquery_eq(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_ne(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_ne
;

comment on function pg_catalog.tsquery_ne(tsquery, tsquery)
is 'implementation of <> operator';

alter function pg_catalog.tsquery_ne(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_ge(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_ge
;

comment on function pg_catalog.tsquery_ge(tsquery, tsquery)
is 'implementation of >= operator';

alter function pg_catalog.tsquery_ge(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_gt(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_gt
;

comment on function pg_catalog.tsquery_gt(tsquery, tsquery)
is 'implementation of > operator';

alter function pg_catalog.tsquery_gt(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_cmp(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_cmp
;

comment on function pg_catalog.tsquery_cmp(tsquery, tsquery)
is 'less-equal-greater';

alter function pg_catalog.tsquery_cmp(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_and(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_and
;

comment on function pg_catalog.tsquery_and(tsquery, tsquery)
is 'implementation of && operator';

alter function pg_catalog.tsquery_and(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_or(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_or
;

comment on function pg_catalog.tsquery_or(tsquery, tsquery)
is 'implementation of || operator';

alter function pg_catalog.tsquery_or(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_not(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_not
;

comment on function pg_catalog.tsquery_not(tsquery)
is 'implementation of !! operator';

alter function pg_catalog.tsquery_not(tsquery)
  owner to postgres;

create function pg_catalog.numnode(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numnode
;

comment on function pg_catalog.numnode(tsquery)
is 'number of nodes';

alter function pg_catalog.numnode(tsquery)
  owner to postgres;

create function pg_catalog.querytree(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.querytree
;

comment on function pg_catalog.querytree(tsquery)
is 'show real useful query for GiST index';

alter function pg_catalog.querytree(tsquery)
  owner to postgres;

create function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rewrite
;

comment on function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery)
is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery)
  owner to postgres;

create function pg_catalog.ts_rewrite(tsquery, text)
strict
language internal
as
-- missing source code for pg_catalog.ts_rewrite
;

comment on function pg_catalog.ts_rewrite(tsquery, text)
is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite(tsquery, text)
  owner to postgres;

create function pg_catalog.tsmatchsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsmatchsel
;

comment on function pg_catalog.tsmatchsel(internal, oid, internal, integer)
is 'restriction selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsmatchjoinsel
;

comment on function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.ts_typanalyze(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_typanalyze
;

comment on function pg_catalog.ts_typanalyze(internal)
is 'tsvector typanalyze';

alter function pg_catalog.ts_typanalyze(internal)
  owner to postgres;

create function pg_catalog.ts_stat(query text, out word text, out ndoc integer, out nentry integer)
strict
cost 10
rows 10000
language internal
as
-- missing source code for pg_catalog.ts_stat
;

comment on function pg_catalog.ts_stat(text, out text, out integer, out integer)
is 'statistics of tsvector column';

alter function pg_catalog.ts_stat(text, out text, out integer, out integer)
  owner to postgres;

create function pg_catalog.ts_stat(query text, weights text, out word text, out ndoc integer, out nentry integer)
strict
cost 10
rows 10000
language internal
as
-- missing source code for pg_catalog.ts_stat
;

comment on function pg_catalog.ts_stat(text, text, out text, out integer, out integer)
is 'statistics of tsvector column';

alter function pg_catalog.ts_stat(text, text, out text, out integer, out integer)
  owner to postgres;

create function pg_catalog.tsq_mcontains(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsq_mcontains
;

comment on function pg_catalog.tsq_mcontains(tsquery, tsquery)
is 'implementation of @> operator';

alter function pg_catalog.tsq_mcontains(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsq_mcontained(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsq_mcontained
;

comment on function pg_catalog.tsq_mcontained(tsquery, tsquery)
is 'implementation of <@ operator';

alter function pg_catalog.tsq_mcontained(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.gtsquery_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_compress
;

comment on function pg_catalog.gtsquery_compress(internal)
is 'GiST tsquery support';

alter function pg_catalog.gtsquery_compress(internal)
  owner to postgres;

create function pg_catalog.gtsquery_decompress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_decompress
;

comment on function pg_catalog.gtsquery_decompress(internal)
is 'GiST tsquery support';

alter function pg_catalog.gtsquery_decompress(internal)
  owner to postgres;

create function pg_catalog.gtsquery_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_picksplit
;

comment on function pg_catalog.gtsquery_picksplit(internal, internal)
is 'GiST tsquery support';

alter function pg_catalog.gtsquery_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.gtsquery_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_union
;

comment on function pg_catalog.gtsquery_union(internal, internal)
is 'GiST tsquery support';

alter function pg_catalog.gtsquery_union(internal, internal)
  owner to postgres;

create function pg_catalog.gtsquery_same(bigint, bigint, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_same
;

comment on function pg_catalog.gtsquery_same(bigint, bigint, internal)
is 'GiST tsquery support';

alter function pg_catalog.gtsquery_same(bigint, bigint, internal)
  owner to postgres;

create function pg_catalog.gtsquery_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_penalty
;

comment on function pg_catalog.gtsquery_penalty(internal, internal, internal)
is 'GiST tsquery support';

alter function pg_catalog.gtsquery_penalty(internal, internal, internal)
  owner to postgres;

create function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_consistent
;

comment on function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal)
is 'GiST tsquery support';

alter function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.ts_rank(real [], tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(real [], tsvector, tsquery, integer)
is 'relevance';

alter function pg_catalog.ts_rank(real [], tsvector, tsquery, integer)
  owner to postgres;

create function pg_catalog.ts_rank(real [], tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(real [], tsvector, tsquery)
is 'relevance';

alter function pg_catalog.ts_rank(real [], tsvector, tsquery)
  owner to postgres;

create function pg_catalog.ts_rank(tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(tsvector, tsquery, integer)
is 'relevance';

alter function pg_catalog.ts_rank(tsvector, tsquery, integer)
  owner to postgres;

create function pg_catalog.ts_rank(tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(tsvector, tsquery)
is 'relevance';

alter function pg_catalog.ts_rank(tsvector, tsquery)
  owner to postgres;

create function pg_catalog.ts_rank_cd(real [], tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(real [], tsvector, tsquery, integer)
is 'relevance';

alter function pg_catalog.ts_rank_cd(real [], tsvector, tsquery, integer)
  owner to postgres;

create function pg_catalog.ts_rank_cd(real [], tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(real [], tsvector, tsquery)
is 'relevance';

alter function pg_catalog.ts_rank_cd(real [], tsvector, tsquery)
  owner to postgres;

create function pg_catalog.ts_rank_cd(tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery, integer)
is 'relevance';

alter function pg_catalog.ts_rank_cd(tsvector, tsquery, integer)
  owner to postgres;

create function pg_catalog.ts_rank_cd(tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery)
is 'relevance';

alter function pg_catalog.ts_rank_cd(tsvector, tsquery)
  owner to postgres;

create function pg_catalog.length(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(tsvector)
is 'number of lexemes';

alter function pg_catalog.length(tsvector)
  owner to postgres;

create function pg_catalog.ts_token_type(parser_oid oid, out tokid integer, out alias text, out description text)
immutable
strict
parallel safe
cost 1
rows 16
language internal
as
-- missing source code for pg_catalog.ts_token_type
;

comment on function pg_catalog.ts_token_type(oid, out integer, out text, out text)
is 'get parser''s token types';

alter function pg_catalog.ts_token_type(oid, out integer, out text, out text)
  owner to postgres;

create function pg_catalog.ts_token_type(parser_name text, out tokid integer, out alias text, out description text)
stable
strict
parallel safe
cost 1
rows 16
language internal
as
-- missing source code for pg_catalog.ts_token_type
;

comment on function pg_catalog.ts_token_type(text, out integer, out text, out text)
is 'get parser''s token types';

alter function pg_catalog.ts_token_type(text, out integer, out text, out text)
  owner to postgres;

create function pg_catalog.ts_parse(parser_oid oid, txt text, out tokid integer, out token text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_parse
;

comment on function pg_catalog.ts_parse(oid, text, out integer, out text)
is 'parse text to tokens';

alter function pg_catalog.ts_parse(oid, text, out integer, out text)
  owner to postgres;

create function pg_catalog.ts_parse(parser_name text, txt text, out tokid integer, out token text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_parse
;

comment on function pg_catalog.ts_parse(text, text, out integer, out text)
is 'parse text to tokens';

alter function pg_catalog.ts_parse(text, text, out integer, out text)
  owner to postgres;

create function pg_catalog.prsd_start(internal, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_start
;

comment on function pg_catalog.prsd_start(internal, integer)
is '(internal)';

alter function pg_catalog.prsd_start(internal, integer)
  owner to postgres;

create function pg_catalog.prsd_nexttoken(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_nexttoken
;

comment on function pg_catalog.prsd_nexttoken(internal, internal, internal)
is '(internal)';

alter function pg_catalog.prsd_nexttoken(internal, internal, internal)
  owner to postgres;

create function pg_catalog.prsd_end(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_end
;

comment on function pg_catalog.prsd_end(internal)
is '(internal)';

alter function pg_catalog.prsd_end(internal)
  owner to postgres;

create function pg_catalog.prsd_headline(internal, internal, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_headline
;

comment on function pg_catalog.prsd_headline(internal, internal, tsquery)
is '(internal)';

alter function pg_catalog.prsd_headline(internal, internal, tsquery)
  owner to postgres;

create function pg_catalog.prsd_lextype(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_lextype
;

comment on function pg_catalog.prsd_lextype(internal)
is '(internal)';

alter function pg_catalog.prsd_lextype(internal)
  owner to postgres;

create function pg_catalog.ts_lexize(regdictionary, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_lexize
;

comment on function pg_catalog.ts_lexize(regdictionary, text)
is 'normalize one word by dictionary';

alter function pg_catalog.ts_lexize(regdictionary, text)
  owner to postgres;

create function pg_catalog.gin_cmp_tslexeme(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_cmp_tslexeme
;

comment on function pg_catalog.gin_cmp_tslexeme(text, text)
is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_tslexeme(text, text)
  owner to postgres;

create function pg_catalog.dsimple_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsimple_init
;

comment on function pg_catalog.dsimple_init(internal)
is '(internal)';

alter function pg_catalog.dsimple_init(internal)
  owner to postgres;

create function pg_catalog.dsimple_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsimple_lexize
;

comment on function pg_catalog.dsimple_lexize(internal, internal, internal, internal)
is '(internal)';

alter function pg_catalog.dsimple_lexize(internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.dsynonym_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsynonym_init
;

comment on function pg_catalog.dsynonym_init(internal)
is '(internal)';

alter function pg_catalog.dsynonym_init(internal)
  owner to postgres;

create function pg_catalog.dsynonym_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsynonym_lexize
;

comment on function pg_catalog.dsynonym_lexize(internal, internal, internal, internal)
is '(internal)';

alter function pg_catalog.dsynonym_lexize(internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.dispell_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dispell_init
;

comment on function pg_catalog.dispell_init(internal)
is '(internal)';

alter function pg_catalog.dispell_init(internal)
  owner to postgres;

create function pg_catalog.dispell_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dispell_lexize
;

comment on function pg_catalog.dispell_lexize(internal, internal, internal, internal)
is '(internal)';

alter function pg_catalog.dispell_lexize(internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.regconfigin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigin
;

comment on function pg_catalog.regconfigin(cstring)
is 'I/O';

alter function pg_catalog.regconfigin(cstring)
  owner to postgres;

create function pg_catalog.regconfigout(regconfig)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigout
;

comment on function pg_catalog.regconfigout(regconfig)
is 'I/O';

alter function pg_catalog.regconfigout(regconfig)
  owner to postgres;

create function pg_catalog.regconfigrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigrecv
;

comment on function pg_catalog.regconfigrecv(internal)
is 'I/O';

alter function pg_catalog.regconfigrecv(internal)
  owner to postgres;

create function pg_catalog.regconfigsend(regconfig)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigsend
;

comment on function pg_catalog.regconfigsend(regconfig)
is 'I/O';

alter function pg_catalog.regconfigsend(regconfig)
  owner to postgres;

create function pg_catalog.thesaurus_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.thesaurus_init
;

comment on function pg_catalog.thesaurus_init(internal)
is '(internal)';

alter function pg_catalog.thesaurus_init(internal)
  owner to postgres;

create function pg_catalog.thesaurus_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.thesaurus_lexize
;

comment on function pg_catalog.thesaurus_lexize(internal, internal, internal, internal)
is '(internal)';

alter function pg_catalog.thesaurus_lexize(internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.ts_headline(regconfig, text, tsquery, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery, text)
is 'generate headline';

alter function pg_catalog.ts_headline(regconfig, text, tsquery, text)
  owner to postgres;

create function pg_catalog.ts_headline(regconfig, text, tsquery)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery)
is 'generate headline';

alter function pg_catalog.ts_headline(regconfig, text, tsquery)
  owner to postgres;

create function pg_catalog.to_tsvector(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(regconfig, text)
is 'transform to tsvector';

alter function pg_catalog.to_tsvector(regconfig, text)
  owner to postgres;

create function pg_catalog.to_tsquery(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsquery
;

comment on function pg_catalog.to_tsquery(regconfig, text)
is 'make tsquery';

alter function pg_catalog.to_tsquery(regconfig, text)
  owner to postgres;

create function pg_catalog.plainto_tsquery(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.plainto_tsquery
;

comment on function pg_catalog.plainto_tsquery(regconfig, text)
is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery(regconfig, text)
  owner to postgres;

create function pg_catalog.to_tsvector(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(text)
is 'transform to tsvector';

alter function pg_catalog.to_tsvector(text)
  owner to postgres;

create function pg_catalog.to_tsquery(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsquery
;

comment on function pg_catalog.to_tsquery(text)
is 'make tsquery';

alter function pg_catalog.to_tsquery(text)
  owner to postgres;

create function pg_catalog.plainto_tsquery(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.plainto_tsquery
;

comment on function pg_catalog.plainto_tsquery(text)
is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery(text)
  owner to postgres;

create function pg_catalog.tsvector_update_trigger()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_update_trigger
;

comment on function pg_catalog.tsvector_update_trigger()
is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger()
  owner to postgres;

create function pg_catalog.tsvector_update_trigger_column()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_update_trigger_column
;

comment on function pg_catalog.tsvector_update_trigger_column()
is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger_column()
  owner to postgres;

create function pg_catalog.ts_headline(text, tsquery, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(text, tsquery, text)
is 'generate headline';

alter function pg_catalog.ts_headline(text, tsquery, text)
  owner to postgres;

create function pg_catalog.ts_headline(text, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(text, tsquery)
is 'generate headline';

alter function pg_catalog.ts_headline(text, tsquery)
  owner to postgres;

create function pg_catalog.pg_ts_parser_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_parser_is_visible
;

comment on function pg_catalog.pg_ts_parser_is_visible(oid)
is 'is text search parser visible in search path?';

alter function pg_catalog.pg_ts_parser_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_ts_dict_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_dict_is_visible
;

comment on function pg_catalog.pg_ts_dict_is_visible(oid)
is 'is text search dictionary visible in search path?';

alter function pg_catalog.pg_ts_dict_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_ts_config_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_config_is_visible
;

comment on function pg_catalog.pg_ts_config_is_visible(oid)
is 'is text search configuration visible in search path?';

alter function pg_catalog.pg_ts_config_is_visible(oid)
  owner to postgres;

create function pg_catalog.get_current_ts_config()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_current_ts_config
;

comment on function pg_catalog.get_current_ts_config()
is 'get current tsearch configuration';

alter function pg_catalog.get_current_ts_config()
  owner to postgres;

create function pg_catalog.ts_match_tt(text, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_match_tt
;

comment on function pg_catalog.ts_match_tt(text, text)
is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tt(text, text)
  owner to postgres;

create function pg_catalog.ts_match_tq(text, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_match_tq
;

comment on function pg_catalog.ts_match_tq(text, tsquery)
is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tq(text, tsquery)
  owner to postgres;

create function pg_catalog.pg_ts_template_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_template_is_visible
;

comment on function pg_catalog.pg_ts_template_is_visible(oid)
is 'is text search template visible in search path?';

alter function pg_catalog.pg_ts_template_is_visible(oid)
  owner to postgres;

create function pg_catalog.regdictionaryin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionaryin
;

comment on function pg_catalog.regdictionaryin(cstring)
is 'I/O';

alter function pg_catalog.regdictionaryin(cstring)
  owner to postgres;

create function pg_catalog.regdictionaryout(regdictionary)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionaryout
;

comment on function pg_catalog.regdictionaryout(regdictionary)
is 'I/O';

alter function pg_catalog.regdictionaryout(regdictionary)
  owner to postgres;

create function pg_catalog.regdictionaryrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionaryrecv
;

comment on function pg_catalog.regdictionaryrecv(internal)
is 'I/O';

alter function pg_catalog.regdictionaryrecv(internal)
  owner to postgres;

create function pg_catalog.regdictionarysend(regdictionary)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionarysend
;

comment on function pg_catalog.regdictionarysend(regdictionary)
is 'I/O';

alter function pg_catalog.regdictionarysend(regdictionary)
  owner to postgres;

create function pg_catalog.pg_stat_reset_shared(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset_shared
;

comment on function pg_catalog.pg_stat_reset_shared(text)
is 'statistics: reset collected statistics shared across the cluster';

alter function pg_catalog.pg_stat_reset_shared(text)
  owner to postgres;

create function pg_catalog.pg_stat_reset_single_table_counters(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset_single_table_counters
;

comment on function pg_catalog.pg_stat_reset_single_table_counters(oid)
is 'statistics: reset collected statistics for a single table or index in the current database';

alter function pg_catalog.pg_stat_reset_single_table_counters(oid)
  owner to postgres;

create function pg_catalog.pg_stat_reset_single_function_counters(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset_single_function_counters
;

comment on function pg_catalog.pg_stat_reset_single_function_counters(oid)
is 'statistics: reset collected statistics for a single function in the current database';

alter function pg_catalog.pg_stat_reset_single_function_counters(oid)
  owner to postgres;

create function pg_catalog.pg_tablespace_location(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_location
;

comment on function pg_catalog.pg_tablespace_location(oid)
is 'tablespace location';

alter function pg_catalog.pg_tablespace_location(oid)
  owner to postgres;

create function pg_catalog.pg_create_physical_replication_slot(slot_name           name,
                                                               immediately_reserve boolean default false,
                                                               temporary           boolean default false,
  out                                                          slot_name           name, out lsn pg_lsn)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_create_physical_replication_slot
;

comment on function pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean, out name, out pg_lsn)
is 'create a physical replication slot';

alter function pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean, out name, out pg_lsn)
  owner to postgres;

create function pg_catalog.pg_drop_replication_slot(name)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_drop_replication_slot
;

comment on function pg_catalog.pg_drop_replication_slot(name)
is 'drop a replication slot';

alter function pg_catalog.pg_drop_replication_slot(name)
  owner to postgres;

create function pg_catalog.pg_get_replication_slots(out slot_name   name, out plugin name, out slot_type text,
                                                    out datoid      oid, out temporary boolean, out active boolean,
                                                    out active_pid  integer, out xmin xid, out catalog_xmin xid,
                                                    out restart_lsn pg_lsn, out confirmed_flush_lsn pg_lsn)
stable
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.pg_get_replication_slots
;

comment on function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out boolean,
                                                        out integer, out xid, out xid, out pg_lsn, out pg_lsn)
is 'information about replication slots currently in use';

alter function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out boolean, out integer, out xid, out xid, out pg_lsn, out pg_lsn)
  owner to postgres;

create function pg_catalog.pg_logical_slot_get_changes(                                               slot_name     name,
                                                                                                      upto_lsn      pg_lsn,
                                                                                                      upto_nchanges integer,
                                                                                                      options       text [] default '{}' :: text [],
  out                                                                                                 lsn           pg_lsn,
  out                                                                                                 xid           xid,
  out                                                                                                 data          text)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_get_changes
;

comment on function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                           out text)
is 'get changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid, out text)
  owner to postgres;

create function pg_catalog.pg_logical_slot_get_binary_changes(                                               slot_name     name,
                                                                                                             upto_lsn      pg_lsn,
                                                                                                             upto_nchanges integer,
                                                                                                             options       text [] default '{}' :: text [],
  out                                                                                                        lsn           pg_lsn,
  out                                                                                                        xid           xid,
  out                                                                                                        data          bytea)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_get_binary_changes
;

comment on function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                                  out bytea)
is 'get binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid, out bytea)
  owner to postgres;

create function pg_catalog.pg_logical_slot_peek_changes(                                               slot_name     name,
                                                                                                       upto_lsn      pg_lsn,
                                                                                                       upto_nchanges integer,
                                                                                                       options       text [] default '{}' :: text [],
  out                                                                                                  lsn           pg_lsn,
  out                                                                                                  xid           xid,
  out                                                                                                  data          text)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_peek_changes
;

comment on function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                            out text)
is 'peek at changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid, out text)
  owner to postgres;

create function pg_catalog.pg_logical_slot_peek_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer,
                                                               options   text [] default '{}' :: text [],
  out                                                          lsn       pg_lsn, out xid xid, out data bytea)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_peek_binary_changes
;

comment on function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                                   out bytea)
is 'peek at binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid, out bytea)
  owner to postgres;

create function pg_catalog.pg_create_logical_replication_slot(                                     slot_name name,
                                                                                                   plugin    name,
                                                                                                   temporary boolean default false,
  out                                                                                              slot_name text,
  out                                                                                              lsn       pg_lsn)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_create_logical_replication_slot
;

comment on function pg_catalog.pg_create_logical_replication_slot(name, name, boolean, out text, out pg_lsn)
is 'set up a logical replication slot';

alter function pg_catalog.pg_create_logical_replication_slot(name, name, boolean, out text, out pg_lsn)
  owner to postgres;

create function pg_catalog.to_jsonb(anyelement)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_jsonb
;

comment on function pg_catalog.to_jsonb(anyelement)
is 'map input to jsonb';

alter function pg_catalog.to_jsonb(anyelement)
  owner to postgres;

create function pg_catalog.pg_stat_get_snapshot_timestamp()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_snapshot_timestamp
;

comment on function pg_catalog.pg_stat_get_snapshot_timestamp()
is 'statistics: timestamp of the current statistics snapshot';

alter function pg_catalog.pg_stat_get_snapshot_timestamp()
  owner to postgres;

create function pg_catalog.gin_clean_pending_list(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.gin_clean_pending_list
;

comment on function pg_catalog.gin_clean_pending_list(regclass)
is 'clean up GIN pending list';

alter function pg_catalog.gin_clean_pending_list(regclass)
  owner to postgres;

create function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_consistent
;

comment on function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal)
is 'GiST tsvector support (obsolete)';

alter function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal)
  owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsquery
;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal)
is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal,
                                                  internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_consistent
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal,
                                                      internal, internal)
is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_consistent
;

comment on function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal)
is 'GiST tsquery support (obsolete)';

alter function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal)
  owner to postgres;

create function pg_catalog.inet_spg_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_config
;

comment on function pg_catalog.inet_spg_config(internal, internal)
is 'SP-GiST support';

alter function pg_catalog.inet_spg_config(internal, internal)
  owner to postgres;

create function pg_catalog.inet_spg_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_choose
;

comment on function pg_catalog.inet_spg_choose(internal, internal)
is 'SP-GiST support';

alter function pg_catalog.inet_spg_choose(internal, internal)
  owner to postgres;

create function pg_catalog.inet_spg_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_picksplit
;

comment on function pg_catalog.inet_spg_picksplit(internal, internal)
is 'SP-GiST support';

alter function pg_catalog.inet_spg_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.inet_spg_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_inner_consistent
;

comment on function pg_catalog.inet_spg_inner_consistent(internal, internal)
is 'SP-GiST support';

alter function pg_catalog.inet_spg_inner_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.inet_spg_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_leaf_consistent
;

comment on function pg_catalog.inet_spg_leaf_consistent(internal, internal)
is 'SP-GiST support';

alter function pg_catalog.inet_spg_leaf_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.pg_current_logfile()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_logfile
;

comment on function pg_catalog.pg_current_logfile()
is 'current logging collector file location';

alter function pg_catalog.pg_current_logfile()
  owner to postgres;

create function pg_catalog.pg_current_logfile(text)
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_logfile
;

comment on function pg_catalog.pg_current_logfile(text)
is 'current logging collector file location';

alter function pg_catalog.pg_current_logfile(text)
  owner to postgres;

create function pg_catalog.jsonb_send(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_send
;

comment on function pg_catalog.jsonb_send(jsonb)
is 'I/O';

alter function pg_catalog.jsonb_send(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_out(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_out
;

comment on function pg_catalog.jsonb_out(jsonb)
is 'I/O';

alter function pg_catalog.jsonb_out(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_recv
;

comment on function pg_catalog.jsonb_recv(internal)
is 'I/O';

alter function pg_catalog.jsonb_recv(internal)
  owner to postgres;

create function pg_catalog.jsonb_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_in
;

comment on function pg_catalog.jsonb_in(cstring)
is 'I/O';

alter function pg_catalog.jsonb_in(cstring)
  owner to postgres;

create function pg_catalog.pg_get_function_arg_default(oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_arg_default
;

comment on function pg_catalog.pg_get_function_arg_default(oid, integer)
is 'function argument default';

alter function pg_catalog.pg_get_function_arg_default(oid, integer)
  owner to postgres;

create function pg_catalog.pg_export_snapshot()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_export_snapshot
;

comment on function pg_catalog.pg_export_snapshot()
is 'export a snapshot';

alter function pg_catalog.pg_export_snapshot()
  owner to postgres;

create function pg_catalog.pg_is_in_recovery()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_in_recovery
;

comment on function pg_catalog.pg_is_in_recovery()
is 'true if server is in recovery';

alter function pg_catalog.pg_is_in_recovery()
  owner to postgres;

create function pg_catalog.money(integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.money
;

comment on function pg_catalog.money(integer)
is 'convert int4 to money';

alter function pg_catalog.money(integer)
  owner to postgres;

create function pg_catalog.money(bigint)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.money
;

comment on function pg_catalog.money(bigint)
is 'convert int8 to money';

alter function pg_catalog.money(bigint)
  owner to postgres;

create function pg_catalog.pg_is_in_backup()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_in_backup
;

comment on function pg_catalog.pg_is_in_backup()
is 'true if server is in online backup';

alter function pg_catalog.pg_is_in_backup()
  owner to postgres;

create function pg_catalog.pg_backup_start_time()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_backup_start_time
;

comment on function pg_catalog.pg_backup_start_time()
is 'start time of an online backup';

alter function pg_catalog.pg_backup_start_time()
  owner to postgres;

create function pg_catalog.pg_collation_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_collation_is_visible
;

comment on function pg_catalog.pg_collation_is_visible(oid)
is 'is collation visible in search path?';

alter function pg_catalog.pg_collation_is_visible(oid)
  owner to postgres;

create function pg_catalog.array_typanalyze(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_typanalyze
;

comment on function pg_catalog.array_typanalyze(internal)
is 'array typanalyze';

alter function pg_catalog.array_typanalyze(internal)
  owner to postgres;

create function pg_catalog.arraycontsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontsel
;

comment on function pg_catalog.arraycontsel(internal, oid, internal, integer)
is 'restriction selectivity for array-containment operators';

alter function pg_catalog.arraycontsel(internal, oid, internal, integer)
  owner to postgres;

create function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontjoinsel
;

comment on function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for array-containment operators';

alter function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal)
  owner to postgres;

create function pg_catalog.pg_get_multixact_members(multixid xid, out xid xid, out mode text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_multixact_members
;

comment on function pg_catalog.pg_get_multixact_members(xid, out xid, out text)
is 'view members of a multixactid';

alter function pg_catalog.pg_get_multixact_members(xid, out xid, out text)
  owner to postgres;

create function pg_catalog.pg_last_wal_receive_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_wal_receive_lsn
;

comment on function pg_catalog.pg_last_wal_receive_lsn()
is 'current wal flush location';

alter function pg_catalog.pg_last_wal_receive_lsn()
  owner to postgres;

create function pg_catalog.pg_last_wal_replay_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_wal_replay_lsn
;

comment on function pg_catalog.pg_last_wal_replay_lsn()
is 'last wal replay location';

alter function pg_catalog.pg_last_wal_replay_lsn()
  owner to postgres;

create function pg_catalog.cash_div_cash(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_cash
;

comment on function pg_catalog.cash_div_cash(money, money)
is 'implementation of / operator';

alter function pg_catalog.cash_div_cash(money, money)
  owner to postgres;

create function pg_catalog.numeric(money)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(money)
is 'convert money to numeric';

alter function pg_catalog.numeric(money)
  owner to postgres;

create function pg_catalog.money(numeric)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.money
;

comment on function pg_catalog.money(numeric)
is 'convert numeric to money';

alter function pg_catalog.money(numeric)
  owner to postgres;

create function pg_catalog.pg_read_file(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_file
;

comment on function pg_catalog.pg_read_file(text)
is 'read text from a file';

alter function pg_catalog.pg_read_file(text)
  owner to postgres;

create function pg_catalog.pg_read_binary_file(text, bigint, bigint)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_binary_file
;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint)
is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text, bigint, bigint)
  owner to postgres;

create function pg_catalog.pg_read_binary_file(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_binary_file
;

comment on function pg_catalog.pg_read_binary_file(text)
is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text)
  owner to postgres;

create function pg_catalog.pg_opfamily_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_opfamily_is_visible
;

comment on function pg_catalog.pg_opfamily_is_visible(oid)
is 'is opfamily visible in search path?';

alter function pg_catalog.pg_opfamily_is_visible(oid)
  owner to postgres;

create function pg_catalog.pg_last_xact_replay_timestamp()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_xact_replay_timestamp
;

comment on function pg_catalog.pg_last_xact_replay_timestamp()
is 'timestamp of last replay xact';

alter function pg_catalog.pg_last_xact_replay_timestamp()
  owner to postgres;

create function pg_catalog.anyrange_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyrange_in
;

comment on function pg_catalog.anyrange_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.anyrange_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.anyrange_out(anyrange)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyrange_out
;

comment on function pg_catalog.anyrange_out(anyrange)
is 'I/O';

alter function pg_catalog.anyrange_out(anyrange)
  owner to postgres;

create function pg_catalog.range_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_in
;

comment on function pg_catalog.range_in(cstring, oid, integer)
is 'I/O';

alter function pg_catalog.range_in(cstring, oid, integer)
  owner to postgres;

create function pg_catalog.range_out(anyrange)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_out
;

comment on function pg_catalog.range_out(anyrange)
is 'I/O';

alter function pg_catalog.range_out(anyrange)
  owner to postgres;

create function pg_catalog.range_recv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_recv
;

comment on function pg_catalog.range_recv(internal, oid, integer)
is 'I/O';

alter function pg_catalog.range_recv(internal, oid, integer)
  owner to postgres;

create function pg_catalog.range_send(anyrange)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_send
;

comment on function pg_catalog.range_send(anyrange)
is 'I/O';

alter function pg_catalog.range_send(anyrange)
  owner to postgres;

create function pg_catalog.pg_identify_object(classid oid, objid oid, objsubid integer, out type text, out schema text,
                                                                                        out name text,
                                                                                        out identity text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_identify_object
;

comment on function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text)
is 'get machine-parseable identification of SQL object';

alter function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text)
  owner to postgres;

create function pg_catalog.int4range(integer, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range
;

comment on function pg_catalog.int4range(integer, integer)
is 'int4range constructor';

alter function pg_catalog.int4range(integer, integer)
  owner to postgres;

create function pg_catalog.int4range(integer, integer, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range
;

comment on function pg_catalog.int4range(integer, integer, text)
is 'int4range constructor';

alter function pg_catalog.int4range(integer, integer, text)
  owner to postgres;

create function pg_catalog.pg_relation_is_updatable(regclass, boolean)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_relation_is_updatable
;

comment on function pg_catalog.pg_relation_is_updatable(regclass, boolean)
is 'is a relation insertable/updatable/deletable';

alter function pg_catalog.pg_relation_is_updatable(regclass, boolean)
  owner to postgres;

create function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_column_is_updatable
;

comment on function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean)
is 'is a column updatable';

alter function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean)
  owner to postgres;

create function pg_catalog.numrange(numeric, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numrange
;

comment on function pg_catalog.numrange(numeric, numeric)
is 'numrange constructor';

alter function pg_catalog.numrange(numeric, numeric)
  owner to postgres;

create function pg_catalog.numrange(numeric, numeric, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numrange
;

comment on function pg_catalog.numrange(numeric, numeric, text)
is 'numrange constructor';

alter function pg_catalog.numrange(numeric, numeric, text)
  owner to postgres;

create function pg_catalog.make_date(year integer, month integer, day integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_date
;

comment on function pg_catalog.make_date(integer, integer, integer)
is 'construct date';

alter function pg_catalog.make_date(integer, integer, integer)
  owner to postgres;

create function pg_catalog.make_time(hour integer, min integer, sec double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_time
;

comment on function pg_catalog.make_time(integer, integer, double precision)
is 'construct time';

alter function pg_catalog.make_time(integer, integer, double precision)
  owner to postgres;

create function pg_catalog.lower(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower
;

comment on function pg_catalog.lower(anyrange)
is 'lower bound of range';

alter function pg_catalog.lower(anyrange)
  owner to postgres;

create function pg_catalog.upper(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper
;

comment on function pg_catalog.upper(anyrange)
is 'upper bound of range';

alter function pg_catalog.upper(anyrange)
  owner to postgres;

create function pg_catalog.isempty(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isempty
;

comment on function pg_catalog.isempty(anyrange)
is 'is the range empty?';

alter function pg_catalog.isempty(anyrange)
  owner to postgres;

create function pg_catalog.lower_inc(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower_inc
;

comment on function pg_catalog.lower_inc(anyrange)
is 'is the range''s lower bound inclusive?';

alter function pg_catalog.lower_inc(anyrange)
  owner to postgres;

create function pg_catalog.upper_inc(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper_inc
;

comment on function pg_catalog.upper_inc(anyrange)
is 'is the range''s upper bound inclusive?';

alter function pg_catalog.upper_inc(anyrange)
  owner to postgres;

create function pg_catalog.lower_inf(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower_inf
;

comment on function pg_catalog.lower_inf(anyrange)
is 'is the range''s lower bound infinite?';

alter function pg_catalog.lower_inf(anyrange)
  owner to postgres;

create function pg_catalog.upper_inf(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper_inf
;

comment on function pg_catalog.upper_inf(anyrange)
is 'is the range''s upper bound infinite?';

alter function pg_catalog.upper_inf(anyrange)
  owner to postgres;

create function pg_catalog.range_eq(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_eq
;

comment on function pg_catalog.range_eq(anyrange, anyrange)
is 'implementation of = operator';

alter function pg_catalog.range_eq(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_ne(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_ne
;

comment on function pg_catalog.range_ne(anyrange, anyrange)
is 'implementation of <> operator';

alter function pg_catalog.range_ne(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_overlaps(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_overlaps
;

comment on function pg_catalog.range_overlaps(anyrange, anyrange)
is 'implementation of && operator';

alter function pg_catalog.range_overlaps(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_contains_elem(anyrange, anyelement)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_contains_elem
;

comment on function pg_catalog.range_contains_elem(anyrange, anyelement)
is 'implementation of @> operator';

alter function pg_catalog.range_contains_elem(anyrange, anyelement)
  owner to postgres;

create function pg_catalog.range_contains(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_contains
;

comment on function pg_catalog.range_contains(anyrange, anyrange)
is 'implementation of @> operator';

alter function pg_catalog.range_contains(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.elem_contained_by_range(anyelement, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.elem_contained_by_range
;

comment on function pg_catalog.elem_contained_by_range(anyelement, anyrange)
is 'implementation of <@ operator';

alter function pg_catalog.elem_contained_by_range(anyelement, anyrange)
  owner to postgres;

create function pg_catalog.range_contained_by(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_contained_by
;

comment on function pg_catalog.range_contained_by(anyrange, anyrange)
is 'implementation of <@ operator';

alter function pg_catalog.range_contained_by(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_adjacent(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_adjacent
;

comment on function pg_catalog.range_adjacent(anyrange, anyrange)
is 'implementation of -|- operator';

alter function pg_catalog.range_adjacent(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_before(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_before
;

comment on function pg_catalog.range_before(anyrange, anyrange)
is 'implementation of << operator';

alter function pg_catalog.range_before(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_after(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_after
;

comment on function pg_catalog.range_after(anyrange, anyrange)
is 'implementation of >> operator';

alter function pg_catalog.range_after(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_overleft(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_overleft
;

comment on function pg_catalog.range_overleft(anyrange, anyrange)
is 'implementation of &< operator';

alter function pg_catalog.range_overleft(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_overright(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_overright
;

comment on function pg_catalog.range_overright(anyrange, anyrange)
is 'implementation of &> operator';

alter function pg_catalog.range_overright(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_union(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_union
;

comment on function pg_catalog.range_union(anyrange, anyrange)
is 'implementation of + operator';

alter function pg_catalog.range_union(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_intersect(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_intersect
;

comment on function pg_catalog.range_intersect(anyrange, anyrange)
is 'implementation of * operator';

alter function pg_catalog.range_intersect(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_minus(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_minus
;

comment on function pg_catalog.range_minus(anyrange, anyrange)
is 'implementation of - operator';

alter function pg_catalog.range_minus(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_cmp(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_cmp
;

comment on function pg_catalog.range_cmp(anyrange, anyrange)
is 'less-equal-greater';

alter function pg_catalog.range_cmp(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_lt(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_lt
;

comment on function pg_catalog.range_lt(anyrange, anyrange)
is 'implementation of < operator';

alter function pg_catalog.range_lt(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_le(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_le
;

comment on function pg_catalog.range_le(anyrange, anyrange)
is 'implementation of <= operator';

alter function pg_catalog.range_le(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_ge(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_ge
;

comment on function pg_catalog.range_ge(anyrange, anyrange)
is 'implementation of >= operator';

alter function pg_catalog.range_ge(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_gt(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gt
;

comment on function pg_catalog.range_gt(anyrange, anyrange)
is 'implementation of > operator';

alter function pg_catalog.range_gt(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_consistent
;

comment on function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal)
is 'GiST support';

alter function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal)
  owner to postgres;

create function pg_catalog.range_gist_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_union
;

comment on function pg_catalog.range_gist_union(internal, internal)
is 'GiST support';

alter function pg_catalog.range_gist_union(internal, internal)
  owner to postgres;

create function pg_catalog.range_gist_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_compress
;

comment on function pg_catalog.range_gist_compress(internal)
is 'GiST support';

alter function pg_catalog.range_gist_compress(internal)
  owner to postgres;

create function pg_catalog.range_gist_decompress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_decompress
;

comment on function pg_catalog.range_gist_decompress(internal)
is 'GiST support';

alter function pg_catalog.range_gist_decompress(internal)
  owner to postgres;

create function pg_catalog.range_gist_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_penalty
;

comment on function pg_catalog.range_gist_penalty(internal, internal, internal)
is 'GiST support';

alter function pg_catalog.range_gist_penalty(internal, internal, internal)
  owner to postgres;

create function pg_catalog.range_gist_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_picksplit
;

comment on function pg_catalog.range_gist_picksplit(internal, internal)
is 'GiST support';

alter function pg_catalog.range_gist_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.range_gist_same(anyrange, anyrange, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_same
;

comment on function pg_catalog.range_gist_same(anyrange, anyrange, internal)
is 'GiST support';

alter function pg_catalog.range_gist_same(anyrange, anyrange, internal)
  owner to postgres;

create function pg_catalog.hash_range(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_range
;

comment on function pg_catalog.hash_range(anyrange)
is 'hash a range';

alter function pg_catalog.hash_range(anyrange)
  owner to postgres;

create function pg_catalog.int4range_canonical(int4range)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range_canonical
;

comment on function pg_catalog.int4range_canonical(int4range)
is 'convert an int4 range to canonical form';

alter function pg_catalog.int4range_canonical(int4range)
  owner to postgres;

create function pg_catalog.daterange_canonical(daterange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange_canonical
;

comment on function pg_catalog.daterange_canonical(daterange)
is 'convert a date range to canonical form';

alter function pg_catalog.daterange_canonical(daterange)
  owner to postgres;

create function pg_catalog.range_typanalyze(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_typanalyze
;

comment on function pg_catalog.range_typanalyze(internal)
is 'range typanalyze';

alter function pg_catalog.range_typanalyze(internal)
  owner to postgres;

create function pg_catalog.timestamp_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_transform
;

comment on function pg_catalog.timestamp_transform(internal)
is 'transform a timestamp length coercion';

alter function pg_catalog.timestamp_transform(internal)
  owner to postgres;

create function pg_catalog.interval_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_transform
;

comment on function pg_catalog.interval_transform(internal)
is 'transform an interval length coercion';

alter function pg_catalog.interval_transform(internal)
  owner to postgres;

create function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarraytriconsistent
;

comment on function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal,
                                                     internal)
is 'GIN array support';

alter function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal)
  owner to postgres;

create function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal,
                                                     internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_triconsistent
;

comment on function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal,
                                                         internal)
is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal)
  owner to postgres;

create function pg_catalog.int4range_subdiff(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range_subdiff
;

comment on function pg_catalog.int4range_subdiff(integer, integer)
is 'float8 difference of two int4 values';

alter function pg_catalog.int4range_subdiff(integer, integer)
  owner to postgres;

create function pg_catalog.int8range_subdiff(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range_subdiff
;

comment on function pg_catalog.int8range_subdiff(bigint, bigint)
is 'float8 difference of two int8 values';

alter function pg_catalog.int8range_subdiff(bigint, bigint)
  owner to postgres;

create function pg_catalog.numrange_subdiff(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numrange_subdiff
;

comment on function pg_catalog.numrange_subdiff(numeric, numeric)
is 'float8 difference of two numeric values';

alter function pg_catalog.numrange_subdiff(numeric, numeric)
  owner to postgres;

create function pg_catalog.daterange_subdiff(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange_subdiff
;

comment on function pg_catalog.daterange_subdiff(date, date)
is 'float8 difference of two date values';

alter function pg_catalog.daterange_subdiff(date, date)
  owner to postgres;

create function pg_catalog.int8range_canonical(int8range)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range_canonical
;

comment on function pg_catalog.int8range_canonical(int8range)
is 'convert an int8 range to canonical form';

alter function pg_catalog.int8range_canonical(int8range)
  owner to postgres;

create function pg_catalog.tsrange_subdiff(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsrange_subdiff
;

comment on function pg_catalog.tsrange_subdiff(timestamp, timestamp)
is 'float8 difference of two timestamp values';

alter function pg_catalog.tsrange_subdiff(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tstzrange_subdiff
;

comment on function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone)
is 'float8 difference of two timestamp with time zone values';

alter function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.jsonb_object_keys(jsonb)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_object_keys
;

comment on function pg_catalog.jsonb_object_keys(jsonb)
is 'get jsonb object keys';

alter function pg_catalog.jsonb_object_keys(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_each_text(from_json jsonb, out key text, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_each_text
;

comment on function pg_catalog.jsonb_each_text(jsonb, out text, out text)
is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each_text(jsonb, out text, out text)
  owner to postgres;

create function pg_catalog.tsrange(timestamp, timestamp)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsrange
;

comment on function pg_catalog.tsrange(timestamp, timestamp)
is 'tsrange constructor';

alter function pg_catalog.tsrange(timestamp, timestamp)
  owner to postgres;

create function pg_catalog.tsrange(timestamp, timestamp, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsrange
;

comment on function pg_catalog.tsrange(timestamp, timestamp, text)
is 'tsrange constructor';

alter function pg_catalog.tsrange(timestamp, timestamp, text)
  owner to postgres;

create function pg_catalog.pg_sleep_for(interval)
  returns void
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.pg_sleep(
         extract(epoch from pg_catalog.clock_timestamp() operator (pg_catalog.+) $1) operator (pg_catalog.-)
         extract(epoch from pg_catalog.clock_timestamp()))
$$;

comment on function pg_catalog.pg_sleep_for(interval)
is 'sleep for the specified interval';

alter function pg_catalog.pg_sleep_for(interval)
  owner to postgres;

create function pg_catalog.pg_sleep_until(timestamp with time zone)
  returns void
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.pg_sleep(
         extract(epoch from $1) operator (pg_catalog.-) extract(epoch from pg_catalog.clock_timestamp()))
$$;

comment on function pg_catalog.pg_sleep_until(timestamp with time zone)
is 'sleep until the specified time';

alter function pg_catalog.pg_sleep_until(timestamp with time zone)
  owner to postgres;

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tstzrange
;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone)
is 'tstzrange constructor';

alter function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tstzrange
;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text)
is 'tstzrange constructor';

alter function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text)
  owner to postgres;

create function pg_catalog.mxid_age(xid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mxid_age
;

comment on function pg_catalog.mxid_age(xid)
is 'age of a multi-transaction ID, in multi-transactions before current multi-transaction';

alter function pg_catalog.mxid_age(xid)
  owner to postgres;

create function pg_catalog.jsonb_extract_path_text(from_json jsonb, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_extract_path_text
;

comment on function pg_catalog.jsonb_extract_path_text(jsonb, text [])
is 'get value from jsonb as text with path elements';

alter function pg_catalog.jsonb_extract_path_text(jsonb, text [])
  owner to postgres;

create function pg_catalog.daterange(date, date)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange
;

comment on function pg_catalog.daterange(date, date)
is 'daterange constructor';

alter function pg_catalog.daterange(date, date)
  owner to postgres;

create function pg_catalog.daterange(date, date, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange
;

comment on function pg_catalog.daterange(date, date, text)
is 'daterange constructor';

alter function pg_catalog.daterange(date, date, text)
  owner to postgres;

create function pg_catalog.acldefault("char", oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.acldefault
;

comment on function pg_catalog.acldefault("char", oid)
is 'TODO';

alter function pg_catalog.acldefault("char", oid)
  owner to postgres;

create function pg_catalog.time_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_transform
;

comment on function pg_catalog.time_transform(internal)
is 'transform a time length coercion';

alter function pg_catalog.time_transform(internal)
  owner to postgres;

create function pg_catalog.int8range(bigint, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range
;

comment on function pg_catalog.int8range(bigint, bigint)
is 'int8range constructor';

alter function pg_catalog.int8range(bigint, bigint)
  owner to postgres;

create function pg_catalog.int8range(bigint, bigint, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range
;

comment on function pg_catalog.int8range(bigint, bigint, text)
is 'int8range constructor';

alter function pg_catalog.int8range(bigint, bigint, text)
  owner to postgres;

create function pg_catalog.json_object_field(from_json json, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_field
;

comment on function pg_catalog.json_object_field(json, text)
is 'implementation of -> operator';

alter function pg_catalog.json_object_field(json, text)
  owner to postgres;

create function pg_catalog.json_object_field_text(from_json json, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_field_text
;

comment on function pg_catalog.json_object_field_text(json, text)
is 'implementation of ->> operator';

alter function pg_catalog.json_object_field_text(json, text)
  owner to postgres;

create function pg_catalog.json_array_element(from_json json, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_array_element
;

comment on function pg_catalog.json_array_element(json, integer)
is 'implementation of -> operator';

alter function pg_catalog.json_array_element(json, integer)
  owner to postgres;

create function pg_catalog.json_array_element_text(from_json json, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_array_element_text
;

comment on function pg_catalog.json_array_element_text(json, integer)
is 'implementation of ->> operator';

alter function pg_catalog.json_array_element_text(json, integer)
  owner to postgres;

create function pg_catalog.json_extract_path(from_json json, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_extract_path
;

comment on function pg_catalog.json_extract_path(json, text [])
is 'get value from json with path elements';

alter function pg_catalog.json_extract_path(json, text [])
  owner to postgres;

create function pg_catalog.brin_summarize_new_values(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.brin_summarize_new_values
;

comment on function pg_catalog.brin_summarize_new_values(regclass)
is 'brin: standalone scan new table pages';

alter function pg_catalog.brin_summarize_new_values(regclass)
  owner to postgres;

create function pg_catalog.json_extract_path_text(from_json json, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_extract_path_text
;

comment on function pg_catalog.json_extract_path_text(json, text [])
is 'get value from json as text with path elements';

alter function pg_catalog.json_extract_path_text(json, text [])
  owner to postgres;

create function pg_catalog.pg_get_object_address(type text, name text [], args text [], out classid oid, out objid oid,
                                                                                        out objsubid integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_object_address
;

comment on function pg_catalog.pg_get_object_address(text, text [], text [], out oid, out oid, out integer)
is 'get OID-based object address from name/args arrays';

alter function pg_catalog.pg_get_object_address(text, text [], text [], out oid, out oid, out integer)
  owner to postgres;

create function pg_catalog.json_array_elements(from_json json, out value json)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_array_elements
;

comment on function pg_catalog.json_array_elements(json, out json)
is 'key value pairs of a json object';

alter function pg_catalog.json_array_elements(json, out json)
  owner to postgres;

create function pg_catalog.json_array_length(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_array_length
;

comment on function pg_catalog.json_array_length(json)
is 'length of json array';

alter function pg_catalog.json_array_length(json)
  owner to postgres;

create function pg_catalog.json_object_keys(json)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_object_keys
;

comment on function pg_catalog.json_object_keys(json)
is 'get json object keys';

alter function pg_catalog.json_object_keys(json)
  owner to postgres;

create function pg_catalog.json_each(from_json json, out key text, out value json)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_each
;

comment on function pg_catalog.json_each(json, out text, out json)
is 'key value pairs of a json object';

alter function pg_catalog.json_each(json, out text, out json)
  owner to postgres;

create function pg_catalog.json_each_text(from_json json, out key text, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_each_text
;

comment on function pg_catalog.json_each_text(json, out text, out text)
is 'key value pairs of a json object';

alter function pg_catalog.json_each_text(json, out text, out text)
  owner to postgres;

create function pg_catalog.json_populate_record(base anyelement, from_json json, use_json_as_text boolean default false)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_populate_record
;

comment on function pg_catalog.json_populate_record(anyelement, json, boolean)
is 'get record fields from a json object';

alter function pg_catalog.json_populate_record(anyelement, json, boolean)
  owner to postgres;

create function pg_catalog.json_populate_recordset(base             anyelement, from_json json,
                                                   use_json_as_text boolean default false)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_populate_recordset
;

comment on function pg_catalog.json_populate_recordset(anyelement, json, boolean)
is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_populate_recordset(anyelement, json, boolean)
  owner to postgres;

create function pg_catalog.json_typeof(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_typeof
;

comment on function pg_catalog.json_typeof(json)
is 'get the type of a json value';

alter function pg_catalog.json_typeof(json)
  owner to postgres;

create function pg_catalog.json_array_elements_text(from_json json, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_array_elements_text
;

comment on function pg_catalog.json_array_elements_text(json, out text)
is 'elements of json array';

alter function pg_catalog.json_array_elements_text(json, out text)
  owner to postgres;

create function pg_catalog.ordered_set_transition(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ordered_set_transition
;

comment on function pg_catalog.ordered_set_transition(internal, "any")
is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition(internal, "any")
  owner to postgres;

create function pg_catalog.ordered_set_transition_multi(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ordered_set_transition_multi
;

comment on function pg_catalog.ordered_set_transition_multi(internal, "any")
is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition_multi(internal, "any")
  owner to postgres;

create function pg_catalog.percentile_disc_final(internal, double precision, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_disc_final
;

comment on function pg_catalog.percentile_disc_final(internal, double precision, anyelement)
is 'aggregate final function';

alter function pg_catalog.percentile_disc_final(internal, double precision, anyelement)
  owner to postgres;

create function pg_catalog.percentile_cont_float8_final(internal, double precision)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_float8_final
;

comment on function pg_catalog.percentile_cont_float8_final(internal, double precision)
is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_final(internal, double precision)
  owner to postgres;

create function pg_catalog.percentile_cont_interval_final(internal, double precision)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_interval_final
;

comment on function pg_catalog.percentile_cont_interval_final(internal, double precision)
is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_final(internal, double precision)
  owner to postgres;

create function pg_catalog.percentile_disc_multi_final(internal, double precision [], anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_disc_multi_final
;

comment on function pg_catalog.percentile_disc_multi_final(internal, double precision [], anyelement)
is 'aggregate final function';

alter function pg_catalog.percentile_disc_multi_final(internal, double precision [], anyelement)
  owner to postgres;

create function pg_catalog.percentile_cont_float8_multi_final(internal, double precision [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_float8_multi_final
;

comment on function pg_catalog.percentile_cont_float8_multi_final(internal, double precision [])
is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_multi_final(internal, double precision [])
  owner to postgres;

create function pg_catalog.percentile_cont_interval_multi_final(internal, double precision [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_interval_multi_final
;

comment on function pg_catalog.percentile_cont_interval_multi_final(internal, double precision [])
is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_multi_final(internal, double precision [])
  owner to postgres;

create function pg_catalog.mode_final(internal, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mode_final
;

comment on function pg_catalog.mode_final(internal, anyelement)
is 'aggregate final function';

alter function pg_catalog.mode_final(internal, anyelement)
  owner to postgres;

create function pg_catalog.rank_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rank_final
;

comment on function pg_catalog.rank_final(internal, "any")
is 'aggregate final function';

alter function pg_catalog.rank_final(internal, "any")
  owner to postgres;

create function pg_catalog.percent_rank_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percent_rank_final
;

comment on function pg_catalog.percent_rank_final(internal, "any")
is 'aggregate final function';

alter function pg_catalog.percent_rank_final(internal, "any")
  owner to postgres;

create function pg_catalog.cume_dist_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cume_dist_final
;

comment on function pg_catalog.cume_dist_final(internal, "any")
is 'aggregate final function';

alter function pg_catalog.cume_dist_final(internal, "any")
  owner to postgres;

create function pg_catalog.dense_rank_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dense_rank_final
;

comment on function pg_catalog.dense_rank_final(internal, "any")
is 'aggregate final function';

alter function pg_catalog.dense_rank_final(internal, "any")
  owner to postgres;

create function pg_catalog.timestamp_izone_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_izone_transform
;

comment on function pg_catalog.timestamp_izone_transform(internal)
is 'transform a time zone adjustment';

alter function pg_catalog.timestamp_izone_transform(internal)
  owner to postgres;

create function pg_catalog.timestamp_zone_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_zone_transform
;

comment on function pg_catalog.timestamp_zone_transform(internal)
is 'transform a time zone adjustment';

alter function pg_catalog.timestamp_zone_transform(internal)
  owner to postgres;

create function pg_catalog.range_gist_fetch(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_fetch
;

comment on function pg_catalog.range_gist_fetch(internal)
is 'GiST support';

alter function pg_catalog.range_gist_fetch(internal)
  owner to postgres;

create function pg_catalog.brin_summarize_range(regclass, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.brin_summarize_range
;

comment on function pg_catalog.brin_summarize_range(regclass, bigint)
is 'brin: standalone scan new table pages';

alter function pg_catalog.brin_summarize_range(regclass, bigint)
  owner to postgres;

create function pg_catalog.brin_desummarize_range(regclass, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.brin_desummarize_range
;

comment on function pg_catalog.brin_desummarize_range(regclass, bigint)
is 'brin: desummarize page range';

alter function pg_catalog.brin_desummarize_range(regclass, bigint)
  owner to postgres;

create function pg_catalog.spg_quad_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_config
;

comment on function pg_catalog.spg_quad_config(internal, internal)
is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_config(internal, internal)
  owner to postgres;

create function pg_catalog.spg_quad_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_choose
;

comment on function pg_catalog.spg_quad_choose(internal, internal)
is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_choose(internal, internal)
  owner to postgres;

create function pg_catalog.spg_quad_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_picksplit
;

comment on function pg_catalog.spg_quad_picksplit(internal, internal)
is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.spg_quad_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_inner_consistent
;

comment on function pg_catalog.spg_quad_inner_consistent(internal, internal)
is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_inner_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.spg_quad_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_leaf_consistent
;

comment on function pg_catalog.spg_quad_leaf_consistent(internal, internal)
is 'SP-GiST support for quad tree and k-d tree over point';

alter function pg_catalog.spg_quad_leaf_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.spg_kd_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_config
;

comment on function pg_catalog.spg_kd_config(internal, internal)
is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_config(internal, internal)
  owner to postgres;

create function pg_catalog.spg_kd_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_choose
;

comment on function pg_catalog.spg_kd_choose(internal, internal)
is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_choose(internal, internal)
  owner to postgres;

create function pg_catalog.spg_kd_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_picksplit
;

comment on function pg_catalog.spg_kd_picksplit(internal, internal)
is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.spg_kd_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_inner_consistent
;

comment on function pg_catalog.spg_kd_inner_consistent(internal, internal)
is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_inner_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.spg_text_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_config
;

comment on function pg_catalog.spg_text_config(internal, internal)
is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_config(internal, internal)
  owner to postgres;

create function pg_catalog.spg_text_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_choose
;

comment on function pg_catalog.spg_text_choose(internal, internal)
is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_choose(internal, internal)
  owner to postgres;

create function pg_catalog.spg_text_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_picksplit
;

comment on function pg_catalog.spg_text_picksplit(internal, internal)
is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.spg_text_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_inner_consistent
;

comment on function pg_catalog.spg_text_inner_consistent(internal, internal)
is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_inner_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.spg_text_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_leaf_consistent
;

comment on function pg_catalog.spg_text_leaf_consistent(internal, internal)
is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_leaf_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.pg_sequence_last_value(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_sequence_last_value
;

comment on function pg_catalog.pg_sequence_last_value(regclass)
is 'sequence last value';

alter function pg_catalog.pg_sequence_last_value(regclass)
  owner to postgres;

create function pg_catalog.jsonb_ne(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_ne
;

comment on function pg_catalog.jsonb_ne(jsonb, jsonb)
is 'implementation of <> operator';

alter function pg_catalog.jsonb_ne(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_lt(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_lt
;

comment on function pg_catalog.jsonb_lt(jsonb, jsonb)
is 'implementation of < operator';

alter function pg_catalog.jsonb_lt(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_gt(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_gt
;

comment on function pg_catalog.jsonb_gt(jsonb, jsonb)
is 'implementation of > operator';

alter function pg_catalog.jsonb_gt(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_le(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_le
;

comment on function pg_catalog.jsonb_le(jsonb, jsonb)
is 'implementation of <= operator';

alter function pg_catalog.jsonb_le(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_ge(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_ge
;

comment on function pg_catalog.jsonb_ge(jsonb, jsonb)
is 'implementation of >= operator';

alter function pg_catalog.jsonb_ge(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_eq(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_eq
;

comment on function pg_catalog.jsonb_eq(jsonb, jsonb)
is 'implementation of = operator';

alter function pg_catalog.jsonb_eq(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_cmp(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_cmp
;

comment on function pg_catalog.jsonb_cmp(jsonb, jsonb)
is 'less-equal-greater';

alter function pg_catalog.jsonb_cmp(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_hash(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_hash
;

comment on function pg_catalog.jsonb_hash(jsonb)
is 'hash';

alter function pg_catalog.jsonb_hash(jsonb)
  owner to postgres;

create function pg_catalog.jsonb_contains(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_contains
;

comment on function pg_catalog.jsonb_contains(jsonb, jsonb)
is 'implementation of @> operator';

alter function pg_catalog.jsonb_contains(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.jsonb_exists(jsonb, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_exists
;

comment on function pg_catalog.jsonb_exists(jsonb, text)
is 'implementation of ? operator';

alter function pg_catalog.jsonb_exists(jsonb, text)
  owner to postgres;

create function pg_catalog.jsonb_exists_any(jsonb, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_exists_any
;

comment on function pg_catalog.jsonb_exists_any(jsonb, text [])
is 'implementation of ?| operator';

alter function pg_catalog.jsonb_exists_any(jsonb, text [])
  owner to postgres;

create function pg_catalog.jsonb_exists_all(jsonb, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_exists_all
;

comment on function pg_catalog.jsonb_exists_all(jsonb, text [])
is 'implementation of ?& operator';

alter function pg_catalog.jsonb_exists_all(jsonb, text [])
  owner to postgres;

create function pg_catalog.jsonb_contained(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_contained
;

comment on function pg_catalog.jsonb_contained(jsonb, jsonb)
is 'implementation of <@ operator';

alter function pg_catalog.jsonb_contained(jsonb, jsonb)
  owner to postgres;

create function pg_catalog.array_agg_array_transfn(internal, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_array_transfn
;

comment on function pg_catalog.array_agg_array_transfn(internal, anyarray)
is 'aggregate transition function';

alter function pg_catalog.array_agg_array_transfn(internal, anyarray)
  owner to postgres;

create function pg_catalog.array_agg_array_finalfn(internal, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_array_finalfn
;

comment on function pg_catalog.array_agg_array_finalfn(internal, anyarray)
is 'aggregate final function';

alter function pg_catalog.array_agg_array_finalfn(internal, anyarray)
  owner to postgres;

create function pg_catalog.range_merge(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_merge
;

comment on function pg_catalog.range_merge(anyrange, anyrange)
is 'the smallest range which includes both of the given ranges';

alter function pg_catalog.range_merge(anyrange, anyrange)
  owner to postgres;

create function pg_catalog.inet_merge(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_merge
;

comment on function pg_catalog.inet_merge(inet, inet)
is 'the smallest network which includes both of the given networks';

alter function pg_catalog.inet_merge(inet, inet)
  owner to postgres;

create function pg_catalog.bound_box(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bound_box
;

comment on function pg_catalog.bound_box(box, box)
is 'bounding box of two boxes';

alter function pg_catalog.bound_box(box, box)
  owner to postgres;

create function pg_catalog.inet_same_family(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_same_family
;

comment on function pg_catalog.inet_same_family(inet, inet)
is 'are the addresses from the same family?';

alter function pg_catalog.inet_same_family(inet, inet)
  owner to postgres;

create function pg_catalog.binary_upgrade_set_record_init_privs(boolean)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_record_init_privs
;

comment on function pg_catalog.binary_upgrade_set_record_init_privs(boolean)
is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_record_init_privs(boolean)
  owner to postgres;

create function pg_catalog.regnamespacein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespacein
;

comment on function pg_catalog.regnamespacein(cstring)
is 'I/O';

alter function pg_catalog.regnamespacein(cstring)
  owner to postgres;

create function pg_catalog.regnamespaceout(regnamespace)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespaceout
;

comment on function pg_catalog.regnamespaceout(regnamespace)
is 'I/O';

alter function pg_catalog.regnamespaceout(regnamespace)
  owner to postgres;

create function pg_catalog.to_regnamespace(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regnamespace
;

comment on function pg_catalog.to_regnamespace(text)
is 'convert namespace name to regnamespace';

alter function pg_catalog.to_regnamespace(text)
  owner to postgres;

create function pg_catalog.regnamespacerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespacerecv
;

comment on function pg_catalog.regnamespacerecv(internal)
is 'I/O';

alter function pg_catalog.regnamespacerecv(internal)
  owner to postgres;

create function pg_catalog.regnamespacesend(regnamespace)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespacesend
;

comment on function pg_catalog.regnamespacesend(regnamespace)
is 'I/O';

alter function pg_catalog.regnamespacesend(regnamespace)
  owner to postgres;

create function pg_catalog.box(point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(point)
is 'convert point to empty box';

alter function pg_catalog.box(point)
  owner to postgres;

create function pg_catalog.regroleout(regrole)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regroleout
;

comment on function pg_catalog.regroleout(regrole)
is 'I/O';

alter function pg_catalog.regroleout(regrole)
  owner to postgres;

create function pg_catalog.to_regrole(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regrole
;

comment on function pg_catalog.to_regrole(text)
is 'convert role name to regrole';

alter function pg_catalog.to_regrole(text)
  owner to postgres;

create function pg_catalog.regrolerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regrolerecv
;

comment on function pg_catalog.regrolerecv(internal)
is 'I/O';

alter function pg_catalog.regrolerecv(internal)
  owner to postgres;

create function pg_catalog.regrolesend(regrole)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regrolesend
;

comment on function pg_catalog.regrolesend(regrole)
is 'I/O';

alter function pg_catalog.regrolesend(regrole)
  owner to postgres;

create function pg_catalog.regrolein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regrolein
;

comment on function pg_catalog.regrolein(cstring)
is 'I/O';

alter function pg_catalog.regrolein(cstring)
  owner to postgres;

create function pg_catalog.brin_inclusion_opcinfo(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_opcinfo
;

comment on function pg_catalog.brin_inclusion_opcinfo(internal)
is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_opcinfo(internal)
  owner to postgres;

create function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_add_value
;

comment on function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal)
is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal)
  owner to postgres;

create function pg_catalog.brin_inclusion_consistent(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_consistent
;

comment on function pg_catalog.brin_inclusion_consistent(internal, internal, internal)
is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_consistent(internal, internal, internal)
  owner to postgres;

create function pg_catalog.brin_inclusion_union(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_union
;

comment on function pg_catalog.brin_inclusion_union(internal, internal, internal)
is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_union(internal, internal, internal)
  owner to postgres;

create function pg_catalog.macaddr8_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_in
;

comment on function pg_catalog.macaddr8_in(cstring)
is 'I/O';

alter function pg_catalog.macaddr8_in(cstring)
  owner to postgres;

create function pg_catalog.macaddr8_out(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_out
;

comment on function pg_catalog.macaddr8_out(macaddr8)
is 'I/O';

alter function pg_catalog.macaddr8_out(macaddr8)
  owner to postgres;

create function pg_catalog.trunc(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(macaddr8)
is 'MACADDR8 manufacturer fields';

alter function pg_catalog.trunc(macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_eq(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_eq
;

comment on function pg_catalog.macaddr8_eq(macaddr8, macaddr8)
is 'implementation of = operator';

alter function pg_catalog.macaddr8_eq(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_lt(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_lt
;

comment on function pg_catalog.macaddr8_lt(macaddr8, macaddr8)
is 'implementation of < operator';

alter function pg_catalog.macaddr8_lt(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_le(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_le
;

comment on function pg_catalog.macaddr8_le(macaddr8, macaddr8)
is 'implementation of <= operator';

alter function pg_catalog.macaddr8_le(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_gt(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_gt
;

comment on function pg_catalog.macaddr8_gt(macaddr8, macaddr8)
is 'implementation of > operator';

alter function pg_catalog.macaddr8_gt(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_ge(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_ge
;

comment on function pg_catalog.macaddr8_ge(macaddr8, macaddr8)
is 'implementation of >= operator';

alter function pg_catalog.macaddr8_ge(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_ne(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_ne
;

comment on function pg_catalog.macaddr8_ne(macaddr8, macaddr8)
is 'implementation of <> operator';

alter function pg_catalog.macaddr8_ne(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_cmp(macaddr8, macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_cmp
;

comment on function pg_catalog.macaddr8_cmp(macaddr8, macaddr8)
is 'less-equal-greater';

alter function pg_catalog.macaddr8_cmp(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_not(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_not
;

comment on function pg_catalog.macaddr8_not(macaddr8)
is 'implementation of ~ operator';

alter function pg_catalog.macaddr8_not(macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_and(macaddr8, macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_and
;

comment on function pg_catalog.macaddr8_and(macaddr8, macaddr8)
is 'implementation of & operator';

alter function pg_catalog.macaddr8_and(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_or(macaddr8, macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_or
;

comment on function pg_catalog.macaddr8_or(macaddr8, macaddr8)
is 'implementation of | operator';

alter function pg_catalog.macaddr8_or(macaddr8, macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8
;

comment on function pg_catalog.macaddr8(macaddr)
is 'convert macaddr to macaddr8';

alter function pg_catalog.macaddr8(macaddr)
  owner to postgres;

create function pg_catalog.macaddr(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr
;

comment on function pg_catalog.macaddr(macaddr8)
is 'convert macaddr8 to macaddr';

alter function pg_catalog.macaddr(macaddr8)
  owner to postgres;

create function pg_catalog.macaddr8_set7bit(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_set7bit
;

comment on function pg_catalog.macaddr8_set7bit(macaddr8)
is 'set 7th bit in macaddr8';

alter function pg_catalog.macaddr8_set7bit(macaddr8)
  owner to postgres;

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text)
is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text)
  owner to postgres;

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery)
is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(regconfig, jsonb, tsquery)
  owner to postgres;

create function pg_catalog.ts_headline(jsonb, tsquery, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(jsonb, tsquery, text)
is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb, tsquery, text)
  owner to postgres;

create function pg_catalog.ts_headline(jsonb, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(jsonb, tsquery)
is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb, tsquery)
  owner to postgres;

create function pg_catalog.ts_headline(regconfig, json, tsquery, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery, text)
is 'generate headline from json';

alter function pg_catalog.ts_headline(regconfig, json, tsquery, text)
  owner to postgres;

create function pg_catalog.ts_headline(regconfig, json, tsquery)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery)
is 'generate headline from json';

alter function pg_catalog.ts_headline(regconfig, json, tsquery)
  owner to postgres;

create function pg_catalog.ts_headline(json, tsquery, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(json, tsquery, text)
is 'generate headline from json';

alter function pg_catalog.ts_headline(json, tsquery, text)
  owner to postgres;

create function pg_catalog.ts_headline(json, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(json, tsquery)
is 'generate headline from json';

alter function pg_catalog.ts_headline(json, tsquery)
  owner to postgres;

create function pg_catalog.to_tsvector(jsonb)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(jsonb)
is 'transform jsonb to tsvector';

alter function pg_catalog.to_tsvector(jsonb)
  owner to postgres;

create function pg_catalog.to_tsvector(json)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(json)
is 'transform json to tsvector';

alter function pg_catalog.to_tsvector(json)
  owner to postgres;

create function pg_catalog.to_tsvector(regconfig, jsonb)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(regconfig, jsonb)
is 'transform jsonb to tsvector';

alter function pg_catalog.to_tsvector(regconfig, jsonb)
  owner to postgres;

create function pg_catalog.to_tsvector(regconfig, json)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(regconfig, json)
is 'transform json to tsvector';

alter function pg_catalog.to_tsvector(regconfig, json)
  owner to postgres;

create function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_table_rewrite_oid
;

comment on function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid)
is 'return Oid of the table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid)
  owner to postgres;

create function pg_catalog.pg_event_trigger_table_rewrite_reason()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_table_rewrite_reason
;

comment on function pg_catalog.pg_event_trigger_table_rewrite_reason()
is 'return reason code for table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_reason()
  owner to postgres;

create function pg_catalog.pg_event_trigger_ddl_commands(out classid      oid, out objid oid, out objsubid integer,
                                                         out command_tag  text, out object_type text,
                                                         out schema_name  text, out object_identity text,
                                                         out in_extension boolean, out command pg_ddl_command)
stable
strict
parallel restricted
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_ddl_commands
;

comment on function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text,
                                                             out text, out text, out boolean, out pg_ddl_command)
is 'list DDL actions being executed by the current command';

alter function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text, out text, out text, out boolean, out pg_ddl_command)
  owner to postgres;

create function pg_catalog.phraseto_tsquery(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.phraseto_tsquery
;

comment on function pg_catalog.phraseto_tsquery(text)
is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery(text)
  owner to postgres;

create function pg_catalog.tsquery_phrase(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_phrase
;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery)
is 'implementation of <-> operator';

alter function pg_catalog.tsquery_phrase(tsquery, tsquery)
  owner to postgres;

create function pg_catalog.tsquery_phrase(tsquery, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_phrase
;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery, integer)
is 'phrase-concatenate with distance';

alter function pg_catalog.tsquery_phrase(tsquery, tsquery, integer)
  owner to postgres;

create function pg_catalog.phraseto_tsquery(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.phraseto_tsquery
;

comment on function pg_catalog.phraseto_tsquery(regconfig, text)
is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery(regconfig, text)
  owner to postgres;

create function pg_catalog.spg_box_quad_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_config
;

comment on function pg_catalog.spg_box_quad_config(internal, internal)
is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_config(internal, internal)
  owner to postgres;

create function pg_catalog.spg_box_quad_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_choose
;

comment on function pg_catalog.spg_box_quad_choose(internal, internal)
is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_choose(internal, internal)
  owner to postgres;

create function pg_catalog.spg_box_quad_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_picksplit
;

comment on function pg_catalog.spg_box_quad_picksplit(internal, internal)
is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_picksplit(internal, internal)
  owner to postgres;

create function pg_catalog.spg_box_quad_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_inner_consistent
;

comment on function pg_catalog.spg_box_quad_inner_consistent(internal, internal)
is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_inner_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.spg_box_quad_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_leaf_consistent
;

comment on function pg_catalog.spg_box_quad_leaf_consistent(internal, internal)
is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_leaf_consistent(internal, internal)
  owner to postgres;

create function pg_catalog.pg_replication_origin_create(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_create
;

comment on function pg_catalog.pg_replication_origin_create(text)
is 'create a replication origin';

alter function pg_catalog.pg_replication_origin_create(text)
  owner to postgres;

create function pg_catalog.pg_replication_origin_drop(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_drop
;

comment on function pg_catalog.pg_replication_origin_drop(text)
is 'drop replication origin identified by its name';

alter function pg_catalog.pg_replication_origin_drop(text)
  owner to postgres;

create function pg_catalog.pg_replication_origin_oid(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_oid
;

comment on function pg_catalog.pg_replication_origin_oid(text)
is 'translate the replication origin''s name to its id';

alter function pg_catalog.pg_replication_origin_oid(text)
  owner to postgres;

create function pg_catalog.pg_replication_origin_session_setup(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_setup
;

comment on function pg_catalog.pg_replication_origin_session_setup(text)
is 'configure session to maintain replication progress tracking for the passed in origin';

alter function pg_catalog.pg_replication_origin_session_setup(text)
  owner to postgres;

create function pg_catalog.pg_replication_origin_session_reset()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_reset
;

comment on function pg_catalog.pg_replication_origin_session_reset()
is 'teardown configured replication progress tracking';

alter function pg_catalog.pg_replication_origin_session_reset()
  owner to postgres;

create function pg_catalog.pg_replication_origin_session_is_setup()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_is_setup
;

comment on function pg_catalog.pg_replication_origin_session_is_setup()
is 'is a replication origin configured in this session';

alter function pg_catalog.pg_replication_origin_session_is_setup()
  owner to postgres;

create function pg_catalog.pg_replication_origin_session_progress(boolean)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_progress
;

comment on function pg_catalog.pg_replication_origin_session_progress(boolean)
is 'get the replication progress of the current session';

alter function pg_catalog.pg_replication_origin_session_progress(boolean)
  owner to postgres;

create function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_xact_setup
;

comment on function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone)
is 'setup the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone)
  owner to postgres;

create function pg_catalog.pg_replication_origin_xact_reset()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_xact_reset
;

comment on function pg_catalog.pg_replication_origin_xact_reset()
is 'reset the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_reset()
  owner to postgres;

create function pg_catalog.pg_replication_origin_advance(text, pg_lsn)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_advance
;

comment on function pg_catalog.pg_replication_origin_advance(text, pg_lsn)
is 'advance replication identifier to specific location';

alter function pg_catalog.pg_replication_origin_advance(text, pg_lsn)
  owner to postgres;

create function pg_catalog.pg_replication_origin_progress(text, boolean)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_progress
;

comment on function pg_catalog.pg_replication_origin_progress(text, boolean)
is 'get an individual replication origin''s replication progress';

alter function pg_catalog.pg_replication_origin_progress(text, boolean)
  owner to postgres;

create function pg_catalog.pg_show_replication_origin_status(out local_id   oid, out external_id text,
                                                             out remote_lsn pg_lsn, out local_lsn pg_lsn)
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_show_replication_origin_status
;

comment on function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn)
is 'get progress for all replication origins';

alter function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn)
  owner to postgres;

create function pg_catalog.pg_stat_get_subscription(subid oid, out subid oid, out relid oid, out pid integer,
                                                               out received_lsn pg_lsn,
                                                               out last_msg_send_time timestamp with time zone,
                                                               out last_msg_receipt_time timestamp with time zone,
                                                               out latest_end_lsn pg_lsn,
                                                               out latest_end_time timestamp with time zone)
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_subscription
;

comment on function pg_catalog.pg_stat_get_subscription(oid, out oid, out oid, out integer, out pg_lsn,
                                                             out timestamp with time zone, out timestamp with time zone,
                                                             out pg_lsn, out timestamp with time zone)
is 'statistics: information about subscription';

alter function pg_catalog.pg_stat_get_subscription(oid, out oid, out oid, out integer, out pg_lsn, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone)
  owner to postgres;

create function pg_catalog.pg_get_publication_tables(pubname text, out relid oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_publication_tables
;

comment on function pg_catalog.pg_get_publication_tables(text, out oid)
is 'get OIDs of tables in a publication';

alter function pg_catalog.pg_get_publication_tables(text, out oid)
  owner to postgres;

create function pg_catalog.pg_get_replica_identity_index(regclass)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_get_replica_identity_index
;

comment on function pg_catalog.pg_get_replica_identity_index(regclass)
is 'oid of replica identity index if any';

alter function pg_catalog.pg_get_replica_identity_index(regclass)
  owner to postgres;

create function pg_catalog.pg_relation_is_publishable(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_is_publishable
;

comment on function pg_catalog.pg_relation_is_publishable(regclass)
is 'returns whether a relation can be part of a publication';

alter function pg_catalog.pg_relation_is_publishable(regclass)
  owner to postgres;

create function pg_catalog.scale(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scale
;

comment on function pg_catalog.scale(numeric)
is 'number of decimal digits in the fractional part';

alter function pg_catalog.scale(numeric)
  owner to postgres;

create function pg_catalog.ts_debug(config regconfig, document text, OUT alias text, OUT description text,
                                                                     OUT token text, OUT dictionaries regdictionary [],
                                                                     OUT dictionary regdictionary, OUT lexemes text [])
  returns SETOF record
stable
strict
parallel safe
language sql
as $$
SELECT tt.alias       AS alias,
       tt.description AS description,
       parse.token    AS token,
       ARRAY(SELECT m.mapdict :: pg_catalog.regdictionary
             FROM pg_catalog.pg_ts_config_map AS m
             WHERE m.mapcfg = $1
               AND m.maptokentype = parse.tokid
             ORDER BY m.mapseqno)
                      AS dictionaries,
       (SELECT mapdict :: pg_catalog.regdictionary
        FROM pg_catalog.pg_ts_config_map AS m
        WHERE m.mapcfg = $1
          AND m.maptokentype = parse.tokid
        ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
        LIMIT 1)      AS dictionary,
       (SELECT pg_catalog.ts_lexize(mapdict, parse.token)
        FROM pg_catalog.pg_ts_config_map AS m
        WHERE m.mapcfg = $1
          AND m.maptokentype = parse.tokid
        ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
        LIMIT 1)      AS lexemes
FROM pg_catalog.ts_parse(
       (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1), $2
         ) AS parse,
     pg_catalog.ts_token_type(
       (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1)
         ) AS tt
WHERE tt.tokid = parse.tokid
$$;

comment on function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary [],
                                                         out regdictionary, out text [])
is 'debug function for text search configuration';

alter function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary [], out regdictionary, out text [])
  owner to postgres;

create function pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text,
                                                   OUT dictionaries regdictionary [], OUT dictionary regdictionary,
                                                   OUT lexemes text [])
  returns SETOF record
stable
strict
parallel safe
language sql
as $$
SELECT *
FROM pg_catalog.ts_debug(pg_catalog.get_current_ts_config(), $1);
$$;

comment on function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary [], out regdictionary,
                                              out text [])
is 'debug function for current text search configuration';

alter function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary [], out regdictionary, out text [])
  owner to postgres;

create function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.ascii_to_mic
;

comment on function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for SQL_ASCII to MULE_INTERNAL';

alter function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_ascii
;

comment on function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to SQL_ASCII';

alter function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.koi8r_to_mic
;

comment on function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to MULE_INTERNAL';

alter function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_koi8r
;

comment on function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to KOI8R';

alter function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.iso_to_mic
;

comment on function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to MULE_INTERNAL';

alter function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_iso
;

comment on function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to ISO-8859-5';

alter function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win1251_to_mic
;

comment on function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to MULE_INTERNAL';

alter function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_win1251
;

comment on function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to WIN1251';

alter function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win866_to_mic
;

comment on function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to MULE_INTERNAL';

alter function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_win866
;

comment on function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to WIN866';

alter function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.koi8r_to_win1251
;

comment on function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to WIN1251';

alter function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win1251_to_koi8r
;

comment on function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to KOI8R';

alter function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.koi8r_to_win866
;

comment on function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to WIN866';

alter function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win866_to_koi8r
;

comment on function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to KOI8R';

alter function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win866_to_win1251
;

comment on function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to WIN1251';

alter function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win1251_to_win866
;

comment on function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to WIN866';

alter function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.iso_to_koi8r
;

comment on function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to KOI8R';

alter function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.koi8r_to_iso
;

comment on function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to ISO-8859-5';

alter function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.iso_to_win1251
;

comment on function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to WIN1251';

alter function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win1251_to_iso
;

comment on function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to ISO-8859-5';

alter function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.iso_to_win866
;

comment on function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to WIN866';

alter function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win866_to_iso
;

comment on function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to ISO-8859-5';

alter function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_cn_to_mic
;

comment on function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_CN to MULE_INTERNAL';

alter function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_euc_cn
;

comment on function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_CN';

alter function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_jp_to_sjis
;

comment on function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JP to SJIS';

alter function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.sjis_to_euc_jp
;

comment on function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer)
is 'internal conversion function for SJIS to EUC_JP';

alter function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_jp_to_mic
;

comment on function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JP to MULE_INTERNAL';

alter function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.sjis_to_mic
;

comment on function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for SJIS to MULE_INTERNAL';

alter function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_euc_jp
;

comment on function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_JP';

alter function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_sjis
;

comment on function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to SJIS';

alter function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_kr_to_mic
;

comment on function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_KR to MULE_INTERNAL';

alter function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_euc_kr
;

comment on function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_KR';

alter function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_tw_to_big5
;

comment on function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_TW to BIG5';

alter function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.big5_to_euc_tw
;

comment on function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer)
is 'internal conversion function for BIG5 to EUC_TW';

alter function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_tw_to_mic
;

comment on function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_TW to MULE_INTERNAL';

alter function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.big5_to_mic
;

comment on function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for BIG5 to MULE_INTERNAL';

alter function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_euc_tw
;

comment on function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_TW';

alter function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_big5
;

comment on function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to BIG5';

alter function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.latin2_to_mic
;

comment on function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN2 to MULE_INTERNAL';

alter function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_latin2
;

comment on function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN2';

alter function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win1250_to_mic
;

comment on function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1250 to MULE_INTERNAL';

alter function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_win1250
;

comment on function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to WIN1250';

alter function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.latin2_to_win1250
;

comment on function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN2 to WIN1250';

alter function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win1250_to_latin2
;

comment on function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1250 to LATIN2';

alter function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.latin1_to_mic
;

comment on function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN1 to MULE_INTERNAL';

alter function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_latin1
;

comment on function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN1';

alter function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.latin3_to_mic
;

comment on function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN3 to MULE_INTERNAL';

alter function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_latin3
;

comment on function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN3';

alter function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.latin4_to_mic
;

comment on function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN4 to MULE_INTERNAL';

alter function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.mic_to_latin4
;

comment on function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN4';

alter function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.ascii_to_utf8
;

comment on function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for SQL_ASCII to UTF8';

alter function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_ascii
;

comment on function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to SQL_ASCII';

alter function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.big5_to_utf8
;

comment on function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for BIG5 to UTF8';

alter function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_big5
;

comment on function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to BIG5';

alter function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_koi8r
;

comment on function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to KOI8R';

alter function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.koi8r_to_utf8
;

comment on function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to UTF8';

alter function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_koi8u
;

comment on function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to KOI8U';

alter function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.koi8u_to_utf8
;

comment on function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8U to UTF8';

alter function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_win
;

comment on function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to WIN1258';

alter function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.win_to_utf8
;

comment on function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1258 to UTF8';

alter function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_cn_to_utf8
;

comment on function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_CN to UTF8';

alter function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_euc_cn
;

comment on function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_CN';

alter function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_jp_to_utf8
;

comment on function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JP to UTF8';

alter function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_euc_jp
;

comment on function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_JP';

alter function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_kr_to_utf8
;

comment on function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_KR to UTF8';

alter function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_euc_kr
;

comment on function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_KR';

alter function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_tw_to_utf8
;

comment on function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_TW to UTF8';

alter function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_euc_tw
;

comment on function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_TW';

alter function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.gb18030_to_utf8
;

comment on function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for GB18030 to UTF8';

alter function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_gb18030
;

comment on function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to GB18030';

alter function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.gbk_to_utf8
;

comment on function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for GBK to UTF8';

alter function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_gbk
;

comment on function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to GBK';

alter function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_iso8859
;

comment on function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to ISO-8859-8';

alter function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.iso8859_to_utf8
;

comment on function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-8 to UTF8';

alter function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.iso8859_1_to_utf8
;

comment on function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN1 to UTF8';

alter function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_iso8859_1
;

comment on function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to LATIN1';

alter function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.johab_to_utf8
;

comment on function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for JOHAB to UTF8';

alter function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_johab
;

comment on function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to JOHAB';

alter function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.sjis_to_utf8
;

comment on function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for SJIS to UTF8';

alter function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_sjis
;

comment on function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to SJIS';

alter function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.uhc_to_utf8
;

comment on function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for UHC to UTF8';

alter function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_uhc
;

comment on function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to UHC';

alter function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_jis_2004_to_utf8
;

comment on function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JIS_2004 to UTF8';

alter function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_euc_jis_2004
;

comment on function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_JIS_2004';

alter function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.shift_jis_2004_to_utf8
;

comment on function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for SHIFT_JIS_2004 to UTF8';

alter function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.utf8_to_shift_jis_2004
;

comment on function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to SHIFT_JIS_2004';

alter function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.euc_jis_2004_to_shift_jis_2004
;

comment on function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JIS_2004 to SHIFT_JIS_2004';

alter function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer)
strict
parallel safe
language c
as
-- missing source code for pg_catalog.shift_jis_2004_to_euc_jis_2004
;

comment on function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for SHIFT_JIS_2004 to EUC_JIS_2004';

alter function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer)
  owner to postgres;

create function pg_catalog.dsnowball_init(internal)
strict
language c
as
-- missing source code for pg_catalog.dsnowball_init
;

alter function pg_catalog.dsnowball_init(internal)
  owner to postgres;

create function pg_catalog.dsnowball_lexize(internal, internal, internal, internal)
strict
language c
as
-- missing source code for pg_catalog.dsnowball_lexize
;

alter function pg_catalog.dsnowball_lexize(internal, internal, internal, internal)
  owner to postgres;

create function information_schema."_pg_expandarray"(anyarray, OUT x anyelement, OUT n integer)
  returns SETOF record
immutable
strict
parallel safe
language sql
as $$
select $1 [ s ], s - pg_catalog.array_lower($1, 1) + 1
from pg_catalog.generate_series(pg_catalog.array_lower($1, 1),
                                pg_catalog.array_upper($1, 1),
                                1) as g (s)
$$;

alter function information_schema."_pg_expandarray"(anyarray, out anyelement, out integer)
  owner to postgres;

create function information_schema."_pg_keysequal"(smallint [], smallint [])
  returns boolean
immutable
parallel safe
language sql
as $$
select $1 operator (pg_catalog.<@) $2 and $2 operator (pg_catalog.<@) $1
$$;

alter function information_schema."_pg_keysequal"(smallint [], smallint [])
  owner to postgres;

create function information_schema."_pg_index_position"(oid, smallint)
  returns integer
stable
strict
language sql
as $$
SELECT (ss.a).n
FROM (SELECT information_schema._pg_expandarray(indkey) AS a FROM pg_catalog.pg_index WHERE indexrelid = $1) ss
WHERE (ss.a).x = $2;
$$;

alter function information_schema."_pg_index_position"(oid, smallint)
  owner to postgres;

create function information_schema."_pg_truetypid"(pg_attribute, pg_type)
  returns oid
immutable
strict
parallel safe
language sql
as $$
SELECT CASE WHEN $2.typtype = 'd' THEN $2.typbasetype ELSE $1.atttypid END
$$;

alter function information_schema."_pg_truetypid"(pg_attribute, pg_type)
  owner to postgres;

create function information_schema."_pg_truetypmod"(pg_attribute, pg_type)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE WHEN $2.typtype = 'd' THEN $2.typtypmod ELSE $1.atttypmod END
$$;

alter function information_schema."_pg_truetypmod"(pg_attribute, pg_type)
  owner to postgres;

create function information_schema."_pg_char_max_length"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $2 = -1 /* default typmod */
                 THEN null
         WHEN $1 IN (1042, 1043) /* char, varchar */
                 THEN $2 - 4
         WHEN $1 IN (1560, 1562) /* bit, varbit */
                 THEN $2
         ELSE null END
$$;

alter function information_schema."_pg_char_max_length"(oid, integer)
  owner to postgres;

create function information_schema."_pg_char_octet_length"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (25, 1042, 1043) /* text, char, varchar */
                 THEN CASE
                        WHEN $2 = -1 /* default typmod */
                                THEN CAST(2 ^ 30 AS integer)
                        ELSE information_schema._pg_char_max_length($1, $2) *
                             pg_catalog.pg_encoding_max_length((SELECT encoding
                                                                FROM pg_catalog.pg_database
                                                                WHERE datname = pg_catalog.current_database()))
        END
         ELSE null END
$$;

alter function information_schema."_pg_char_octet_length"(oid, integer)
  owner to postgres;

create function information_schema."_pg_numeric_precision"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE $1
         WHEN 21 /*int2*/ THEN 16
         WHEN 23 /*int4*/ THEN 32
         WHEN 20 /*int8*/ THEN 64
         WHEN 1700 /*numeric*/ THEN CASE
                                      WHEN $2 = -1
                                              THEN null
                                      ELSE (($2 - 4) >> 16) & 65535
        END
         WHEN 700 /*float4*/ THEN 24 /*FLT_MANT_DIG*/
         WHEN 701 /*float8*/ THEN 53 /*DBL_MANT_DIG*/
         ELSE null END
$$;

alter function information_schema."_pg_numeric_precision"(oid, integer)
  owner to postgres;

create function information_schema."_pg_numeric_precision_radix"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (21, 23, 20, 700, 701) THEN 2
         WHEN $1 IN (1700) THEN 10
         ELSE null END
$$;

alter function information_schema."_pg_numeric_precision_radix"(oid, integer)
  owner to postgres;

create function information_schema."_pg_numeric_scale"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (21, 23, 20) THEN 0
         WHEN $1 IN (1700) THEN CASE
                                  WHEN $2 = -1
                                          THEN null
                                  ELSE ($2 - 4) & 65535
        END
         ELSE null END
$$;

alter function information_schema."_pg_numeric_scale"(oid, integer)
  owner to postgres;

create function information_schema."_pg_datetime_precision"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (1082) /* date */
                 THEN 0
         WHEN $1 IN (1083, 1114, 1184, 1266) /* time, timestamp, same + tz */
                 THEN CASE WHEN $2 < 0 THEN 6 ELSE $2 END
         WHEN $1 IN (1186) /* interval */
                 THEN CASE WHEN $2 < 0 OR $2 & 65535 = 65535 THEN 6 ELSE $2 & 65535 END
         ELSE null END
$$;

alter function information_schema."_pg_datetime_precision"(oid, integer)
  owner to postgres;

create function information_schema."_pg_interval_type"(typid oid, mod integer)
  returns text
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (1186) /* interval */
                 THEN upper(substring(format_type($1, $2) from 'interval[()0-9]* #"%#"' for '#'))
         ELSE null END
$$;

alter function information_schema."_pg_interval_type"(oid, integer)
  owner to postgres;

create function pg_catalog.plpgsql_call_handler()
language c
as
-- missing source code for pg_catalog.plpgsql_call_handler
;

alter function pg_catalog.plpgsql_call_handler()
  owner to postgres;

create function pg_catalog.plpgsql_inline_handler(internal)
strict
language c
as
-- missing source code for pg_catalog.plpgsql_inline_handler
;

alter function pg_catalog.plpgsql_inline_handler(internal)
  owner to postgres;

create function pg_catalog.plpgsql_validator(oid)
strict
language c
as
-- missing source code for pg_catalog.plpgsql_validator
;

alter function pg_catalog.plpgsql_validator(oid)
  owner to postgres;

create operator pg_catalog.= (procedure = int48eq, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.=(integer, bigint)
is 'equal';

alter operator pg_catalog.=(integer, bigint)
  owner to postgres;

create operator pg_catalog.<> (procedure = int48ne, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<>(integer, bigint)
is 'not equal';

alter operator pg_catalog.<>(integer, bigint)
  owner to postgres;

create operator pg_catalog.< (procedure = int48lt, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<(integer, bigint)
is 'less than';

alter operator pg_catalog.<(integer, bigint)
  owner to postgres;

create operator pg_catalog.< (procedure = boollt, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<(boolean, boolean)
is 'less than';

alter operator pg_catalog.<(boolean, boolean)
  owner to postgres;

create operator pg_catalog.> (procedure = boolgt, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.>(boolean, boolean)
is 'greater than';

alter operator pg_catalog.>(boolean, boolean)
  owner to postgres;

create operator pg_catalog.> (procedure = int48gt, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.>(integer, bigint)
is 'greater than';

alter operator pg_catalog.>(integer, bigint)
  owner to postgres;

create operator pg_catalog.<= (procedure = int48le, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<=(integer, bigint)
is 'less than or equal';

alter operator pg_catalog.<=(integer, bigint)
  owner to postgres;

create operator pg_catalog.>= (procedure = int48ge, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.>=(integer, bigint)
is 'greater than or equal';

alter operator pg_catalog.>=(integer, bigint)
  owner to postgres;

create operator pg_catalog.<> (procedure = boolne, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<>(boolean, boolean)
is 'not equal';

alter operator pg_catalog.<>(boolean, boolean)
  owner to postgres;

create operator pg_catalog.= (procedure = booleq, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.=(boolean, boolean)
is 'equal';

alter operator pg_catalog.=(boolean, boolean)
  owner to postgres;

create operator pg_catalog.= (procedure = chareq, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.=("char", "char")
is 'equal';

alter operator pg_catalog.=("char", "char")
  owner to postgres;

create operator pg_catalog.= (procedure = nameeq, leftarg = name, rightarg = name);

comment on operator pg_catalog.=(name, name)
is 'equal';

alter operator pg_catalog.=(name, name)
  owner to postgres;

create operator pg_catalog.= (procedure = int2eq, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.=(smallint, smallint)
is 'equal';

alter operator pg_catalog.=(smallint, smallint)
  owner to postgres;

create operator pg_catalog.< (procedure = int2lt, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<(smallint, smallint)
is 'less than';

alter operator pg_catalog.<(smallint, smallint)
  owner to postgres;

create operator pg_catalog.= (procedure = int4eq, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.=(integer, integer)
is 'equal';

alter operator pg_catalog.=(integer, integer)
  owner to postgres;

create operator pg_catalog.< (procedure = int4lt, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<(integer, integer)
is 'less than';

alter operator pg_catalog.<(integer, integer)
  owner to postgres;

create operator pg_catalog.= (procedure = texteq, leftarg = text, rightarg = text);

comment on operator pg_catalog.=(text, text)
is 'equal';

alter operator pg_catalog.=(text, text)
  owner to postgres;

create operator pg_catalog.|| (procedure = array_append, leftarg = anyarray, rightarg = anyelement);

comment on operator pg_catalog.||(anyarray, anyelement)
is 'append element onto end of array';

alter operator pg_catalog.||(anyarray, anyelement)
  owner to postgres;

create operator pg_catalog.= (procedure = xideq, leftarg = xid, rightarg = xid);

comment on operator pg_catalog.=(xid, xid)
is 'equal';

alter operator pg_catalog.=(xid, xid)
  owner to postgres;

create operator pg_catalog.= (procedure = xideqint4, leftarg = xid, rightarg = integer);

comment on operator pg_catalog.=(xid, integer)
is 'equal';

alter operator pg_catalog.=(xid, integer)
  owner to postgres;

create operator pg_catalog.|| (procedure = array_prepend, leftarg = anyelement, rightarg = anyarray);

comment on operator pg_catalog.||(anyelement, anyarray)
is 'prepend element onto front of array';

alter operator pg_catalog.||(anyelement, anyarray)
  owner to postgres;

create operator pg_catalog.|| (procedure = array_cat, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.||(anyarray, anyarray)
is 'concatenate';

alter operator pg_catalog.||(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.= (procedure = cideq, leftarg = cid, rightarg = cid);

comment on operator pg_catalog.=(cid, cid)
is 'equal';

alter operator pg_catalog.=(cid, cid)
  owner to postgres;

create operator pg_catalog.= (procedure = tideq, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.=(tid, tid)
is 'equal';

alter operator pg_catalog.=(tid, tid)
  owner to postgres;

create operator pg_catalog.! (procedure = numeric_fac, leftarg = bigint);

comment on operator pg_catalog.!(bigint, none)
is 'factorial';

alter operator pg_catalog.!(bigint, none)
  owner to postgres;

create operator pg_catalog.!! (procedure = numeric_fac, rightarg = bigint);

comment on operator pg_catalog.!!(none, bigint)
is 'deprecated, use ! instead';

alter operator pg_catalog.!!(none, bigint)
  owner to postgres;

create operator pg_catalog.<> (procedure = tidne, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<>(tid, tid)
is 'not equal';

alter operator pg_catalog.<>(tid, tid)
  owner to postgres;

create operator pg_catalog.= (procedure = int8eq, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.=(bigint, bigint)
is 'equal';

alter operator pg_catalog.=(bigint, bigint)
  owner to postgres;

create operator pg_catalog.<> (procedure = int8ne, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<>(bigint, bigint)
is 'not equal';

alter operator pg_catalog.<>(bigint, bigint)
  owner to postgres;

create operator pg_catalog.< (procedure = int8lt, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<(bigint, bigint)
is 'less than';

alter operator pg_catalog.<(bigint, bigint)
  owner to postgres;

create operator pg_catalog.> (procedure = int8gt, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.>(bigint, bigint)
is 'greater than';

alter operator pg_catalog.>(bigint, bigint)
  owner to postgres;

create operator pg_catalog.<= (procedure = int8le, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<=(bigint, bigint)
is 'less than or equal';

alter operator pg_catalog.<=(bigint, bigint)
  owner to postgres;

create operator pg_catalog.>= (procedure = int8ge, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.>=(bigint, bigint)
is 'greater than or equal';

alter operator pg_catalog.>=(bigint, bigint)
  owner to postgres;

create operator pg_catalog.= (procedure = int84eq, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.=(bigint, integer)
is 'equal';

alter operator pg_catalog.=(bigint, integer)
  owner to postgres;

create operator pg_catalog.<> (procedure = int84ne, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<>(bigint, integer)
is 'not equal';

alter operator pg_catalog.<>(bigint, integer)
  owner to postgres;

create operator pg_catalog.< (procedure = int84lt, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<(bigint, integer)
is 'less than';

alter operator pg_catalog.<(bigint, integer)
  owner to postgres;

create operator pg_catalog.> (procedure = int84gt, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>(bigint, integer)
is 'greater than';

alter operator pg_catalog.>(bigint, integer)
  owner to postgres;

create operator pg_catalog.<= (procedure = int84le, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<=(bigint, integer)
is 'less than or equal';

alter operator pg_catalog.<=(bigint, integer)
  owner to postgres;

create operator pg_catalog.>= (procedure = int84ge, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>=(bigint, integer)
is 'greater than or equal';

alter operator pg_catalog.>=(bigint, integer)
  owner to postgres;

create operator pg_catalog.@> (procedure = box_contain_pt, leftarg = box, rightarg = point);

comment on operator pg_catalog.@>(box, point)
is 'contains';

alter operator pg_catalog.@>(box, point)
  owner to postgres;

create operator pg_catalog.% (procedure = int8mod, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.%(bigint, bigint)
is 'modulus';

alter operator pg_catalog.%(bigint, bigint)
  owner to postgres;

create operator pg_catalog.@ (procedure = int8abs, rightarg = bigint);

comment on operator pg_catalog.@(none, bigint)
is 'absolute value';

alter operator pg_catalog.@(none, bigint)
  owner to postgres;

create operator pg_catalog.- (procedure = int8um, rightarg = bigint);

comment on operator pg_catalog.-(none, bigint)
is 'negate';

alter operator pg_catalog.-(none, bigint)
  owner to postgres;

create operator pg_catalog.<< (procedure = poly_left, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<<(polygon, polygon)
is 'is left of';

alter operator pg_catalog.<<(polygon, polygon)
  owner to postgres;

create operator pg_catalog.&< (procedure = poly_overleft, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&<(polygon, polygon)
is 'overlaps or is left of';

alter operator pg_catalog.&<(polygon, polygon)
  owner to postgres;

create operator pg_catalog.&> (procedure = poly_overright, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&>(polygon, polygon)
is 'overlaps or is right of';

alter operator pg_catalog.&>(polygon, polygon)
  owner to postgres;

create operator pg_catalog.>> (procedure = poly_right, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.>>(polygon, polygon)
is 'is right of';

alter operator pg_catalog.>>(polygon, polygon)
  owner to postgres;

create operator pg_catalog.<@ (procedure = poly_contained, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<@(polygon, polygon)
is 'is contained by';

alter operator pg_catalog.<@(polygon, polygon)
  owner to postgres;

create operator pg_catalog.@> (procedure = poly_contain, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.@>(polygon, polygon)
is 'contains';

alter operator pg_catalog.@>(polygon, polygon)
  owner to postgres;

create operator pg_catalog.~= (procedure = poly_same, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.~=(polygon, polygon)
is 'same as';

alter operator pg_catalog.~=(polygon, polygon)
  owner to postgres;

create operator pg_catalog.&& (procedure = poly_overlap, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&&(polygon, polygon)
is 'overlaps';

alter operator pg_catalog.&&(polygon, polygon)
  owner to postgres;

create operator pg_catalog.<< (procedure = box_left, leftarg = box, rightarg = box);

comment on operator pg_catalog.<<(box, box)
is 'is left of';

alter operator pg_catalog.<<(box, box)
  owner to postgres;

create operator pg_catalog.&< (procedure = box_overleft, leftarg = box, rightarg = box);

comment on operator pg_catalog.&<(box, box)
is 'overlaps or is left of';

alter operator pg_catalog.&<(box, box)
  owner to postgres;

create operator pg_catalog.&> (procedure = box_overright, leftarg = box, rightarg = box);

comment on operator pg_catalog.&>(box, box)
is 'overlaps or is right of';

alter operator pg_catalog.&>(box, box)
  owner to postgres;

create operator pg_catalog.>> (procedure = box_right, leftarg = box, rightarg = box);

comment on operator pg_catalog.>>(box, box)
is 'is right of';

alter operator pg_catalog.>>(box, box)
  owner to postgres;

create operator pg_catalog.<@ (procedure = box_contained, leftarg = box, rightarg = box);

comment on operator pg_catalog.<@(box, box)
is 'is contained by';

alter operator pg_catalog.<@(box, box)
  owner to postgres;

create operator pg_catalog.@> (procedure = box_contain, leftarg = box, rightarg = box);

comment on operator pg_catalog.@>(box, box)
is 'contains';

alter operator pg_catalog.@>(box, box)
  owner to postgres;

create operator pg_catalog.~= (procedure = box_same, leftarg = box, rightarg = box);

comment on operator pg_catalog.~=(box, box)
is 'same as';

alter operator pg_catalog.~=(box, box)
  owner to postgres;

create operator pg_catalog.&& (procedure = box_overlap, leftarg = box, rightarg = box);

comment on operator pg_catalog.&&(box, box)
is 'overlaps';

alter operator pg_catalog.&&(box, box)
  owner to postgres;

create operator pg_catalog.>= (procedure = box_ge, leftarg = box, rightarg = box);

comment on operator pg_catalog.>=(box, box)
is 'greater than or equal by area';

alter operator pg_catalog.>=(box, box)
  owner to postgres;

create operator pg_catalog.> (procedure = box_gt, leftarg = box, rightarg = box);

comment on operator pg_catalog.>(box, box)
is 'greater than by area';

alter operator pg_catalog.>(box, box)
  owner to postgres;

create operator pg_catalog.= (procedure = box_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.=(box, box)
is 'equal by area';

alter operator pg_catalog.=(box, box)
  owner to postgres;

create operator pg_catalog.< (procedure = box_lt, leftarg = box, rightarg = box);

comment on operator pg_catalog.<(box, box)
is 'less than by area';

alter operator pg_catalog.<(box, box)
  owner to postgres;

create operator pg_catalog.<= (procedure = box_le, leftarg = box, rightarg = box);

comment on operator pg_catalog.<=(box, box)
is 'less than or equal by area';

alter operator pg_catalog.<=(box, box)
  owner to postgres;

create operator pg_catalog.>^ (procedure = point_above, leftarg = point, rightarg = point);

comment on operator pg_catalog.>^(point, point)
is 'is above';

alter operator pg_catalog.>^(point, point)
  owner to postgres;

create operator pg_catalog.<< (procedure = point_left, leftarg = point, rightarg = point);

comment on operator pg_catalog.<<(point, point)
is 'is left of';

alter operator pg_catalog.<<(point, point)
  owner to postgres;

create operator pg_catalog.>> (procedure = point_right, leftarg = point, rightarg = point);

comment on operator pg_catalog.>>(point, point)
is 'is right of';

alter operator pg_catalog.>>(point, point)
  owner to postgres;

create operator pg_catalog.<^ (procedure = point_below, leftarg = point, rightarg = point);

comment on operator pg_catalog.<^(point, point)
is 'is below';

alter operator pg_catalog.<^(point, point)
  owner to postgres;

create operator pg_catalog.~= (procedure = point_eq, leftarg = point, rightarg = point);

comment on operator pg_catalog.~=(point, point)
is 'same as';

alter operator pg_catalog.~=(point, point)
  owner to postgres;

create operator pg_catalog.<@ (procedure = on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.<@(point, box)
is 'point inside box';

alter operator pg_catalog.<@(point, box)
  owner to postgres;

create operator pg_catalog.<@ (procedure = on_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.<@(point, path)
is 'point within closed path, or point on open path';

alter operator pg_catalog.<@(point, path)
  owner to postgres;

create operator pg_catalog.@@ (procedure = box_center, rightarg = box);

comment on operator pg_catalog.@@(none, box)
is 'center of';

alter operator pg_catalog.@@(none, box)
  owner to postgres;

create operator pg_catalog.* (procedure = int4mul, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.*(integer, integer)
is 'multiply';

alter operator pg_catalog.*(integer, integer)
  owner to postgres;

create operator pg_catalog.<-> (procedure = point_distance, leftarg = point, rightarg = point);

comment on operator pg_catalog.<->(point, point)
is 'distance between';

alter operator pg_catalog.<->(point, point)
  owner to postgres;

create operator pg_catalog.<> (procedure = int4ne, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<>(integer, integer)
is 'not equal';

alter operator pg_catalog.<>(integer, integer)
  owner to postgres;

create operator pg_catalog.<> (procedure = int2ne, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<>(smallint, smallint)
is 'not equal';

alter operator pg_catalog.<>(smallint, smallint)
  owner to postgres;

create operator pg_catalog.> (procedure = int2gt, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.>(smallint, smallint)
is 'greater than';

alter operator pg_catalog.>(smallint, smallint)
  owner to postgres;

create operator pg_catalog.> (procedure = int4gt, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>(integer, integer)
is 'greater than';

alter operator pg_catalog.>(integer, integer)
  owner to postgres;

create operator pg_catalog.<= (procedure = int2le, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<=(smallint, smallint)
is 'less than or equal';

alter operator pg_catalog.<=(smallint, smallint)
  owner to postgres;

create operator pg_catalog.<= (procedure = int4le, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<=(integer, integer)
is 'less than or equal';

alter operator pg_catalog.<=(integer, integer)
  owner to postgres;

create operator pg_catalog.>= (procedure = int2ge, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.>=(smallint, smallint)
is 'greater than or equal';

alter operator pg_catalog.>=(smallint, smallint)
  owner to postgres;

create operator pg_catalog.>= (procedure = int4ge, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>=(integer, integer)
is 'greater than or equal';

alter operator pg_catalog.>=(integer, integer)
  owner to postgres;

create operator pg_catalog.* (procedure = int2mul, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.*(smallint, smallint)
is 'multiply';

alter operator pg_catalog.*(smallint, smallint)
  owner to postgres;

create operator pg_catalog./ (procedure = int2div, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog./(smallint, smallint)
is 'divide';

alter operator pg_catalog./(smallint, smallint)
  owner to postgres;

create operator pg_catalog./ (procedure = int4div, leftarg = integer, rightarg = integer);

comment on operator pg_catalog./(integer, integer)
is 'divide';

alter operator pg_catalog./(integer, integer)
  owner to postgres;

create operator pg_catalog.% (procedure = int2mod, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.%(smallint, smallint)
is 'modulus';

alter operator pg_catalog.%(smallint, smallint)
  owner to postgres;

create operator pg_catalog.% (procedure = int4mod, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.%(integer, integer)
is 'modulus';

alter operator pg_catalog.%(integer, integer)
  owner to postgres;

create operator pg_catalog.<> (procedure = textne, leftarg = text, rightarg = text);

comment on operator pg_catalog.<>(text, text)
is 'not equal';

alter operator pg_catalog.<>(text, text)
  owner to postgres;

create operator pg_catalog.= (procedure = int24eq, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.=(smallint, integer)
is 'equal';

alter operator pg_catalog.=(smallint, integer)
  owner to postgres;

create operator pg_catalog.= (procedure = int42eq, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.=(integer, smallint)
is 'equal';

alter operator pg_catalog.=(integer, smallint)
  owner to postgres;

create operator pg_catalog.< (procedure = int24lt, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<(smallint, integer)
is 'less than';

alter operator pg_catalog.<(smallint, integer)
  owner to postgres;

create operator pg_catalog.< (procedure = int42lt, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<(integer, smallint)
is 'less than';

alter operator pg_catalog.<(integer, smallint)
  owner to postgres;

create operator pg_catalog.> (procedure = int24gt, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>(smallint, integer)
is 'greater than';

alter operator pg_catalog.>(smallint, integer)
  owner to postgres;

create operator pg_catalog.> (procedure = int42gt, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.>(integer, smallint)
is 'greater than';

alter operator pg_catalog.>(integer, smallint)
  owner to postgres;

create operator pg_catalog.<> (procedure = int24ne, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<>(smallint, integer)
is 'not equal';

alter operator pg_catalog.<>(smallint, integer)
  owner to postgres;

create operator pg_catalog.<> (procedure = int42ne, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<>(integer, smallint)
is 'not equal';

alter operator pg_catalog.<>(integer, smallint)
  owner to postgres;

create operator pg_catalog.<= (procedure = int24le, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<=(smallint, integer)
is 'less than or equal';

alter operator pg_catalog.<=(smallint, integer)
  owner to postgres;

create operator pg_catalog.<= (procedure = int42le, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<=(integer, smallint)
is 'less than or equal';

alter operator pg_catalog.<=(integer, smallint)
  owner to postgres;

create operator pg_catalog.>= (procedure = int24ge, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>=(smallint, integer)
is 'greater than or equal';

alter operator pg_catalog.>=(smallint, integer)
  owner to postgres;

create operator pg_catalog.>= (procedure = int42ge, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.>=(integer, smallint)
is 'greater than or equal';

alter operator pg_catalog.>=(integer, smallint)
  owner to postgres;

create operator pg_catalog.* (procedure = int24mul, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.*(smallint, integer)
is 'multiply';

alter operator pg_catalog.*(smallint, integer)
  owner to postgres;

create operator pg_catalog.* (procedure = int42mul, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.*(integer, smallint)
is 'multiply';

alter operator pg_catalog.*(integer, smallint)
  owner to postgres;

create operator pg_catalog./ (procedure = int24div, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog./(smallint, integer)
is 'divide';

alter operator pg_catalog./(smallint, integer)
  owner to postgres;

create operator pg_catalog./ (procedure = int42div, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog./(integer, smallint)
is 'divide';

alter operator pg_catalog./(integer, smallint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int2pl, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.+(smallint, smallint)
is 'add';

alter operator pg_catalog.+(smallint, smallint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int4pl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.+(integer, integer)
is 'add';

alter operator pg_catalog.+(integer, integer)
  owner to postgres;

create operator pg_catalog.+ (procedure = int24pl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.+(smallint, integer)
is 'add';

alter operator pg_catalog.+(smallint, integer)
  owner to postgres;

create operator pg_catalog.+ (procedure = int42pl, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.+(integer, smallint)
is 'add';

alter operator pg_catalog.+(integer, smallint)
  owner to postgres;

create operator pg_catalog.- (procedure = int2mi, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.-(smallint, smallint)
is 'subtract';

alter operator pg_catalog.-(smallint, smallint)
  owner to postgres;

create operator pg_catalog.- (procedure = int4mi, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.-(integer, integer)
is 'subtract';

alter operator pg_catalog.-(integer, integer)
  owner to postgres;

create operator pg_catalog.- (procedure = int24mi, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.-(smallint, integer)
is 'subtract';

alter operator pg_catalog.-(smallint, integer)
  owner to postgres;

create operator pg_catalog.- (procedure = int42mi, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.-(integer, smallint)
is 'subtract';

alter operator pg_catalog.-(integer, smallint)
  owner to postgres;

create operator pg_catalog.- (procedure = int4um, rightarg = integer);

comment on operator pg_catalog.-(none, integer)
is 'negate';

alter operator pg_catalog.-(none, integer)
  owner to postgres;

create operator pg_catalog.- (procedure = int2um, rightarg = smallint);

comment on operator pg_catalog.-(none, smallint)
is 'negate';

alter operator pg_catalog.-(none, smallint)
  owner to postgres;

create operator pg_catalog.= (procedure = abstimeeq, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.=(abstime, abstime)
is 'equal';

alter operator pg_catalog.=(abstime, abstime)
  owner to postgres;

create operator pg_catalog.<> (procedure = abstimene, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<>(abstime, abstime)
is 'not equal';

alter operator pg_catalog.<>(abstime, abstime)
  owner to postgres;

create operator pg_catalog.< (procedure = abstimelt, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<(abstime, abstime)
is 'less than';

alter operator pg_catalog.<(abstime, abstime)
  owner to postgres;

create operator pg_catalog.> (procedure = abstimegt, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.>(abstime, abstime)
is 'greater than';

alter operator pg_catalog.>(abstime, abstime)
  owner to postgres;

create operator pg_catalog.<= (procedure = abstimele, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<=(abstime, abstime)
is 'less than or equal';

alter operator pg_catalog.<=(abstime, abstime)
  owner to postgres;

create operator pg_catalog.>= (procedure = abstimege, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.>=(abstime, abstime)
is 'greater than or equal';

alter operator pg_catalog.>=(abstime, abstime)
  owner to postgres;

create operator pg_catalog.= (procedure = reltimeeq, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.=(reltime, reltime)
is 'equal';

alter operator pg_catalog.=(reltime, reltime)
  owner to postgres;

create operator pg_catalog.<> (procedure = reltimene, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<>(reltime, reltime)
is 'not equal';

alter operator pg_catalog.<>(reltime, reltime)
  owner to postgres;

create operator pg_catalog.< (procedure = reltimelt, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<(reltime, reltime)
is 'less than';

alter operator pg_catalog.<(reltime, reltime)
  owner to postgres;

create operator pg_catalog.> (procedure = reltimegt, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.>(reltime, reltime)
is 'greater than';

alter operator pg_catalog.>(reltime, reltime)
  owner to postgres;

create operator pg_catalog.<= (procedure = reltimele, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<=(reltime, reltime)
is 'less than or equal';

alter operator pg_catalog.<=(reltime, reltime)
  owner to postgres;

create operator pg_catalog.>= (procedure = reltimege, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.>=(reltime, reltime)
is 'greater than or equal';

alter operator pg_catalog.>=(reltime, reltime)
  owner to postgres;

create operator pg_catalog.~= (procedure = tintervalsame, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.~=(tinterval, tinterval)
is 'same as';

alter operator pg_catalog.~=(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.<< (procedure = tintervalct, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<<(tinterval, tinterval)
is 'contains';

alter operator pg_catalog.<<(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.&& (procedure = tintervalov, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.&&(tinterval, tinterval)
is 'overlaps';

alter operator pg_catalog.&&(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.#= (procedure = tintervalleneq, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#=(tinterval, reltime)
is 'equal by length';

alter operator pg_catalog.#=(tinterval, reltime)
  owner to postgres;

create operator pg_catalog.#<> (procedure = tintervallenne, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<>(tinterval, reltime)
is 'not equal by length';

alter operator pg_catalog.#<>(tinterval, reltime)
  owner to postgres;

create operator pg_catalog.#< (procedure = tintervallenlt, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<(tinterval, reltime)
is 'less than by length';

alter operator pg_catalog.#<(tinterval, reltime)
  owner to postgres;

create operator pg_catalog.#> (procedure = tintervallengt, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#>(tinterval, reltime)
is 'greater than by length';

alter operator pg_catalog.#>(tinterval, reltime)
  owner to postgres;

create operator pg_catalog.#<= (procedure = tintervallenle, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<=(tinterval, reltime)
is 'less than or equal by length';

alter operator pg_catalog.#<=(tinterval, reltime)
  owner to postgres;

create operator pg_catalog.#>= (procedure = tintervallenge, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#>=(tinterval, reltime)
is 'greater than or equal by length';

alter operator pg_catalog.#>=(tinterval, reltime)
  owner to postgres;

create operator pg_catalog.+ (procedure = timepl, leftarg = abstime, rightarg = reltime);

comment on operator pg_catalog.+(abstime, reltime)
is 'add';

alter operator pg_catalog.+(abstime, reltime)
  owner to postgres;

create operator pg_catalog.- (procedure = timemi, leftarg = abstime, rightarg = reltime);

comment on operator pg_catalog.-(abstime, reltime)
is 'subtract';

alter operator pg_catalog.-(abstime, reltime)
  owner to postgres;

create operator pg_catalog.<?> (procedure = intinterval, leftarg = abstime, rightarg = tinterval);

comment on operator pg_catalog.<?>(abstime, tinterval)
is 'is contained by';

alter operator pg_catalog.<?>(abstime, tinterval)
  owner to postgres;

create operator pg_catalog.- (procedure = float4um, rightarg = real);

comment on operator pg_catalog.-(none, real)
is 'negate';

alter operator pg_catalog.-(none, real)
  owner to postgres;

create operator pg_catalog.- (procedure = float8um, rightarg = double precision);

comment on operator pg_catalog.-(none, double precision)
is 'negate';

alter operator pg_catalog.-(none, double precision)
  owner to postgres;

create operator pg_catalog.+ (procedure = float4pl, leftarg = real, rightarg = real);

comment on operator pg_catalog.+(real, real)
is 'add';

alter operator pg_catalog.+(real, real)
  owner to postgres;

create operator pg_catalog.- (procedure = float4mi, leftarg = real, rightarg = real);

comment on operator pg_catalog.-(real, real)
is 'subtract';

alter operator pg_catalog.-(real, real)
  owner to postgres;

create operator pg_catalog./ (procedure = float4div, leftarg = real, rightarg = real);

comment on operator pg_catalog./(real, real)
is 'divide';

alter operator pg_catalog./(real, real)
  owner to postgres;

create operator pg_catalog.* (procedure = float4mul, leftarg = real, rightarg = real);

comment on operator pg_catalog.*(real, real)
is 'multiply';

alter operator pg_catalog.*(real, real)
  owner to postgres;

create operator pg_catalog.@ (procedure = float4abs, rightarg = real);

comment on operator pg_catalog.@(none, real)
is 'absolute value';

alter operator pg_catalog.@(none, real)
  owner to postgres;

create operator pg_catalog.+ (procedure = float8pl, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.+(double precision, double precision)
is 'add';

alter operator pg_catalog.+(double precision, double precision)
  owner to postgres;

create operator pg_catalog.- (procedure = float8mi, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.-(double precision, double precision)
is 'subtract';

alter operator pg_catalog.-(double precision, double precision)
  owner to postgres;

create operator pg_catalog./ (procedure = float8div, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog./(double precision, double precision)
is 'divide';

alter operator pg_catalog./(double precision, double precision)
  owner to postgres;

create operator pg_catalog.* (procedure = float8mul, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.*(double precision, double precision)
is 'multiply';

alter operator pg_catalog.*(double precision, double precision)
  owner to postgres;

create operator pg_catalog.@ (procedure = float8abs, rightarg = double precision);

comment on operator pg_catalog.@(none, double precision)
is 'absolute value';

alter operator pg_catalog.@(none, double precision)
  owner to postgres;

create operator pg_catalog.|/ (procedure = dsqrt, rightarg = double precision);

comment on operator pg_catalog.|/(none, double precision)
is 'square root';

alter operator pg_catalog.|/(none, double precision)
  owner to postgres;

create operator pg_catalog.||/ (procedure = dcbrt, rightarg = double precision);

comment on operator pg_catalog.||/(none, double precision)
is 'cube root';

alter operator pg_catalog.||/(none, double precision)
  owner to postgres;

create operator pg_catalog.<#> (procedure = mktinterval, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<#>(abstime, abstime)
is 'convert to tinterval';

alter operator pg_catalog.<#>(abstime, abstime)
  owner to postgres;

create operator pg_catalog.= (procedure = oideq, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.=(oid, oid)
is 'equal';

alter operator pg_catalog.=(oid, oid)
  owner to postgres;

create operator pg_catalog.<> (procedure = oidne, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<>(oid, oid)
is 'not equal';

alter operator pg_catalog.<>(oid, oid)
  owner to postgres;

create operator pg_catalog.< (procedure = oidlt, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<(oid, oid)
is 'less than';

alter operator pg_catalog.<(oid, oid)
  owner to postgres;

create operator pg_catalog.> (procedure = oidgt, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.>(oid, oid)
is 'greater than';

alter operator pg_catalog.>(oid, oid)
  owner to postgres;

create operator pg_catalog.<= (procedure = oidle, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<=(oid, oid)
is 'less than or equal';

alter operator pg_catalog.<=(oid, oid)
  owner to postgres;

create operator pg_catalog.>= (procedure = oidge, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.>=(oid, oid)
is 'greater than or equal';

alter operator pg_catalog.>=(oid, oid)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<->(point, line)
is 'distance between';

alter operator pg_catalog.<->(point, line)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<->(point, lseg)
is 'distance between';

alter operator pg_catalog.<->(point, lseg)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.<->(point, box)
is 'distance between';

alter operator pg_catalog.<->(point, box)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<->(lseg, line)
is 'distance between';

alter operator pg_catalog.<->(lseg, line)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<->(lseg, box)
is 'distance between';

alter operator pg_catalog.<->(lseg, box)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.<->(point, path)
is 'distance between';

alter operator pg_catalog.<->(point, path)
  owner to postgres;

create operator pg_catalog.= (procedure = float4eq, leftarg = real, rightarg = real);

comment on operator pg_catalog.=(real, real)
is 'equal';

alter operator pg_catalog.=(real, real)
  owner to postgres;

create operator pg_catalog.<> (procedure = float4ne, leftarg = real, rightarg = real);

comment on operator pg_catalog.<>(real, real)
is 'not equal';

alter operator pg_catalog.<>(real, real)
  owner to postgres;

create operator pg_catalog.< (procedure = float4lt, leftarg = real, rightarg = real);

comment on operator pg_catalog.<(real, real)
is 'less than';

alter operator pg_catalog.<(real, real)
  owner to postgres;

create operator pg_catalog.> (procedure = float4gt, leftarg = real, rightarg = real);

comment on operator pg_catalog.>(real, real)
is 'greater than';

alter operator pg_catalog.>(real, real)
  owner to postgres;

create operator pg_catalog.<= (procedure = float4le, leftarg = real, rightarg = real);

comment on operator pg_catalog.<=(real, real)
is 'less than or equal';

alter operator pg_catalog.<=(real, real)
  owner to postgres;

create operator pg_catalog.>= (procedure = float4ge, leftarg = real, rightarg = real);

comment on operator pg_catalog.>=(real, real)
is 'greater than or equal';

alter operator pg_catalog.>=(real, real)
  owner to postgres;

create operator pg_catalog.<> (procedure = charne, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<>("char", "char")
is 'not equal';

alter operator pg_catalog.<>("char", "char")
  owner to postgres;

create operator pg_catalog.< (procedure = charlt, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<("char", "char")
is 'less than';

alter operator pg_catalog.<("char", "char")
  owner to postgres;

create operator pg_catalog.<= (procedure = charle, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<=("char", "char")
is 'less than or equal';

alter operator pg_catalog.<=("char", "char")
  owner to postgres;

create operator pg_catalog.> (procedure = chargt, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.>("char", "char")
is 'greater than';

alter operator pg_catalog.>("char", "char")
  owner to postgres;

create operator pg_catalog.>= (procedure = charge, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.>=("char", "char")
is 'greater than or equal';

alter operator pg_catalog.>=("char", "char")
  owner to postgres;

create operator pg_catalog.~ (procedure = nameregexeq, leftarg = name, rightarg = text);

comment on operator pg_catalog.~(name, text)
is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(name, text)
  owner to postgres;

create operator pg_catalog.!~ (procedure = nameregexne, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~(name, text)
is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(name, text)
  owner to postgres;

create operator pg_catalog.~ (procedure = textregexeq, leftarg = text, rightarg = text);

comment on operator pg_catalog.~(text, text)
is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(text, text)
  owner to postgres;

create operator pg_catalog.!~ (procedure = textregexne, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~(text, text)
is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(text, text)
  owner to postgres;

create operator pg_catalog.<> (procedure = namene, leftarg = name, rightarg = name);

comment on operator pg_catalog.<>(name, name)
is 'not equal';

alter operator pg_catalog.<>(name, name)
  owner to postgres;

create operator pg_catalog.<> (procedure = oidvectorne, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<>(oidvector, oidvector)
is 'not equal';

alter operator pg_catalog.<>(oidvector, oidvector)
  owner to postgres;

create operator pg_catalog.< (procedure = oidvectorlt, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<(oidvector, oidvector)
is 'less than';

alter operator pg_catalog.<(oidvector, oidvector)
  owner to postgres;

create operator pg_catalog.> (procedure = oidvectorgt, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.>(oidvector, oidvector)
is 'greater than';

alter operator pg_catalog.>(oidvector, oidvector)
  owner to postgres;

create operator pg_catalog.<= (procedure = oidvectorle, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<=(oidvector, oidvector)
is 'less than or equal';

alter operator pg_catalog.<=(oidvector, oidvector)
  owner to postgres;

create operator pg_catalog.>= (procedure = oidvectorge, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.>=(oidvector, oidvector)
is 'greater than or equal';

alter operator pg_catalog.>=(oidvector, oidvector)
  owner to postgres;

create operator pg_catalog.= (procedure = oidvectoreq, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.=(oidvector, oidvector)
is 'equal';

alter operator pg_catalog.=(oidvector, oidvector)
  owner to postgres;

create operator pg_catalog.|| (procedure = textcat, leftarg = text, rightarg = text);

comment on operator pg_catalog.||(text, text)
is 'concatenate';

alter operator pg_catalog.||(text, text)
  owner to postgres;

create operator pg_catalog.< (procedure = namelt, leftarg = name, rightarg = name);

comment on operator pg_catalog.<(name, name)
is 'less than';

alter operator pg_catalog.<(name, name)
  owner to postgres;

create operator pg_catalog.<= (procedure = namele, leftarg = name, rightarg = name);

comment on operator pg_catalog.<=(name, name)
is 'less than or equal';

alter operator pg_catalog.<=(name, name)
  owner to postgres;

create operator pg_catalog.> (procedure = namegt, leftarg = name, rightarg = name);

comment on operator pg_catalog.>(name, name)
is 'greater than';

alter operator pg_catalog.>(name, name)
  owner to postgres;

create operator pg_catalog.>= (procedure = namege, leftarg = name, rightarg = name);

comment on operator pg_catalog.>=(name, name)
is 'greater than or equal';

alter operator pg_catalog.>=(name, name)
  owner to postgres;

create operator pg_catalog.< (procedure = text_lt, leftarg = text, rightarg = text);

comment on operator pg_catalog.<(text, text)
is 'less than';

alter operator pg_catalog.<(text, text)
  owner to postgres;

create operator pg_catalog.<= (procedure = text_le, leftarg = text, rightarg = text);

comment on operator pg_catalog.<=(text, text)
is 'less than or equal';

alter operator pg_catalog.<=(text, text)
  owner to postgres;

create operator pg_catalog.> (procedure = text_gt, leftarg = text, rightarg = text);

comment on operator pg_catalog.>(text, text)
is 'greater than';

alter operator pg_catalog.>(text, text)
  owner to postgres;

create operator pg_catalog.>= (procedure = text_ge, leftarg = text, rightarg = text);

comment on operator pg_catalog.>=(text, text)
is 'greater than or equal';

alter operator pg_catalog.>=(text, text)
  owner to postgres;

create operator pg_catalog.= (procedure = float8eq, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.=(double precision, double precision)
is 'equal';

alter operator pg_catalog.=(double precision, double precision)
  owner to postgres;

create operator pg_catalog.<> (procedure = float8ne, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<>(double precision, double precision)
is 'not equal';

alter operator pg_catalog.<>(double precision, double precision)
  owner to postgres;

create operator pg_catalog.< (procedure = float8lt, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<(double precision, double precision)
is 'less than';

alter operator pg_catalog.<(double precision, double precision)
  owner to postgres;

create operator pg_catalog.<= (procedure = float8le, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<=(double precision, double precision)
is 'less than or equal';

alter operator pg_catalog.<=(double precision, double precision)
  owner to postgres;

create operator pg_catalog.> (procedure = float8gt, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.>(double precision, double precision)
is 'greater than';

alter operator pg_catalog.>(double precision, double precision)
  owner to postgres;

create operator pg_catalog.>= (procedure = float8ge, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.>=(double precision, double precision)
is 'greater than or equal';

alter operator pg_catalog.>=(double precision, double precision)
  owner to postgres;

create operator pg_catalog.@ (procedure = int2abs, rightarg = smallint);

comment on operator pg_catalog.@(none, smallint)
is 'absolute value';

alter operator pg_catalog.@(none, smallint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int8pl, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.+(bigint, bigint)
is 'add';

alter operator pg_catalog.+(bigint, bigint)
  owner to postgres;

create operator pg_catalog.- (procedure = int8mi, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.-(bigint, bigint)
is 'subtract';

alter operator pg_catalog.-(bigint, bigint)
  owner to postgres;

create operator pg_catalog.* (procedure = int8mul, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.*(bigint, bigint)
is 'multiply';

alter operator pg_catalog.*(bigint, bigint)
  owner to postgres;

create operator pg_catalog./ (procedure = int8div, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog./(bigint, bigint)
is 'divide';

alter operator pg_catalog./(bigint, bigint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int84pl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.+(bigint, integer)
is 'add';

alter operator pg_catalog.+(bigint, integer)
  owner to postgres;

create operator pg_catalog.- (procedure = int84mi, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.-(bigint, integer)
is 'subtract';

alter operator pg_catalog.-(bigint, integer)
  owner to postgres;

create operator pg_catalog.* (procedure = int84mul, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.*(bigint, integer)
is 'multiply';

alter operator pg_catalog.*(bigint, integer)
  owner to postgres;

create operator pg_catalog./ (procedure = int84div, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog./(bigint, integer)
is 'divide';

alter operator pg_catalog./(bigint, integer)
  owner to postgres;

create operator pg_catalog.+ (procedure = int48pl, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.+(integer, bigint)
is 'add';

alter operator pg_catalog.+(integer, bigint)
  owner to postgres;

create operator pg_catalog.- (procedure = int48mi, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.-(integer, bigint)
is 'subtract';

alter operator pg_catalog.-(integer, bigint)
  owner to postgres;

create operator pg_catalog.* (procedure = int48mul, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.*(integer, bigint)
is 'multiply';

alter operator pg_catalog.*(integer, bigint)
  owner to postgres;

create operator pg_catalog./ (procedure = int48div, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog./(integer, bigint)
is 'divide';

alter operator pg_catalog./(integer, bigint)
  owner to postgres;

create operator pg_catalog.<-> (procedure = box_distance, leftarg = box, rightarg = box);

comment on operator pg_catalog.<->(box, box)
is 'distance between';

alter operator pg_catalog.<->(box, box)
  owner to postgres;

create operator pg_catalog.<-> (procedure = path_distance, leftarg = path, rightarg = path);

comment on operator pg_catalog.<->(path, path)
is 'distance between';

alter operator pg_catalog.<->(path, path)
  owner to postgres;

create operator pg_catalog.<-> (procedure = line_distance, leftarg = line, rightarg = line);

comment on operator pg_catalog.<->(line, line)
is 'distance between';

alter operator pg_catalog.<->(line, line)
  owner to postgres;

create operator pg_catalog.<-> (procedure = lseg_distance, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<->(lseg, lseg)
is 'distance between';

alter operator pg_catalog.<->(lseg, lseg)
  owner to postgres;

create operator pg_catalog.<-> (procedure = poly_distance, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<->(polygon, polygon)
is 'distance between';

alter operator pg_catalog.<->(polygon, polygon)
  owner to postgres;

create operator pg_catalog.<> (procedure = point_ne, leftarg = point, rightarg = point);

comment on operator pg_catalog.<>(point, point)
is 'not equal';

alter operator pg_catalog.<>(point, point)
  owner to postgres;

create operator pg_catalog.+ (procedure = point_add, leftarg = point, rightarg = point);

comment on operator pg_catalog.+(point, point)
is 'add points (translate)';

alter operator pg_catalog.+(point, point)
  owner to postgres;

create operator pg_catalog.- (procedure = point_sub, leftarg = point, rightarg = point);

comment on operator pg_catalog.-(point, point)
is 'subtract points (translate)';

alter operator pg_catalog.-(point, point)
  owner to postgres;

create operator pg_catalog.* (procedure = point_mul, leftarg = point, rightarg = point);

comment on operator pg_catalog.*(point, point)
is 'multiply points (scale/rotate)';

alter operator pg_catalog.*(point, point)
  owner to postgres;

create operator pg_catalog./ (procedure = point_div, leftarg = point, rightarg = point);

comment on operator pg_catalog./(point, point)
is 'divide points (scale/rotate)';

alter operator pg_catalog./(point, point)
  owner to postgres;

create operator pg_catalog.+ (procedure = path_add, leftarg = path, rightarg = path);

comment on operator pg_catalog.+(path, path)
is 'concatenate';

alter operator pg_catalog.+(path, path)
  owner to postgres;

create operator pg_catalog.+ (procedure = path_add_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.+(path, point)
is 'add (translate path)';

alter operator pg_catalog.+(path, point)
  owner to postgres;

create operator pg_catalog.- (procedure = path_sub_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.-(path, point)
is 'subtract (translate path)';

alter operator pg_catalog.-(path, point)
  owner to postgres;

create operator pg_catalog.* (procedure = path_mul_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.*(path, point)
is 'multiply (rotate/scale path)';

alter operator pg_catalog.*(path, point)
  owner to postgres;

create operator pg_catalog./ (procedure = path_div_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog./(path, point)
is 'divide (rotate/scale path)';

alter operator pg_catalog./(path, point)
  owner to postgres;

create operator pg_catalog.@> (procedure = path_contain_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.@>(path, point)
is 'contains';

alter operator pg_catalog.@>(path, point)
  owner to postgres;

create operator pg_catalog.<@ (procedure = pt_contained_poly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.<@(point, polygon)
is 'is contained by';

alter operator pg_catalog.<@(point, polygon)
  owner to postgres;

create operator pg_catalog.@> (procedure = poly_contain_pt, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.@>(polygon, point)
is 'contains';

alter operator pg_catalog.@>(polygon, point)
  owner to postgres;

create operator pg_catalog.<@ (procedure = pt_contained_circle, leftarg = point, rightarg = circle);

comment on operator pg_catalog.<@(point, circle)
is 'is contained by';

alter operator pg_catalog.<@(point, circle)
  owner to postgres;

create operator pg_catalog.@> (procedure = circle_contain_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.@>(circle, point)
is 'contains';

alter operator pg_catalog.@>(circle, point)
  owner to postgres;

create operator pg_catalog.@ (procedure = int4abs, rightarg = integer);

comment on operator pg_catalog.@(none, integer)
is 'absolute value';

alter operator pg_catalog.@(none, integer)
  owner to postgres;

create operator pg_catalog.= (procedure = path_n_eq, leftarg = path, rightarg = path);

comment on operator pg_catalog.=(path, path)
is 'equal';

alter operator pg_catalog.=(path, path)
  owner to postgres;

create operator pg_catalog.< (procedure = path_n_lt, leftarg = path, rightarg = path);

comment on operator pg_catalog.<(path, path)
is 'less than';

alter operator pg_catalog.<(path, path)
  owner to postgres;

create operator pg_catalog.> (procedure = path_n_gt, leftarg = path, rightarg = path);

comment on operator pg_catalog.>(path, path)
is 'greater than';

alter operator pg_catalog.>(path, path)
  owner to postgres;

create operator pg_catalog.<= (procedure = path_n_le, leftarg = path, rightarg = path);

comment on operator pg_catalog.<=(path, path)
is 'less than or equal';

alter operator pg_catalog.<=(path, path)
  owner to postgres;

create operator pg_catalog.>= (procedure = path_n_ge, leftarg = path, rightarg = path);

comment on operator pg_catalog.>=(path, path)
is 'greater than or equal';

alter operator pg_catalog.>=(path, path)
  owner to postgres;

create operator pg_catalog.# (procedure = path_npoints, rightarg = path);

comment on operator pg_catalog.#(none, path)
is 'number of points';

alter operator pg_catalog.#(none, path)
  owner to postgres;

create operator pg_catalog.?# (procedure = path_inter, leftarg = path, rightarg = path);

comment on operator pg_catalog.?#(path, path)
is 'intersect';

alter operator pg_catalog.?#(path, path)
  owner to postgres;

create operator pg_catalog.@-@ (procedure = path_length, rightarg = path);

comment on operator pg_catalog.@-@(none, path)
is 'sum of path segment lengths';

alter operator pg_catalog.@-@(none, path)
  owner to postgres;

create operator pg_catalog.>^ (procedure = box_above_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.>^(box, box)
is 'is above (allows touching)';

alter operator pg_catalog.>^(box, box)
  owner to postgres;

create operator pg_catalog.<^ (procedure = box_below_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.<^(box, box)
is 'is below (allows touching)';

alter operator pg_catalog.<^(box, box)
  owner to postgres;

create operator pg_catalog.?# (procedure = box_overlap, leftarg = box, rightarg = box);

comment on operator pg_catalog.?#(box, box)
is 'deprecated, use && instead';

alter operator pg_catalog.?#(box, box)
  owner to postgres;

create operator pg_catalog.# (procedure = box_intersect, leftarg = box, rightarg = box);

comment on operator pg_catalog.#(box, box)
is 'box intersection';

alter operator pg_catalog.#(box, box)
  owner to postgres;

create operator pg_catalog.+ (procedure = box_add, leftarg = box, rightarg = point);

comment on operator pg_catalog.+(box, point)
is 'add point to box (translate)';

alter operator pg_catalog.+(box, point)
  owner to postgres;

create operator pg_catalog.- (procedure = box_sub, leftarg = box, rightarg = point);

comment on operator pg_catalog.-(box, point)
is 'subtract point from box (translate)';

alter operator pg_catalog.-(box, point)
  owner to postgres;

create operator pg_catalog.* (procedure = box_mul, leftarg = box, rightarg = point);

comment on operator pg_catalog.*(box, point)
is 'multiply box by point (scale)';

alter operator pg_catalog.*(box, point)
  owner to postgres;

create operator pg_catalog./ (procedure = box_div, leftarg = box, rightarg = point);

comment on operator pg_catalog./(box, point)
is 'divide box by point (scale)';

alter operator pg_catalog./(box, point)
  owner to postgres;

create operator pg_catalog.?- (procedure = point_horiz, leftarg = point, rightarg = point);

comment on operator pg_catalog.?-(point, point)
is 'horizontally aligned';

alter operator pg_catalog.?-(point, point)
  owner to postgres;

create operator pg_catalog.?| (procedure = point_vert, leftarg = point, rightarg = point);

comment on operator pg_catalog.?|(point, point)
is 'vertically aligned';

alter operator pg_catalog.?|(point, point)
  owner to postgres;

create operator pg_catalog.= (procedure = tintervaleq, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.=(tinterval, tinterval)
is 'equal';

alter operator pg_catalog.=(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.<> (procedure = tintervalne, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<>(tinterval, tinterval)
is 'not equal';

alter operator pg_catalog.<>(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.< (procedure = tintervallt, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<(tinterval, tinterval)
is 'less than';

alter operator pg_catalog.<(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.> (procedure = tintervalgt, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.>(tinterval, tinterval)
is 'greater than';

alter operator pg_catalog.>(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.<= (procedure = tintervalle, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<=(tinterval, tinterval)
is 'less than or equal';

alter operator pg_catalog.<=(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.>= (procedure = tintervalge, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.>=(tinterval, tinterval)
is 'greater than or equal';

alter operator pg_catalog.>=(tinterval, tinterval)
  owner to postgres;

create operator pg_catalog.+ (procedure = int82pl, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.+(bigint, smallint)
is 'add';

alter operator pg_catalog.+(bigint, smallint)
  owner to postgres;

create operator pg_catalog.- (procedure = int82mi, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.-(bigint, smallint)
is 'subtract';

alter operator pg_catalog.-(bigint, smallint)
  owner to postgres;

create operator pg_catalog.* (procedure = int82mul, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.*(bigint, smallint)
is 'multiply';

alter operator pg_catalog.*(bigint, smallint)
  owner to postgres;

create operator pg_catalog./ (procedure = int82div, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog./(bigint, smallint)
is 'divide';

alter operator pg_catalog./(bigint, smallint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int28pl, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.+(smallint, bigint)
is 'add';

alter operator pg_catalog.+(smallint, bigint)
  owner to postgres;

create operator pg_catalog.- (procedure = int28mi, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.-(smallint, bigint)
is 'subtract';

alter operator pg_catalog.-(smallint, bigint)
  owner to postgres;

create operator pg_catalog.* (procedure = int28mul, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.*(smallint, bigint)
is 'multiply';

alter operator pg_catalog.*(smallint, bigint)
  owner to postgres;

create operator pg_catalog./ (procedure = int28div, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog./(smallint, bigint)
is 'divide';

alter operator pg_catalog./(smallint, bigint)
  owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog.*(money, real)
is 'multiply';

alter operator pg_catalog.*(money, real)
  owner to postgres;

create operator pg_catalog./ (procedure = cash_div_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog./(money, real)
is 'divide';

alter operator pg_catalog./(money, real)
  owner to postgres;

create operator pg_catalog.* (procedure = flt4_mul_cash, leftarg = real, rightarg = money);

comment on operator pg_catalog.*(real, money)
is 'multiply';

alter operator pg_catalog.*(real, money)
  owner to postgres;

create operator pg_catalog.= (procedure = cash_eq, leftarg = money, rightarg = money);

comment on operator pg_catalog.=(money, money)
is 'equal';

alter operator pg_catalog.=(money, money)
  owner to postgres;

create operator pg_catalog.<> (procedure = cash_ne, leftarg = money, rightarg = money);

comment on operator pg_catalog.<>(money, money)
is 'not equal';

alter operator pg_catalog.<>(money, money)
  owner to postgres;

create operator pg_catalog.< (procedure = cash_lt, leftarg = money, rightarg = money);

comment on operator pg_catalog.<(money, money)
is 'less than';

alter operator pg_catalog.<(money, money)
  owner to postgres;

create operator pg_catalog.> (procedure = cash_gt, leftarg = money, rightarg = money);

comment on operator pg_catalog.>(money, money)
is 'greater than';

alter operator pg_catalog.>(money, money)
  owner to postgres;

create operator pg_catalog.<= (procedure = cash_le, leftarg = money, rightarg = money);

comment on operator pg_catalog.<=(money, money)
is 'less than or equal';

alter operator pg_catalog.<=(money, money)
  owner to postgres;

create operator pg_catalog.>= (procedure = cash_ge, leftarg = money, rightarg = money);

comment on operator pg_catalog.>=(money, money)
is 'greater than or equal';

alter operator pg_catalog.>=(money, money)
  owner to postgres;

create operator pg_catalog.+ (procedure = cash_pl, leftarg = money, rightarg = money);

comment on operator pg_catalog.+(money, money)
is 'add';

alter operator pg_catalog.+(money, money)
  owner to postgres;

create operator pg_catalog.- (procedure = cash_mi, leftarg = money, rightarg = money);

comment on operator pg_catalog.-(money, money)
is 'subtract';

alter operator pg_catalog.-(money, money)
  owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog.*(money, double precision)
is 'multiply';

alter operator pg_catalog.*(money, double precision)
  owner to postgres;

create operator pg_catalog./ (procedure = cash_div_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog./(money, double precision)
is 'divide';

alter operator pg_catalog./(money, double precision)
  owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog.*(money, integer)
is 'multiply';

alter operator pg_catalog.*(money, integer)
  owner to postgres;

create operator pg_catalog./ (procedure = cash_div_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog./(money, integer)
is 'divide';

alter operator pg_catalog./(money, integer)
  owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog.*(money, smallint)
is 'multiply';

alter operator pg_catalog.*(money, smallint)
  owner to postgres;

create operator pg_catalog./ (procedure = cash_div_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog./(money, smallint)
is 'divide';

alter operator pg_catalog./(money, smallint)
  owner to postgres;

create operator pg_catalog.* (procedure = flt8_mul_cash, leftarg = double precision, rightarg = money);

comment on operator pg_catalog.*(double precision, money)
is 'multiply';

alter operator pg_catalog.*(double precision, money)
  owner to postgres;

create operator pg_catalog.* (procedure = int4_mul_cash, leftarg = integer, rightarg = money);

comment on operator pg_catalog.*(integer, money)
is 'multiply';

alter operator pg_catalog.*(integer, money)
  owner to postgres;

create operator pg_catalog.* (procedure = int2_mul_cash, leftarg = smallint, rightarg = money);

comment on operator pg_catalog.*(smallint, money)
is 'multiply';

alter operator pg_catalog.*(smallint, money)
  owner to postgres;

create operator pg_catalog.<< (procedure = network_sub, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<<(inet, inet)
is 'is subnet';

alter operator pg_catalog.<<(inet, inet)
  owner to postgres;

create operator pg_catalog.<<= (procedure = network_subeq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<<=(inet, inet)
is 'is subnet or equal';

alter operator pg_catalog.<<=(inet, inet)
  owner to postgres;

create operator pg_catalog.>> (procedure = network_sup, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>>(inet, inet)
is 'is supernet';

alter operator pg_catalog.>>(inet, inet)
  owner to postgres;

create operator pg_catalog.>>= (procedure = network_supeq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>>=(inet, inet)
is 'is supernet or equal';

alter operator pg_catalog.>>=(inet, inet)
  owner to postgres;

create operator pg_catalog.^ (procedure = dpow, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.^(double precision, double precision)
is 'exponentiation';

alter operator pg_catalog.^(double precision, double precision)
  owner to postgres;

create operator pg_catalog.+ (procedure = aclinsert, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.+(aclitem [], aclitem)
is 'add/update ACL item';

alter operator pg_catalog.+(aclitem [], aclitem)
  owner to postgres;

create operator pg_catalog.- (procedure = aclremove, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.-(aclitem [], aclitem)
is 'remove ACL item';

alter operator pg_catalog.-(aclitem [], aclitem)
  owner to postgres;

create operator pg_catalog.@> (procedure = aclcontains, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.@>(aclitem [], aclitem)
is 'contains';

alter operator pg_catalog.@>(aclitem [], aclitem)
  owner to postgres;

create operator pg_catalog.@@ (procedure = lseg_center, rightarg = lseg);

comment on operator pg_catalog.@@(none, lseg)
is 'center of';

alter operator pg_catalog.@@(none, lseg)
  owner to postgres;

create operator pg_catalog.@@ (procedure = path_center, rightarg = path);

comment on operator pg_catalog.@@(none, path)
is 'center of';

alter operator pg_catalog.@@(none, path)
  owner to postgres;

create operator pg_catalog.@@ (procedure = poly_center, rightarg = polygon);

comment on operator pg_catalog.@@(none, polygon)
is 'center of';

alter operator pg_catalog.@@(none, polygon)
  owner to postgres;

create operator pg_catalog.= (procedure = aclitemeq, leftarg = aclitem, rightarg = aclitem);

comment on operator pg_catalog.=(aclitem, aclitem)
is 'equal';

alter operator pg_catalog.=(aclitem, aclitem)
  owner to postgres;

create operator pg_catalog.^ (procedure = numeric_power, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.^(numeric, numeric)
is 'exponentiation';

alter operator pg_catalog.^(numeric, numeric)
  owner to postgres;

create operator pg_catalog.= (procedure = bpchareq, leftarg = char, rightarg = char);

comment on operator pg_catalog.=(char, char)
is 'equal';

alter operator pg_catalog.=(char, char)
  owner to postgres;

create operator pg_catalog.~ (procedure = bpcharregexeq, leftarg = char, rightarg = text);

comment on operator pg_catalog.~(char, text)
is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(char, text)
  owner to postgres;

create operator pg_catalog.!~ (procedure = bpcharregexne, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~(char, text)
is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(char, text)
  owner to postgres;

create operator pg_catalog.<> (procedure = bpcharne, leftarg = char, rightarg = char);

comment on operator pg_catalog.<>(char, char)
is 'not equal';

alter operator pg_catalog.<>(char, char)
  owner to postgres;

create operator pg_catalog.< (procedure = bpcharlt, leftarg = char, rightarg = char);

comment on operator pg_catalog.<(char, char)
is 'less than';

alter operator pg_catalog.<(char, char)
  owner to postgres;

create operator pg_catalog.<= (procedure = bpcharle, leftarg = char, rightarg = char);

comment on operator pg_catalog.<=(char, char)
is 'less than or equal';

alter operator pg_catalog.<=(char, char)
  owner to postgres;

create operator pg_catalog.> (procedure = bpchargt, leftarg = char, rightarg = char);

comment on operator pg_catalog.>(char, char)
is 'greater than';

alter operator pg_catalog.>(char, char)
  owner to postgres;

create operator pg_catalog.>= (procedure = bpcharge, leftarg = char, rightarg = char);

comment on operator pg_catalog.>=(char, char)
is 'greater than or equal';

alter operator pg_catalog.>=(char, char)
  owner to postgres;

create operator pg_catalog.= (procedure = array_eq, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.=(anyarray, anyarray)
is 'equal';

alter operator pg_catalog.=(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.<> (procedure = array_ne, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<>(anyarray, anyarray)
is 'not equal';

alter operator pg_catalog.<>(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.< (procedure = array_lt, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<(anyarray, anyarray)
is 'less than';

alter operator pg_catalog.<(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.> (procedure = array_gt, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.>(anyarray, anyarray)
is 'greater than';

alter operator pg_catalog.>(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.<= (procedure = array_le, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<=(anyarray, anyarray)
is 'less than or equal';

alter operator pg_catalog.<=(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.>= (procedure = array_ge, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.>=(anyarray, anyarray)
is 'greater than or equal';

alter operator pg_catalog.>=(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.+ (procedure = date_pl_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.+(date, interval)
is 'add';

alter operator pg_catalog.+(date, interval)
  owner to postgres;

create operator pg_catalog.- (procedure = date_mi_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.-(date, interval)
is 'subtract';

alter operator pg_catalog.-(date, interval)
  owner to postgres;

create operator pg_catalog.= (procedure = date_eq, leftarg = date, rightarg = date);

comment on operator pg_catalog.=(date, date)
is 'equal';

alter operator pg_catalog.=(date, date)
  owner to postgres;

create operator pg_catalog.<> (procedure = date_ne, leftarg = date, rightarg = date);

comment on operator pg_catalog.<>(date, date)
is 'not equal';

alter operator pg_catalog.<>(date, date)
  owner to postgres;

create operator pg_catalog.< (procedure = date_lt, leftarg = date, rightarg = date);

comment on operator pg_catalog.<(date, date)
is 'less than';

alter operator pg_catalog.<(date, date)
  owner to postgres;

create operator pg_catalog.<= (procedure = date_le, leftarg = date, rightarg = date);

comment on operator pg_catalog.<=(date, date)
is 'less than or equal';

alter operator pg_catalog.<=(date, date)
  owner to postgres;

create operator pg_catalog.> (procedure = date_gt, leftarg = date, rightarg = date);

comment on operator pg_catalog.>(date, date)
is 'greater than';

alter operator pg_catalog.>(date, date)
  owner to postgres;

create operator pg_catalog.>= (procedure = date_ge, leftarg = date, rightarg = date);

comment on operator pg_catalog.>=(date, date)
is 'greater than or equal';

alter operator pg_catalog.>=(date, date)
  owner to postgres;

create operator pg_catalog.- (procedure = date_mi, leftarg = date, rightarg = date);

comment on operator pg_catalog.-(date, date)
is 'subtract';

alter operator pg_catalog.-(date, date)
  owner to postgres;

create operator pg_catalog.+ (procedure = date_pli, leftarg = date, rightarg = integer);

comment on operator pg_catalog.+(date, integer)
is 'add';

alter operator pg_catalog.+(date, integer)
  owner to postgres;

create operator pg_catalog.- (procedure = date_mii, leftarg = date, rightarg = integer);

comment on operator pg_catalog.-(date, integer)
is 'subtract';

alter operator pg_catalog.-(date, integer)
  owner to postgres;

create operator pg_catalog.= (procedure = time_eq, leftarg = time, rightarg = time);

comment on operator pg_catalog.=(time, time)
is 'equal';

alter operator pg_catalog.=(time, time)
  owner to postgres;

create operator pg_catalog.<> (procedure = time_ne, leftarg = time, rightarg = time);

comment on operator pg_catalog.<>(time, time)
is 'not equal';

alter operator pg_catalog.<>(time, time)
  owner to postgres;

create operator pg_catalog.< (procedure = time_lt, leftarg = time, rightarg = time);

comment on operator pg_catalog.<(time, time)
is 'less than';

alter operator pg_catalog.<(time, time)
  owner to postgres;

create operator pg_catalog.<= (procedure = time_le, leftarg = time, rightarg = time);

comment on operator pg_catalog.<=(time, time)
is 'less than or equal';

alter operator pg_catalog.<=(time, time)
  owner to postgres;

create operator pg_catalog.> (procedure = time_gt, leftarg = time, rightarg = time);

comment on operator pg_catalog.>(time, time)
is 'greater than';

alter operator pg_catalog.>(time, time)
  owner to postgres;

create operator pg_catalog.>= (procedure = time_ge, leftarg = time, rightarg = time);

comment on operator pg_catalog.>=(time, time)
is 'greater than or equal';

alter operator pg_catalog.>=(time, time)
  owner to postgres;

create operator pg_catalog.+ (procedure = float48pl, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.+(real, double precision)
is 'add';

alter operator pg_catalog.+(real, double precision)
  owner to postgres;

create operator pg_catalog.- (procedure = float48mi, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.-(real, double precision)
is 'subtract';

alter operator pg_catalog.-(real, double precision)
  owner to postgres;

create operator pg_catalog./ (procedure = float48div, leftarg = real, rightarg = double precision);

comment on operator pg_catalog./(real, double precision)
is 'divide';

alter operator pg_catalog./(real, double precision)
  owner to postgres;

create operator pg_catalog.* (procedure = float48mul, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.*(real, double precision)
is 'multiply';

alter operator pg_catalog.*(real, double precision)
  owner to postgres;

create operator pg_catalog.= (procedure = float48eq, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.=(real, double precision)
is 'equal';

alter operator pg_catalog.=(real, double precision)
  owner to postgres;

create operator pg_catalog.<> (procedure = float48ne, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<>(real, double precision)
is 'not equal';

alter operator pg_catalog.<>(real, double precision)
  owner to postgres;

create operator pg_catalog.< (procedure = float48lt, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<(real, double precision)
is 'less than';

alter operator pg_catalog.<(real, double precision)
  owner to postgres;

create operator pg_catalog.> (procedure = float48gt, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.>(real, double precision)
is 'greater than';

alter operator pg_catalog.>(real, double precision)
  owner to postgres;

create operator pg_catalog.<= (procedure = float48le, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<=(real, double precision)
is 'less than or equal';

alter operator pg_catalog.<=(real, double precision)
  owner to postgres;

create operator pg_catalog.>= (procedure = float48ge, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.>=(real, double precision)
is 'greater than or equal';

alter operator pg_catalog.>=(real, double precision)
  owner to postgres;

create operator pg_catalog.+ (procedure = float84pl, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.+(double precision, real)
is 'add';

alter operator pg_catalog.+(double precision, real)
  owner to postgres;

create operator pg_catalog.- (procedure = float84mi, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.-(double precision, real)
is 'subtract';

alter operator pg_catalog.-(double precision, real)
  owner to postgres;

create operator pg_catalog./ (procedure = float84div, leftarg = double precision, rightarg = real);

comment on operator pg_catalog./(double precision, real)
is 'divide';

alter operator pg_catalog./(double precision, real)
  owner to postgres;

create operator pg_catalog.* (procedure = float84mul, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.*(double precision, real)
is 'multiply';

alter operator pg_catalog.*(double precision, real)
  owner to postgres;

create operator pg_catalog.= (procedure = float84eq, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.=(double precision, real)
is 'equal';

alter operator pg_catalog.=(double precision, real)
  owner to postgres;

create operator pg_catalog.<> (procedure = float84ne, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<>(double precision, real)
is 'not equal';

alter operator pg_catalog.<>(double precision, real)
  owner to postgres;

create operator pg_catalog.< (procedure = float84lt, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<(double precision, real)
is 'less than';

alter operator pg_catalog.<(double precision, real)
  owner to postgres;

create operator pg_catalog.> (procedure = float84gt, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.>(double precision, real)
is 'greater than';

alter operator pg_catalog.>(double precision, real)
  owner to postgres;

create operator pg_catalog.<= (procedure = float84le, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<=(double precision, real)
is 'less than or equal';

alter operator pg_catalog.<=(double precision, real)
  owner to postgres;

create operator pg_catalog.>= (procedure = float84ge, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.>=(double precision, real)
is 'greater than or equal';

alter operator pg_catalog.>=(double precision, real)
  owner to postgres;

create operator pg_catalog.= (procedure = network_eq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.=(inet, inet)
is 'equal';

alter operator pg_catalog.=(inet, inet)
  owner to postgres;

create operator pg_catalog.<> (procedure = network_ne, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<>(inet, inet)
is 'not equal';

alter operator pg_catalog.<>(inet, inet)
  owner to postgres;

create operator pg_catalog.< (procedure = network_lt, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<(inet, inet)
is 'less than';

alter operator pg_catalog.<(inet, inet)
  owner to postgres;

create operator pg_catalog.<= (procedure = network_le, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<=(inet, inet)
is 'less than or equal';

alter operator pg_catalog.<=(inet, inet)
  owner to postgres;

create operator pg_catalog.> (procedure = network_gt, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>(inet, inet)
is 'greater than';

alter operator pg_catalog.>(inet, inet)
  owner to postgres;

create operator pg_catalog.>= (procedure = network_ge, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>=(inet, inet)
is 'greater than or equal';

alter operator pg_catalog.>=(inet, inet)
  owner to postgres;

create operator pg_catalog.~~ (procedure = namelike, leftarg = name, rightarg = text);

comment on operator pg_catalog.~~(name, text)
is 'matches LIKE expression';

alter operator pg_catalog.~~(name, text)
  owner to postgres;

create operator pg_catalog.!~~ (procedure = namenlike, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~~(name, text)
is 'does not match LIKE expression';

alter operator pg_catalog.!~~(name, text)
  owner to postgres;

create operator pg_catalog.~~ (procedure = textlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.~~(text, text)
is 'matches LIKE expression';

alter operator pg_catalog.~~(text, text)
  owner to postgres;

create operator pg_catalog.!~~ (procedure = textnlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~~(text, text)
is 'does not match LIKE expression';

alter operator pg_catalog.!~~(text, text)
  owner to postgres;

create operator pg_catalog.~~ (procedure = bpcharlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.~~(char, text)
is 'matches LIKE expression';

alter operator pg_catalog.~~(char, text)
  owner to postgres;

create operator pg_catalog.!~~ (procedure = bpcharnlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~~(char, text)
is 'does not match LIKE expression';

alter operator pg_catalog.!~~(char, text)
  owner to postgres;

create operator pg_catalog.= (procedure = macaddr_eq, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.=(macaddr, macaddr)
is 'equal';

alter operator pg_catalog.=(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.<> (procedure = macaddr_ne, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<>(macaddr, macaddr)
is 'not equal';

alter operator pg_catalog.<>(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.< (procedure = macaddr_lt, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<(macaddr, macaddr)
is 'less than';

alter operator pg_catalog.<(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.<= (procedure = macaddr_le, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<=(macaddr, macaddr)
is 'less than or equal';

alter operator pg_catalog.<=(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.> (procedure = macaddr_gt, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.>(macaddr, macaddr)
is 'greater than';

alter operator pg_catalog.>(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.>= (procedure = macaddr_ge, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.>=(macaddr, macaddr)
is 'greater than or equal';

alter operator pg_catalog.>=(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.~* (procedure = nameicregexeq, leftarg = name, rightarg = text);

comment on operator pg_catalog.~*(name, text)
is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(name, text)
  owner to postgres;

create operator pg_catalog.!~* (procedure = nameicregexne, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~*(name, text)
is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(name, text)
  owner to postgres;

create operator pg_catalog.~* (procedure = texticregexeq, leftarg = text, rightarg = text);

comment on operator pg_catalog.~*(text, text)
is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(text, text)
  owner to postgres;

create operator pg_catalog.!~* (procedure = texticregexne, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~*(text, text)
is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(text, text)
  owner to postgres;

create operator pg_catalog.~* (procedure = bpcharicregexeq, leftarg = char, rightarg = text);

comment on operator pg_catalog.~*(char, text)
is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(char, text)
  owner to postgres;

create operator pg_catalog.!~* (procedure = bpcharicregexne, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~*(char, text)
is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(char, text)
  owner to postgres;

create operator pg_catalog.| (procedure = tintervalstart, rightarg = tinterval);

comment on operator pg_catalog.|(none, tinterval)
is 'start of interval';

alter operator pg_catalog.|(none, tinterval)
  owner to postgres;

create operator pg_catalog.= (procedure = timestamptz_eq, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(timestamp with time zone, timestamp with time zone)
is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.<> (procedure = timestamptz_ne, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp with time zone)
is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.< (procedure = timestamptz_lt, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(timestamp with time zone, timestamp with time zone)
is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.<= (procedure = timestamptz_le, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp with time zone)
is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.> (procedure = timestamptz_gt, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(timestamp with time zone, timestamp with time zone)
is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.>= (procedure = timestamptz_ge, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp with time zone)
is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.+ (procedure = timestamptz_pl_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.+(timestamp with time zone, interval)
is 'add';

alter operator pg_catalog.+(timestamp with time zone, interval)
  owner to postgres;

create operator pg_catalog.- (procedure = timestamptz_mi, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.-(timestamp with time zone, timestamp with time zone)
is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.- (procedure = timestamptz_mi_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.-(timestamp with time zone, interval)
is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, interval)
  owner to postgres;

create operator pg_catalog.= (procedure = interval_eq, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.=(interval, interval)
is 'equal';

alter operator pg_catalog.=(interval, interval)
  owner to postgres;

create operator pg_catalog.<> (procedure = interval_ne, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<>(interval, interval)
is 'not equal';

alter operator pg_catalog.<>(interval, interval)
  owner to postgres;

create operator pg_catalog.< (procedure = interval_lt, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<(interval, interval)
is 'less than';

alter operator pg_catalog.<(interval, interval)
  owner to postgres;

create operator pg_catalog.<= (procedure = interval_le, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<=(interval, interval)
is 'less than or equal';

alter operator pg_catalog.<=(interval, interval)
  owner to postgres;

create operator pg_catalog.> (procedure = interval_gt, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.>(interval, interval)
is 'greater than';

alter operator pg_catalog.>(interval, interval)
  owner to postgres;

create operator pg_catalog.>= (procedure = interval_ge, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.>=(interval, interval)
is 'greater than or equal';

alter operator pg_catalog.>=(interval, interval)
  owner to postgres;

create operator pg_catalog.- (procedure = interval_um, rightarg = interval);

comment on operator pg_catalog.-(none, interval)
is 'negate';

alter operator pg_catalog.-(none, interval)
  owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.+(interval, interval)
is 'add';

alter operator pg_catalog.+(interval, interval)
  owner to postgres;

create operator pg_catalog.- (procedure = interval_mi, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.-(interval, interval)
is 'subtract';

alter operator pg_catalog.-(interval, interval)
  owner to postgres;

create operator pg_catalog.+ (procedure = datetime_pl, leftarg = date, rightarg = time);

comment on operator pg_catalog.+(date, time)
is 'convert date and time to timestamp';

alter operator pg_catalog.+(date, time)
  owner to postgres;

create operator pg_catalog.+ (procedure = datetimetz_pl, leftarg = date, rightarg = time with time zone);

comment on operator pg_catalog.+(date, time with time zone)
is 'convert date and time with time zone to timestamp with time zone';

alter operator pg_catalog.+(date, time with time zone)
  owner to postgres;

create operator pg_catalog.+ (procedure = timedate_pl, leftarg = time, rightarg = date);

comment on operator pg_catalog.+(time, date)
is 'convert time and date to timestamp';

alter operator pg_catalog.+(time, date)
  owner to postgres;

create operator pg_catalog.+ (procedure = timetzdate_pl, leftarg = time with time zone, rightarg = date);

comment on operator pg_catalog.+(time with time zone, date)
is 'convert time with time zone and date to timestamp with time zone';

alter operator pg_catalog.+(time with time zone, date)
  owner to postgres;

create operator pg_catalog.- (procedure = time_mi_time, leftarg = time, rightarg = time);

comment on operator pg_catalog.-(time, time)
is 'subtract';

alter operator pg_catalog.-(time, time)
  owner to postgres;

create operator pg_catalog.@@ (procedure = circle_center, rightarg = circle);

comment on operator pg_catalog.@@(none, circle)
is 'center of';

alter operator pg_catalog.@@(none, circle)
  owner to postgres;

create operator pg_catalog.= (procedure = circle_eq, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.=(circle, circle)
is 'equal by area';

alter operator pg_catalog.=(circle, circle)
  owner to postgres;

create operator pg_catalog.<> (procedure = circle_ne, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<>(circle, circle)
is 'not equal by area';

alter operator pg_catalog.<>(circle, circle)
  owner to postgres;

create operator pg_catalog.< (procedure = circle_lt, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<(circle, circle)
is 'less than by area';

alter operator pg_catalog.<(circle, circle)
  owner to postgres;

create operator pg_catalog.> (procedure = circle_gt, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>(circle, circle)
is 'greater than by area';

alter operator pg_catalog.>(circle, circle)
  owner to postgres;

create operator pg_catalog.<= (procedure = circle_le, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<=(circle, circle)
is 'less than or equal by area';

alter operator pg_catalog.<=(circle, circle)
  owner to postgres;

create operator pg_catalog.>= (procedure = circle_ge, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>=(circle, circle)
is 'greater than or equal by area';

alter operator pg_catalog.>=(circle, circle)
  owner to postgres;

create operator pg_catalog.<< (procedure = circle_left, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<<(circle, circle)
is 'is left of';

alter operator pg_catalog.<<(circle, circle)
  owner to postgres;

create operator pg_catalog.&< (procedure = circle_overleft, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&<(circle, circle)
is 'overlaps or is left of';

alter operator pg_catalog.&<(circle, circle)
  owner to postgres;

create operator pg_catalog.&> (procedure = circle_overright, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&>(circle, circle)
is 'overlaps or is right of';

alter operator pg_catalog.&>(circle, circle)
  owner to postgres;

create operator pg_catalog.>> (procedure = circle_right, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>>(circle, circle)
is 'is right of';

alter operator pg_catalog.>>(circle, circle)
  owner to postgres;

create operator pg_catalog.<@ (procedure = circle_contained, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<@(circle, circle)
is 'is contained by';

alter operator pg_catalog.<@(circle, circle)
  owner to postgres;

create operator pg_catalog.@> (procedure = circle_contain, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.@>(circle, circle)
is 'contains';

alter operator pg_catalog.@>(circle, circle)
  owner to postgres;

create operator pg_catalog.~= (procedure = circle_same, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.~=(circle, circle)
is 'same as';

alter operator pg_catalog.~=(circle, circle)
  owner to postgres;

create operator pg_catalog.&& (procedure = circle_overlap, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&&(circle, circle)
is 'overlaps';

alter operator pg_catalog.&&(circle, circle)
  owner to postgres;

create operator pg_catalog.|>> (procedure = circle_above, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.|>>(circle, circle)
is 'is above';

alter operator pg_catalog.|>>(circle, circle)
  owner to postgres;

create operator pg_catalog.<<| (procedure = circle_below, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<<|(circle, circle)
is 'is below';

alter operator pg_catalog.<<|(circle, circle)
  owner to postgres;

create operator pg_catalog.+ (procedure = circle_add_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.+(circle, point)
is 'add';

alter operator pg_catalog.+(circle, point)
  owner to postgres;

create operator pg_catalog.- (procedure = circle_sub_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.-(circle, point)
is 'subtract';

alter operator pg_catalog.-(circle, point)
  owner to postgres;

create operator pg_catalog.* (procedure = circle_mul_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.*(circle, point)
is 'multiply';

alter operator pg_catalog.*(circle, point)
  owner to postgres;

create operator pg_catalog./ (procedure = circle_div_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog./(circle, point)
is 'divide';

alter operator pg_catalog./(circle, point)
  owner to postgres;

create operator pg_catalog.<-> (procedure = circle_distance, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<->(circle, circle)
is 'distance between';

alter operator pg_catalog.<->(circle, circle)
  owner to postgres;

create operator pg_catalog.# (procedure = poly_npoints, rightarg = polygon);

comment on operator pg_catalog.#(none, polygon)
is 'number of points';

alter operator pg_catalog.#(none, polygon)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_pc, leftarg = point, rightarg = circle);

comment on operator pg_catalog.<->(point, circle)
is 'distance between';

alter operator pg_catalog.<->(point, circle)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_cpoly, leftarg = circle, rightarg = polygon);

comment on operator pg_catalog.<->(circle, polygon)
is 'distance between';

alter operator pg_catalog.<->(circle, polygon)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.<->(line, box)
is 'distance between';

alter operator pg_catalog.<->(line, box)
  owner to postgres;

create operator pg_catalog.?# (procedure = lseg_intersect, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?#(lseg, lseg)
is 'intersect';

alter operator pg_catalog.?#(lseg, lseg)
  owner to postgres;

create operator pg_catalog.?|| (procedure = lseg_parallel, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?||(lseg, lseg)
is 'parallel';

alter operator pg_catalog.?||(lseg, lseg)
  owner to postgres;

create operator pg_catalog.?-| (procedure = lseg_perp, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?-|(lseg, lseg)
is 'perpendicular';

alter operator pg_catalog.?-|(lseg, lseg)
  owner to postgres;

create operator pg_catalog.?- (procedure = lseg_horizontal, rightarg = lseg);

comment on operator pg_catalog.?-(none, lseg)
is 'horizontal';

alter operator pg_catalog.?-(none, lseg)
  owner to postgres;

create operator pg_catalog.?| (procedure = lseg_vertical, rightarg = lseg);

comment on operator pg_catalog.?|(none, lseg)
is 'vertical';

alter operator pg_catalog.?|(none, lseg)
  owner to postgres;

create operator pg_catalog.= (procedure = lseg_eq, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.=(lseg, lseg)
is 'equal';

alter operator pg_catalog.=(lseg, lseg)
  owner to postgres;

create operator pg_catalog.# (procedure = lseg_interpt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.#(lseg, lseg)
is 'intersection point';

alter operator pg_catalog.#(lseg, lseg)
  owner to postgres;

create operator pg_catalog.?# (procedure = inter_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.?#(lseg, line)
is 'intersect';

alter operator pg_catalog.?#(lseg, line)
  owner to postgres;

create operator pg_catalog.?# (procedure = inter_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.?#(lseg, box)
is 'intersect';

alter operator pg_catalog.?#(lseg, box)
  owner to postgres;

create operator pg_catalog.?# (procedure = inter_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.?#(line, box)
is 'intersect';

alter operator pg_catalog.?#(line, box)
  owner to postgres;

create operator pg_catalog.<@ (procedure = on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<@(point, line)
is 'point on line';

alter operator pg_catalog.<@(point, line)
  owner to postgres;

create operator pg_catalog.<@ (procedure = on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<@(point, lseg)
is 'is contained by';

alter operator pg_catalog.<@(point, lseg)
  owner to postgres;

create operator pg_catalog.<@ (procedure = on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<@(lseg, line)
is 'lseg on line';

alter operator pg_catalog.<@(lseg, line)
  owner to postgres;

create operator pg_catalog.<@ (procedure = on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<@(lseg, box)
is 'is contained by';

alter operator pg_catalog.<@(lseg, box)
  owner to postgres;

create operator pg_catalog.= (procedure = timetz_eq, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.=(time with time zone, time with time zone)
is 'equal';

alter operator pg_catalog.=(time with time zone, time with time zone)
  owner to postgres;

create operator pg_catalog.<> (procedure = timetz_ne, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<>(time with time zone, time with time zone)
is 'not equal';

alter operator pg_catalog.<>(time with time zone, time with time zone)
  owner to postgres;

create operator pg_catalog.< (procedure = timetz_lt, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<(time with time zone, time with time zone)
is 'less than';

alter operator pg_catalog.<(time with time zone, time with time zone)
  owner to postgres;

create operator pg_catalog.<= (procedure = timetz_le, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<=(time with time zone, time with time zone)
is 'less than or equal';

alter operator pg_catalog.<=(time with time zone, time with time zone)
  owner to postgres;

create operator pg_catalog.> (procedure = timetz_gt, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.>(time with time zone, time with time zone)
is 'greater than';

alter operator pg_catalog.>(time with time zone, time with time zone)
  owner to postgres;

create operator pg_catalog.>= (procedure = timetz_ge, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.>=(time with time zone, time with time zone)
is 'greater than or equal';

alter operator pg_catalog.>=(time with time zone, time with time zone)
  owner to postgres;

create operator pg_catalog.## (procedure = close_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.##(point, line)
is 'closest point to A on B';

alter operator pg_catalog.##(point, line)
  owner to postgres;

create operator pg_catalog.## (procedure = close_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.##(point, lseg)
is 'closest point to A on B';

alter operator pg_catalog.##(point, lseg)
  owner to postgres;

create operator pg_catalog.## (procedure = close_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.##(point, box)
is 'closest point to A on B';

alter operator pg_catalog.##(point, box)
  owner to postgres;

create operator pg_catalog.## (procedure = close_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.##(lseg, line)
is 'closest point to A on B';

alter operator pg_catalog.##(lseg, line)
  owner to postgres;

create operator pg_catalog.## (procedure = close_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.##(lseg, box)
is 'closest point to A on B';

alter operator pg_catalog.##(lseg, box)
  owner to postgres;

create operator pg_catalog.## (procedure = close_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.##(line, box)
is 'closest point to A on B';

alter operator pg_catalog.##(line, box)
  owner to postgres;

create operator pg_catalog.## (procedure = close_ls, leftarg = line, rightarg = lseg);

comment on operator pg_catalog.##(line, lseg)
is 'closest point to A on B';

alter operator pg_catalog.##(line, lseg)
  owner to postgres;

create operator pg_catalog.## (procedure = close_lseg, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.##(lseg, lseg)
is 'closest point to A on B';

alter operator pg_catalog.##(lseg, lseg)
  owner to postgres;

create operator pg_catalog.* (procedure = interval_mul, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog.*(interval, double precision)
is 'multiply';

alter operator pg_catalog.*(interval, double precision)
  owner to postgres;

create operator pg_catalog.* (procedure = mul_d_interval, leftarg = double precision, rightarg = interval);

comment on operator pg_catalog.*(double precision, interval)
is 'multiply';

alter operator pg_catalog.*(double precision, interval)
  owner to postgres;

create operator pg_catalog./ (procedure = interval_div, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog./(interval, double precision)
is 'divide';

alter operator pg_catalog./(interval, double precision)
  owner to postgres;

create operator pg_catalog.<> (procedure = lseg_ne, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<>(lseg, lseg)
is 'not equal';

alter operator pg_catalog.<>(lseg, lseg)
  owner to postgres;

create operator pg_catalog.< (procedure = lseg_lt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<(lseg, lseg)
is 'less than by length';

alter operator pg_catalog.<(lseg, lseg)
  owner to postgres;

create operator pg_catalog.<= (procedure = lseg_le, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<=(lseg, lseg)
is 'less than or equal by length';

alter operator pg_catalog.<=(lseg, lseg)
  owner to postgres;

create operator pg_catalog.> (procedure = lseg_gt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.>(lseg, lseg)
is 'greater than by length';

alter operator pg_catalog.>(lseg, lseg)
  owner to postgres;

create operator pg_catalog.>= (procedure = lseg_ge, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.>=(lseg, lseg)
is 'greater than or equal by length';

alter operator pg_catalog.>=(lseg, lseg)
  owner to postgres;

create operator pg_catalog.@-@ (procedure = lseg_length, rightarg = lseg);

comment on operator pg_catalog.@-@(none, lseg)
is 'distance between endpoints';

alter operator pg_catalog.@-@(none, lseg)
  owner to postgres;

create operator pg_catalog.?# (procedure = line_intersect, leftarg = line, rightarg = line);

comment on operator pg_catalog.?#(line, line)
is 'intersect';

alter operator pg_catalog.?#(line, line)
  owner to postgres;

create operator pg_catalog.?|| (procedure = line_parallel, leftarg = line, rightarg = line);

comment on operator pg_catalog.?||(line, line)
is 'parallel';

alter operator pg_catalog.?||(line, line)
  owner to postgres;

create operator pg_catalog.?-| (procedure = line_perp, leftarg = line, rightarg = line);

comment on operator pg_catalog.?-|(line, line)
is 'perpendicular';

alter operator pg_catalog.?-|(line, line)
  owner to postgres;

create operator pg_catalog.?- (procedure = line_horizontal, rightarg = line);

comment on operator pg_catalog.?-(none, line)
is 'horizontal';

alter operator pg_catalog.?-(none, line)
  owner to postgres;

create operator pg_catalog.?| (procedure = line_vertical, rightarg = line);

comment on operator pg_catalog.?|(none, line)
is 'vertical';

alter operator pg_catalog.?|(none, line)
  owner to postgres;

create operator pg_catalog.= (procedure = line_eq, leftarg = line, rightarg = line);

comment on operator pg_catalog.=(line, line)
is 'equal';

alter operator pg_catalog.=(line, line)
  owner to postgres;

create operator pg_catalog.# (procedure = line_interpt, leftarg = line, rightarg = line);

comment on operator pg_catalog.#(line, line)
is 'intersection point';

alter operator pg_catalog.#(line, line)
  owner to postgres;

create operator pg_catalog.~~* (procedure = nameiclike, leftarg = name, rightarg = text);

comment on operator pg_catalog.~~*(name, text)
is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(name, text)
  owner to postgres;

create operator pg_catalog.!~~* (procedure = nameicnlike, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~~*(name, text)
is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(name, text)
  owner to postgres;

create operator pg_catalog.~~* (procedure = texticlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.~~*(text, text)
is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(text, text)
  owner to postgres;

create operator pg_catalog.!~~* (procedure = texticnlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~~*(text, text)
is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(text, text)
  owner to postgres;

create operator pg_catalog.~~* (procedure = bpchariclike, leftarg = char, rightarg = text);

comment on operator pg_catalog.~~*(char, text)
is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(char, text)
  owner to postgres;

create operator pg_catalog.!~~* (procedure = bpcharicnlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~~*(char, text)
is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(char, text)
  owner to postgres;

create operator pg_catalog.<= (procedure = boolle, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<=(boolean, boolean)
is 'less than or equal';

alter operator pg_catalog.<=(boolean, boolean)
  owner to postgres;

create operator pg_catalog.>= (procedure = boolge, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.>=(boolean, boolean)
is 'greater than or equal';

alter operator pg_catalog.>=(boolean, boolean)
  owner to postgres;

create operator pg_catalog.- (procedure = numeric_uminus, rightarg = numeric);

comment on operator pg_catalog.-(none, numeric)
is 'negate';

alter operator pg_catalog.-(none, numeric)
  owner to postgres;

create operator pg_catalog.= (procedure = numeric_eq, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.=(numeric, numeric)
is 'equal';

alter operator pg_catalog.=(numeric, numeric)
  owner to postgres;

create operator pg_catalog.<> (procedure = numeric_ne, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<>(numeric, numeric)
is 'not equal';

alter operator pg_catalog.<>(numeric, numeric)
  owner to postgres;

create operator pg_catalog.< (procedure = numeric_lt, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<(numeric, numeric)
is 'less than';

alter operator pg_catalog.<(numeric, numeric)
  owner to postgres;

create operator pg_catalog.<= (procedure = numeric_le, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<=(numeric, numeric)
is 'less than or equal';

alter operator pg_catalog.<=(numeric, numeric)
  owner to postgres;

create operator pg_catalog.> (procedure = numeric_gt, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.>(numeric, numeric)
is 'greater than';

alter operator pg_catalog.>(numeric, numeric)
  owner to postgres;

create operator pg_catalog.>= (procedure = numeric_ge, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.>=(numeric, numeric)
is 'greater than or equal';

alter operator pg_catalog.>=(numeric, numeric)
  owner to postgres;

create operator pg_catalog.+ (procedure = numeric_add, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.+(numeric, numeric)
is 'add';

alter operator pg_catalog.+(numeric, numeric)
  owner to postgres;

create operator pg_catalog.- (procedure = numeric_sub, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.-(numeric, numeric)
is 'subtract';

alter operator pg_catalog.-(numeric, numeric)
  owner to postgres;

create operator pg_catalog.* (procedure = numeric_mul, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.*(numeric, numeric)
is 'multiply';

alter operator pg_catalog.*(numeric, numeric)
  owner to postgres;

create operator pg_catalog./ (procedure = numeric_div, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog./(numeric, numeric)
is 'divide';

alter operator pg_catalog./(numeric, numeric)
  owner to postgres;

create operator pg_catalog.% (procedure = numeric_mod, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.%(numeric, numeric)
is 'modulus';

alter operator pg_catalog.%(numeric, numeric)
  owner to postgres;

create operator pg_catalog.@ (procedure = numeric_abs, rightarg = numeric);

comment on operator pg_catalog.@(none, numeric)
is 'absolute value';

alter operator pg_catalog.@(none, numeric)
  owner to postgres;

create operator pg_catalog.= (procedure = biteq, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.=(bit, bit)
is 'equal';

alter operator pg_catalog.=(bit, bit)
  owner to postgres;

create operator pg_catalog.<> (procedure = bitne, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<>(bit, bit)
is 'not equal';

alter operator pg_catalog.<>(bit, bit)
  owner to postgres;

create operator pg_catalog.< (procedure = bitlt, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<(bit, bit)
is 'less than';

alter operator pg_catalog.<(bit, bit)
  owner to postgres;

create operator pg_catalog.> (procedure = bitgt, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.>(bit, bit)
is 'greater than';

alter operator pg_catalog.>(bit, bit)
  owner to postgres;

create operator pg_catalog.<= (procedure = bitle, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<=(bit, bit)
is 'less than or equal';

alter operator pg_catalog.<=(bit, bit)
  owner to postgres;

create operator pg_catalog.>= (procedure = bitge, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.>=(bit, bit)
is 'greater than or equal';

alter operator pg_catalog.>=(bit, bit)
  owner to postgres;

create operator pg_catalog.& (procedure = bitand, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.&(bit, bit)
is 'bitwise and';

alter operator pg_catalog.&(bit, bit)
  owner to postgres;

create operator pg_catalog.| (procedure = bitor, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.|(bit, bit)
is 'bitwise or';

alter operator pg_catalog.|(bit, bit)
  owner to postgres;

create operator pg_catalog.# (procedure = bitxor, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.#(bit, bit)
is 'bitwise exclusive or';

alter operator pg_catalog.#(bit, bit)
  owner to postgres;

create operator pg_catalog.~ (procedure = bitnot, rightarg = bit);

comment on operator pg_catalog.~(none, bit)
is 'bitwise not';

alter operator pg_catalog.~(none, bit)
  owner to postgres;

create operator pg_catalog.<< (procedure = bitshiftleft, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.<<(bit, integer)
is 'bitwise shift left';

alter operator pg_catalog.<<(bit, integer)
  owner to postgres;

create operator pg_catalog.>> (procedure = bitshiftright, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.>>(bit, integer)
is 'bitwise shift right';

alter operator pg_catalog.>>(bit, integer)
  owner to postgres;

create operator pg_catalog.|| (procedure = bitcat, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.||(bit varying, bit varying)
is 'concatenate';

alter operator pg_catalog.||(bit varying, bit varying)
  owner to postgres;

create operator pg_catalog.+ (procedure = time_pl_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.+(time, interval)
is 'add';

alter operator pg_catalog.+(time, interval)
  owner to postgres;

create operator pg_catalog.- (procedure = time_mi_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.-(time, interval)
is 'subtract';

alter operator pg_catalog.-(time, interval)
  owner to postgres;

create operator pg_catalog.+ (procedure = timetz_pl_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.+(time with time zone, interval)
is 'add';

alter operator pg_catalog.+(time with time zone, interval)
  owner to postgres;

create operator pg_catalog.- (procedure = timetz_mi_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.-(time with time zone, interval)
is 'subtract';

alter operator pg_catalog.-(time with time zone, interval)
  owner to postgres;

create operator pg_catalog.= (procedure = varbiteq, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.=(bit varying, bit varying)
is 'equal';

alter operator pg_catalog.=(bit varying, bit varying)
  owner to postgres;

create operator pg_catalog.<> (procedure = varbitne, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<>(bit varying, bit varying)
is 'not equal';

alter operator pg_catalog.<>(bit varying, bit varying)
  owner to postgres;

create operator pg_catalog.< (procedure = varbitlt, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<(bit varying, bit varying)
is 'less than';

alter operator pg_catalog.<(bit varying, bit varying)
  owner to postgres;

create operator pg_catalog.> (procedure = varbitgt, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.>(bit varying, bit varying)
is 'greater than';

alter operator pg_catalog.>(bit varying, bit varying)
  owner to postgres;

create operator pg_catalog.<= (procedure = varbitle, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<=(bit varying, bit varying)
is 'less than or equal';

alter operator pg_catalog.<=(bit varying, bit varying)
  owner to postgres;

create operator pg_catalog.>= (procedure = varbitge, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.>=(bit varying, bit varying)
is 'greater than or equal';

alter operator pg_catalog.>=(bit varying, bit varying)
  owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_time, leftarg = interval, rightarg = time);

comment on operator pg_catalog.+(interval, time)
is 'add';

alter operator pg_catalog.+(interval, time)
  owner to postgres;

create operator pg_catalog.= (procedure = int28eq, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.=(smallint, bigint)
is 'equal';

alter operator pg_catalog.=(smallint, bigint)
  owner to postgres;

create operator pg_catalog.<> (procedure = int28ne, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<>(smallint, bigint)
is 'not equal';

alter operator pg_catalog.<>(smallint, bigint)
  owner to postgres;

create operator pg_catalog.< (procedure = int28lt, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<(smallint, bigint)
is 'less than';

alter operator pg_catalog.<(smallint, bigint)
  owner to postgres;

create operator pg_catalog.> (procedure = int28gt, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.>(smallint, bigint)
is 'greater than';

alter operator pg_catalog.>(smallint, bigint)
  owner to postgres;

create operator pg_catalog.<= (procedure = int28le, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<=(smallint, bigint)
is 'less than or equal';

alter operator pg_catalog.<=(smallint, bigint)
  owner to postgres;

create operator pg_catalog.>= (procedure = int28ge, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.>=(smallint, bigint)
is 'greater than or equal';

alter operator pg_catalog.>=(smallint, bigint)
  owner to postgres;

create operator pg_catalog.= (procedure = int82eq, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.=(bigint, smallint)
is 'equal';

alter operator pg_catalog.=(bigint, smallint)
  owner to postgres;

create operator pg_catalog.<> (procedure = int82ne, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<>(bigint, smallint)
is 'not equal';

alter operator pg_catalog.<>(bigint, smallint)
  owner to postgres;

create operator pg_catalog.< (procedure = int82lt, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<(bigint, smallint)
is 'less than';

alter operator pg_catalog.<(bigint, smallint)
  owner to postgres;

create operator pg_catalog.> (procedure = int82gt, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.>(bigint, smallint)
is 'greater than';

alter operator pg_catalog.>(bigint, smallint)
  owner to postgres;

create operator pg_catalog.<= (procedure = int82le, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<=(bigint, smallint)
is 'less than or equal';

alter operator pg_catalog.<=(bigint, smallint)
  owner to postgres;

create operator pg_catalog.>= (procedure = int82ge, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.>=(bigint, smallint)
is 'greater than or equal';

alter operator pg_catalog.>=(bigint, smallint)
  owner to postgres;

create operator pg_catalog.& (procedure = int2and, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.&(smallint, smallint)
is 'bitwise and';

alter operator pg_catalog.&(smallint, smallint)
  owner to postgres;

create operator pg_catalog.| (procedure = int2or, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.|(smallint, smallint)
is 'bitwise or';

alter operator pg_catalog.|(smallint, smallint)
  owner to postgres;

create operator pg_catalog.# (procedure = int2xor, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.#(smallint, smallint)
is 'bitwise exclusive or';

alter operator pg_catalog.#(smallint, smallint)
  owner to postgres;

create operator pg_catalog.~ (procedure = int2not, rightarg = smallint);

comment on operator pg_catalog.~(none, smallint)
is 'bitwise not';

alter operator pg_catalog.~(none, smallint)
  owner to postgres;

create operator pg_catalog.<< (procedure = int2shl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<<(smallint, integer)
is 'bitwise shift left';

alter operator pg_catalog.<<(smallint, integer)
  owner to postgres;

create operator pg_catalog.>> (procedure = int2shr, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>>(smallint, integer)
is 'bitwise shift right';

alter operator pg_catalog.>>(smallint, integer)
  owner to postgres;

create operator pg_catalog.& (procedure = int4and, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.&(integer, integer)
is 'bitwise and';

alter operator pg_catalog.&(integer, integer)
  owner to postgres;

create operator pg_catalog.| (procedure = int4or, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.|(integer, integer)
is 'bitwise or';

alter operator pg_catalog.|(integer, integer)
  owner to postgres;

create operator pg_catalog.# (procedure = int4xor, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.#(integer, integer)
is 'bitwise exclusive or';

alter operator pg_catalog.#(integer, integer)
  owner to postgres;

create operator pg_catalog.~ (procedure = int4not, rightarg = integer);

comment on operator pg_catalog.~(none, integer)
is 'bitwise not';

alter operator pg_catalog.~(none, integer)
  owner to postgres;

create operator pg_catalog.<< (procedure = int4shl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<<(integer, integer)
is 'bitwise shift left';

alter operator pg_catalog.<<(integer, integer)
  owner to postgres;

create operator pg_catalog.>> (procedure = int4shr, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>>(integer, integer)
is 'bitwise shift right';

alter operator pg_catalog.>>(integer, integer)
  owner to postgres;

create operator pg_catalog.& (procedure = int8and, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.&(bigint, bigint)
is 'bitwise and';

alter operator pg_catalog.&(bigint, bigint)
  owner to postgres;

create operator pg_catalog.| (procedure = int8or, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.|(bigint, bigint)
is 'bitwise or';

alter operator pg_catalog.|(bigint, bigint)
  owner to postgres;

create operator pg_catalog.# (procedure = int8xor, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.#(bigint, bigint)
is 'bitwise exclusive or';

alter operator pg_catalog.#(bigint, bigint)
  owner to postgres;

create operator pg_catalog.~ (procedure = int8not, rightarg = bigint);

comment on operator pg_catalog.~(none, bigint)
is 'bitwise not';

alter operator pg_catalog.~(none, bigint)
  owner to postgres;

create operator pg_catalog.<< (procedure = int8shl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<<(bigint, integer)
is 'bitwise shift left';

alter operator pg_catalog.<<(bigint, integer)
  owner to postgres;

create operator pg_catalog.>> (procedure = int8shr, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>>(bigint, integer)
is 'bitwise shift right';

alter operator pg_catalog.>>(bigint, integer)
  owner to postgres;

create operator pg_catalog.+ (procedure = int8up, rightarg = bigint);

comment on operator pg_catalog.+(none, bigint)
is 'unary plus';

alter operator pg_catalog.+(none, bigint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int2up, rightarg = smallint);

comment on operator pg_catalog.+(none, smallint)
is 'unary plus';

alter operator pg_catalog.+(none, smallint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int4up, rightarg = integer);

comment on operator pg_catalog.+(none, integer)
is 'unary plus';

alter operator pg_catalog.+(none, integer)
  owner to postgres;

create operator pg_catalog.+ (procedure = float4up, rightarg = real);

comment on operator pg_catalog.+(none, real)
is 'unary plus';

alter operator pg_catalog.+(none, real)
  owner to postgres;

create operator pg_catalog.+ (procedure = float8up, rightarg = double precision);

comment on operator pg_catalog.+(none, double precision)
is 'unary plus';

alter operator pg_catalog.+(none, double precision)
  owner to postgres;

create operator pg_catalog.+ (procedure = numeric_uplus, rightarg = numeric);

comment on operator pg_catalog.+(none, numeric)
is 'unary plus';

alter operator pg_catalog.+(none, numeric)
  owner to postgres;

create operator pg_catalog.= (procedure = byteaeq, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.=(bytea, bytea)
is 'equal';

alter operator pg_catalog.=(bytea, bytea)
  owner to postgres;

create operator pg_catalog.<> (procedure = byteane, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<>(bytea, bytea)
is 'not equal';

alter operator pg_catalog.<>(bytea, bytea)
  owner to postgres;

create operator pg_catalog.< (procedure = bytealt, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<(bytea, bytea)
is 'less than';

alter operator pg_catalog.<(bytea, bytea)
  owner to postgres;

create operator pg_catalog.<= (procedure = byteale, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<=(bytea, bytea)
is 'less than or equal';

alter operator pg_catalog.<=(bytea, bytea)
  owner to postgres;

create operator pg_catalog.> (procedure = byteagt, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.>(bytea, bytea)
is 'greater than';

alter operator pg_catalog.>(bytea, bytea)
  owner to postgres;

create operator pg_catalog.>= (procedure = byteage, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.>=(bytea, bytea)
is 'greater than or equal';

alter operator pg_catalog.>=(bytea, bytea)
  owner to postgres;

create operator pg_catalog.~~ (procedure = bytealike, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.~~(bytea, bytea)
is 'matches LIKE expression';

alter operator pg_catalog.~~(bytea, bytea)
  owner to postgres;

create operator pg_catalog.!~~ (procedure = byteanlike, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.!~~(bytea, bytea)
is 'does not match LIKE expression';

alter operator pg_catalog.!~~(bytea, bytea)
  owner to postgres;

create operator pg_catalog.|| (procedure = byteacat, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.||(bytea, bytea)
is 'concatenate';

alter operator pg_catalog.||(bytea, bytea)
  owner to postgres;

create operator pg_catalog.= (procedure = timestamp_eq, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.=(timestamp, timestamp)
is 'equal';

alter operator pg_catalog.=(timestamp, timestamp)
  owner to postgres;

create operator pg_catalog.<> (procedure = timestamp_ne, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<>(timestamp, timestamp)
is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp)
  owner to postgres;

create operator pg_catalog.< (procedure = timestamp_lt, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<(timestamp, timestamp)
is 'less than';

alter operator pg_catalog.<(timestamp, timestamp)
  owner to postgres;

create operator pg_catalog.<= (procedure = timestamp_le, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<=(timestamp, timestamp)
is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp)
  owner to postgres;

create operator pg_catalog.> (procedure = timestamp_gt, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.>(timestamp, timestamp)
is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp)
  owner to postgres;

create operator pg_catalog.>= (procedure = timestamp_ge, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.>=(timestamp, timestamp)
is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp)
  owner to postgres;

create operator pg_catalog.+ (procedure = timestamp_pl_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.+(timestamp, interval)
is 'add';

alter operator pg_catalog.+(timestamp, interval)
  owner to postgres;

create operator pg_catalog.- (procedure = timestamp_mi, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.-(timestamp, timestamp)
is 'subtract';

alter operator pg_catalog.-(timestamp, timestamp)
  owner to postgres;

create operator pg_catalog.- (procedure = timestamp_mi_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.-(timestamp, interval)
is 'subtract';

alter operator pg_catalog.-(timestamp, interval)
  owner to postgres;

create operator pg_catalog.~<~ (procedure = text_pattern_lt, leftarg = text, rightarg = text);

comment on operator pg_catalog.~<~(text, text)
is 'less than';

alter operator pg_catalog.~<~(text, text)
  owner to postgres;

create operator pg_catalog.~<=~ (procedure = text_pattern_le, leftarg = text, rightarg = text);

comment on operator pg_catalog.~<=~(text, text)
is 'less than or equal';

alter operator pg_catalog.~<=~(text, text)
  owner to postgres;

create operator pg_catalog.~>=~ (procedure = text_pattern_ge, leftarg = text, rightarg = text);

comment on operator pg_catalog.~>=~(text, text)
is 'greater than or equal';

alter operator pg_catalog.~>=~(text, text)
  owner to postgres;

create operator pg_catalog.~>~ (procedure = text_pattern_gt, leftarg = text, rightarg = text);

comment on operator pg_catalog.~>~(text, text)
is 'greater than';

alter operator pg_catalog.~>~(text, text)
  owner to postgres;

create operator pg_catalog.~<~ (procedure = bpchar_pattern_lt, leftarg = char, rightarg = char);

comment on operator pg_catalog.~<~(char, char)
is 'less than';

alter operator pg_catalog.~<~(char, char)
  owner to postgres;

create operator pg_catalog.~<=~ (procedure = bpchar_pattern_le, leftarg = char, rightarg = char);

comment on operator pg_catalog.~<=~(char, char)
is 'less than or equal';

alter operator pg_catalog.~<=~(char, char)
  owner to postgres;

create operator pg_catalog.~>=~ (procedure = bpchar_pattern_ge, leftarg = char, rightarg = char);

comment on operator pg_catalog.~>=~(char, char)
is 'greater than or equal';

alter operator pg_catalog.~>=~(char, char)
  owner to postgres;

create operator pg_catalog.~>~ (procedure = bpchar_pattern_gt, leftarg = char, rightarg = char);

comment on operator pg_catalog.~>~(char, char)
is 'greater than';

alter operator pg_catalog.~>~(char, char)
  owner to postgres;

create operator pg_catalog.< (procedure = date_lt_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<(date, timestamp)
is 'less than';

alter operator pg_catalog.<(date, timestamp)
  owner to postgres;

create operator pg_catalog.<= (procedure = date_le_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<=(date, timestamp)
is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp)
  owner to postgres;

create operator pg_catalog.= (procedure = date_eq_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.=(date, timestamp)
is 'equal';

alter operator pg_catalog.=(date, timestamp)
  owner to postgres;

create operator pg_catalog.>= (procedure = date_ge_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.>=(date, timestamp)
is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp)
  owner to postgres;

create operator pg_catalog.> (procedure = date_gt_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.>(date, timestamp)
is 'greater than';

alter operator pg_catalog.>(date, timestamp)
  owner to postgres;

create operator pg_catalog.<> (procedure = date_ne_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<>(date, timestamp)
is 'not equal';

alter operator pg_catalog.<>(date, timestamp)
  owner to postgres;

create operator pg_catalog.< (procedure = date_lt_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(date, timestamp with time zone)
is 'less than';

alter operator pg_catalog.<(date, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.<= (procedure = date_le_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(date, timestamp with time zone)
is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.= (procedure = date_eq_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(date, timestamp with time zone)
is 'equal';

alter operator pg_catalog.=(date, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.>= (procedure = date_ge_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(date, timestamp with time zone)
is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.> (procedure = date_gt_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(date, timestamp with time zone)
is 'greater than';

alter operator pg_catalog.>(date, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.<> (procedure = date_ne_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(date, timestamp with time zone)
is 'not equal';

alter operator pg_catalog.<>(date, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.< (procedure = timestamp_lt_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<(timestamp, date)
is 'less than';

alter operator pg_catalog.<(timestamp, date)
  owner to postgres;

create operator pg_catalog.<= (procedure = timestamp_le_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<=(timestamp, date)
is 'less than or equal';

alter operator pg_catalog.<=(timestamp, date)
  owner to postgres;

create operator pg_catalog.= (procedure = timestamp_eq_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.=(timestamp, date)
is 'equal';

alter operator pg_catalog.=(timestamp, date)
  owner to postgres;

create operator pg_catalog.>= (procedure = timestamp_ge_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.>=(timestamp, date)
is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, date)
  owner to postgres;

create operator pg_catalog.> (procedure = timestamp_gt_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.>(timestamp, date)
is 'greater than';

alter operator pg_catalog.>(timestamp, date)
  owner to postgres;

create operator pg_catalog.<> (procedure = timestamp_ne_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<>(timestamp, date)
is 'not equal';

alter operator pg_catalog.<>(timestamp, date)
  owner to postgres;

create operator pg_catalog.< (procedure = timestamptz_lt_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<(timestamp with time zone, date)
is 'less than';

alter operator pg_catalog.<(timestamp with time zone, date)
  owner to postgres;

create operator pg_catalog.<= (procedure = timestamptz_le_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<=(timestamp with time zone, date)
is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, date)
  owner to postgres;

create operator pg_catalog.= (procedure = timestamptz_eq_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.=(timestamp with time zone, date)
is 'equal';

alter operator pg_catalog.=(timestamp with time zone, date)
  owner to postgres;

create operator pg_catalog.>= (procedure = timestamptz_ge_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.>=(timestamp with time zone, date)
is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, date)
  owner to postgres;

create operator pg_catalog.> (procedure = timestamptz_gt_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.>(timestamp with time zone, date)
is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, date)
  owner to postgres;

create operator pg_catalog.<> (procedure = timestamptz_ne_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<>(timestamp with time zone, date)
is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, date)
  owner to postgres;

create operator pg_catalog.< (procedure = timestamp_lt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(timestamp, timestamp with time zone)
is 'less than';

alter operator pg_catalog.<(timestamp, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.<= (procedure = timestamp_le_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(timestamp, timestamp with time zone)
is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.= (procedure = timestamp_eq_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(timestamp, timestamp with time zone)
is 'equal';

alter operator pg_catalog.=(timestamp, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.>= (procedure = timestamp_ge_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(timestamp, timestamp with time zone)
is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.> (procedure = timestamp_gt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(timestamp, timestamp with time zone)
is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.<> (procedure = timestamp_ne_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(timestamp, timestamp with time zone)
is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.< (procedure = timestamptz_lt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<(timestamp with time zone, timestamp)
is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp)
  owner to postgres;

create operator pg_catalog.<= (procedure = timestamptz_le_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp)
is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp)
  owner to postgres;

create operator pg_catalog.= (procedure = timestamptz_eq_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.=(timestamp with time zone, timestamp)
is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp)
  owner to postgres;

create operator pg_catalog.>= (procedure = timestamptz_ge_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp)
is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp)
  owner to postgres;

create operator pg_catalog.> (procedure = timestamptz_gt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.>(timestamp with time zone, timestamp)
is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp)
  owner to postgres;

create operator pg_catalog.<> (procedure = timestamptz_ne_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp)
is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp)
  owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_date, leftarg = interval, rightarg = date);

comment on operator pg_catalog.+(interval, date)
is 'add';

alter operator pg_catalog.+(interval, date)
  owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_timetz, leftarg = interval, rightarg = time with time zone);

comment on operator pg_catalog.+(interval, time with time zone)
is 'add';

alter operator pg_catalog.+(interval, time with time zone)
  owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_timestamp, leftarg = interval, rightarg = timestamp);

comment on operator pg_catalog.+(interval, timestamp)
is 'add';

alter operator pg_catalog.+(interval, timestamp)
  owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_timestamptz, leftarg = interval, rightarg = timestamp with time zone);

comment on operator pg_catalog.+(interval, timestamp with time zone)
is 'add';

alter operator pg_catalog.+(interval, timestamp with time zone)
  owner to postgres;

create operator pg_catalog.+ (procedure = integer_pl_date, leftarg = integer, rightarg = date);

comment on operator pg_catalog.+(integer, date)
is 'add';

alter operator pg_catalog.+(integer, date)
  owner to postgres;

create operator pg_catalog.<<| (procedure = box_below, leftarg = box, rightarg = box);

comment on operator pg_catalog.<<|(box, box)
is 'is below';

alter operator pg_catalog.<<|(box, box)
  owner to postgres;

create operator pg_catalog.&<| (procedure = box_overbelow, leftarg = box, rightarg = box);

comment on operator pg_catalog.&<|(box, box)
is 'overlaps or is below';

alter operator pg_catalog.&<|(box, box)
  owner to postgres;

create operator pg_catalog.|&> (procedure = box_overabove, leftarg = box, rightarg = box);

comment on operator pg_catalog.|&>(box, box)
is 'overlaps or is above';

alter operator pg_catalog.|&>(box, box)
  owner to postgres;

create operator pg_catalog.|>> (procedure = box_above, leftarg = box, rightarg = box);

comment on operator pg_catalog.|>>(box, box)
is 'is above';

alter operator pg_catalog.|>>(box, box)
  owner to postgres;

create operator pg_catalog.<<| (procedure = poly_below, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<<|(polygon, polygon)
is 'is below';

alter operator pg_catalog.<<|(polygon, polygon)
  owner to postgres;

create operator pg_catalog.&<| (procedure = poly_overbelow, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&<|(polygon, polygon)
is 'overlaps or is below';

alter operator pg_catalog.&<|(polygon, polygon)
  owner to postgres;

create operator pg_catalog.|&> (procedure = poly_overabove, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.|&>(polygon, polygon)
is 'overlaps or is above';

alter operator pg_catalog.|&>(polygon, polygon)
  owner to postgres;

create operator pg_catalog.|>> (procedure = poly_above, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.|>>(polygon, polygon)
is 'is above';

alter operator pg_catalog.|>>(polygon, polygon)
  owner to postgres;

create operator pg_catalog.&<| (procedure = circle_overbelow, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&<|(circle, circle)
is 'overlaps or is below';

alter operator pg_catalog.&<|(circle, circle)
  owner to postgres;

create operator pg_catalog.|&> (procedure = circle_overabove, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.|&>(circle, circle)
is 'overlaps or is above';

alter operator pg_catalog.|&>(circle, circle)
  owner to postgres;

create operator pg_catalog.~ (procedure = inetnot, rightarg = inet);

comment on operator pg_catalog.~(none, inet)
is 'bitwise not';

alter operator pg_catalog.~(none, inet)
  owner to postgres;

create operator pg_catalog.& (procedure = inetand, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&(inet, inet)
is 'bitwise and';

alter operator pg_catalog.&(inet, inet)
  owner to postgres;

create operator pg_catalog.| (procedure = inetor, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.|(inet, inet)
is 'bitwise or';

alter operator pg_catalog.|(inet, inet)
  owner to postgres;

create operator pg_catalog.+ (procedure = inetpl, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.+(inet, bigint)
is 'add';

alter operator pg_catalog.+(inet, bigint)
  owner to postgres;

create operator pg_catalog.+ (procedure = int8pl_inet, leftarg = bigint, rightarg = inet);

comment on operator pg_catalog.+(bigint, inet)
is 'add';

alter operator pg_catalog.+(bigint, inet)
  owner to postgres;

create operator pg_catalog.- (procedure = inetmi_int8, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.-(inet, bigint)
is 'subtract';

alter operator pg_catalog.-(inet, bigint)
  owner to postgres;

create operator pg_catalog.- (procedure = inetmi, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.-(inet, inet)
is 'subtract';

alter operator pg_catalog.-(inet, inet)
  owner to postgres;

create operator pg_catalog.&& (procedure = arrayoverlap, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.&&(anyarray, anyarray)
is 'overlaps';

alter operator pg_catalog.&&(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.@> (procedure = arraycontains, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.@>(anyarray, anyarray)
is 'contains';

alter operator pg_catalog.@>(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.<@ (procedure = arraycontained, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<@(anyarray, anyarray)
is 'is contained by';

alter operator pg_catalog.<@(anyarray, anyarray)
  owner to postgres;

create operator pg_catalog.|| (procedure = textanycat, leftarg = text, rightarg = anynonarray);

comment on operator pg_catalog.||(text, anynonarray)
is 'concatenate';

alter operator pg_catalog.||(text, anynonarray)
  owner to postgres;

create operator pg_catalog.|| (procedure = anytextcat, leftarg = anynonarray, rightarg = text);

comment on operator pg_catalog.||(anynonarray, text)
is 'concatenate';

alter operator pg_catalog.||(anynonarray, text)
  owner to postgres;

create operator pg_catalog.< (procedure = tidlt, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<(tid, tid)
is 'less than';

alter operator pg_catalog.<(tid, tid)
  owner to postgres;

create operator pg_catalog.> (procedure = tidgt, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.>(tid, tid)
is 'greater than';

alter operator pg_catalog.>(tid, tid)
  owner to postgres;

create operator pg_catalog.<= (procedure = tidle, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<=(tid, tid)
is 'less than or equal';

alter operator pg_catalog.<=(tid, tid)
  owner to postgres;

create operator pg_catalog.>= (procedure = tidge, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.>=(tid, tid)
is 'greater than or equal';

alter operator pg_catalog.>=(tid, tid)
  owner to postgres;

create operator pg_catalog.@ (procedure = poly_contained, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.@(polygon, polygon)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(polygon, polygon)
  owner to postgres;

create operator pg_catalog.~ (procedure = poly_contain, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.~(polygon, polygon)
is 'deprecated, use @> instead';

alter operator pg_catalog.~(polygon, polygon)
  owner to postgres;

create operator pg_catalog.@ (procedure = box_contained, leftarg = box, rightarg = box);

comment on operator pg_catalog.@(box, box)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(box, box)
  owner to postgres;

create operator pg_catalog.~ (procedure = box_contain, leftarg = box, rightarg = box);

comment on operator pg_catalog.~(box, box)
is 'deprecated, use @> instead';

alter operator pg_catalog.~(box, box)
  owner to postgres;

create operator pg_catalog.@ (procedure = circle_contained, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.@(circle, circle)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(circle, circle)
  owner to postgres;

create operator pg_catalog.~ (procedure = circle_contain, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.~(circle, circle)
is 'deprecated, use @> instead';

alter operator pg_catalog.~(circle, circle)
  owner to postgres;

create operator pg_catalog.@ (procedure = on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.@(point, box)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, box)
  owner to postgres;

create operator pg_catalog.@ (procedure = on_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.@(point, path)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, path)
  owner to postgres;

create operator pg_catalog.~ (procedure = path_contain_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.~(path, point)
is 'deprecated, use @> instead';

alter operator pg_catalog.~(path, point)
  owner to postgres;

create operator pg_catalog.@ (procedure = pt_contained_poly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.@(point, polygon)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, polygon)
  owner to postgres;

create operator pg_catalog.~ (procedure = poly_contain_pt, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.~(polygon, point)
is 'deprecated, use @> instead';

alter operator pg_catalog.~(polygon, point)
  owner to postgres;

create operator pg_catalog.@ (procedure = pt_contained_circle, leftarg = point, rightarg = circle);

comment on operator pg_catalog.@(point, circle)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, circle)
  owner to postgres;

create operator pg_catalog.~ (procedure = circle_contain_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.~(circle, point)
is 'deprecated, use @> instead';

alter operator pg_catalog.~(circle, point)
  owner to postgres;

create operator pg_catalog.@ (procedure = on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.@(point, line)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, line)
  owner to postgres;

create operator pg_catalog.@ (procedure = on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.@(point, lseg)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, lseg)
  owner to postgres;

create operator pg_catalog.@ (procedure = on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.@(lseg, line)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(lseg, line)
  owner to postgres;

create operator pg_catalog.@ (procedure = on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.@(lseg, box)
is 'deprecated, use <@ instead';

alter operator pg_catalog.@(lseg, box)
  owner to postgres;

create operator pg_catalog.~ (procedure = aclcontains, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.~(aclitem [], aclitem)
is 'deprecated, use @> instead';

alter operator pg_catalog.~(aclitem [], aclitem)
  owner to postgres;

create operator pg_catalog.= (procedure = uuid_eq, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.=(uuid, uuid)
is 'equal';

alter operator pg_catalog.=(uuid, uuid)
  owner to postgres;

create operator pg_catalog.<> (procedure = uuid_ne, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<>(uuid, uuid)
is 'not equal';

alter operator pg_catalog.<>(uuid, uuid)
  owner to postgres;

create operator pg_catalog.< (procedure = uuid_lt, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<(uuid, uuid)
is 'less than';

alter operator pg_catalog.<(uuid, uuid)
  owner to postgres;

create operator pg_catalog.> (procedure = uuid_gt, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.>(uuid, uuid)
is 'greater than';

alter operator pg_catalog.>(uuid, uuid)
  owner to postgres;

create operator pg_catalog.<= (procedure = uuid_le, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<=(uuid, uuid)
is 'less than or equal';

alter operator pg_catalog.<=(uuid, uuid)
  owner to postgres;

create operator pg_catalog.>= (procedure = uuid_ge, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.>=(uuid, uuid)
is 'greater than or equal';

alter operator pg_catalog.>=(uuid, uuid)
  owner to postgres;

create operator pg_catalog.= (procedure = record_eq, leftarg = record, rightarg = record);

comment on operator pg_catalog.=(record, record)
is 'equal';

alter operator pg_catalog.=(record, record)
  owner to postgres;

create operator pg_catalog.<> (procedure = record_ne, leftarg = record, rightarg = record);

comment on operator pg_catalog.<>(record, record)
is 'not equal';

alter operator pg_catalog.<>(record, record)
  owner to postgres;

create operator pg_catalog.< (procedure = record_lt, leftarg = record, rightarg = record);

comment on operator pg_catalog.<(record, record)
is 'less than';

alter operator pg_catalog.<(record, record)
  owner to postgres;

create operator pg_catalog.> (procedure = record_gt, leftarg = record, rightarg = record);

comment on operator pg_catalog.>(record, record)
is 'greater than';

alter operator pg_catalog.>(record, record)
  owner to postgres;

create operator pg_catalog.<= (procedure = record_le, leftarg = record, rightarg = record);

comment on operator pg_catalog.<=(record, record)
is 'less than or equal';

alter operator pg_catalog.<=(record, record)
  owner to postgres;

create operator pg_catalog.>= (procedure = record_ge, leftarg = record, rightarg = record);

comment on operator pg_catalog.>=(record, record)
is 'greater than or equal';

alter operator pg_catalog.>=(record, record)
  owner to postgres;

create operator pg_catalog.~ (procedure = macaddr_not, rightarg = macaddr);

comment on operator pg_catalog.~(none, macaddr)
is 'bitwise not';

alter operator pg_catalog.~(none, macaddr)
  owner to postgres;

create operator pg_catalog.& (procedure = macaddr_and, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.&(macaddr, macaddr)
is 'bitwise and';

alter operator pg_catalog.&(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.| (procedure = macaddr_or, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.|(macaddr, macaddr)
is 'bitwise or';

alter operator pg_catalog.|(macaddr, macaddr)
  owner to postgres;

create operator pg_catalog.*= (procedure = record_image_eq, leftarg = record, rightarg = record);

comment on operator pg_catalog.*=(record, record)
is 'identical';

alter operator pg_catalog.*=(record, record)
  owner to postgres;

create operator pg_catalog.*<> (procedure = record_image_ne, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<>(record, record)
is 'not identical';

alter operator pg_catalog.*<>(record, record)
  owner to postgres;

create operator pg_catalog.*< (procedure = record_image_lt, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<(record, record)
is 'less than';

alter operator pg_catalog.*<(record, record)
  owner to postgres;

create operator pg_catalog.*> (procedure = record_image_gt, leftarg = record, rightarg = record);

comment on operator pg_catalog.*>(record, record)
is 'greater than';

alter operator pg_catalog.*>(record, record)
  owner to postgres;

create operator pg_catalog.*<= (procedure = record_image_le, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<=(record, record)
is 'less than or equal';

alter operator pg_catalog.*<=(record, record)
  owner to postgres;

create operator pg_catalog.*>= (procedure = record_image_ge, leftarg = record, rightarg = record);

comment on operator pg_catalog.*>=(record, record)
is 'greater than or equal';

alter operator pg_catalog.*>=(record, record)
  owner to postgres;

create operator pg_catalog.#>> (procedure = jsonb_extract_path_text, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.#>>(jsonb, text [])
is 'get value from jsonb as text with path elements';

alter operator pg_catalog.#>>(jsonb, text [])
  owner to postgres;

create operator pg_catalog.-> (procedure = jsonb_object_field, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->(jsonb, text)
is 'get jsonb object field';

alter operator pg_catalog.->(jsonb, text)
  owner to postgres;

create operator pg_catalog.-> (procedure = jsonb_array_element, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->(jsonb, integer)
is 'get jsonb array element';

alter operator pg_catalog.->(jsonb, integer)
  owner to postgres;

create operator pg_catalog.#> (procedure = jsonb_extract_path, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.#>(jsonb, text [])
is 'get value from jsonb with path elements';

alter operator pg_catalog.#>(jsonb, text [])
  owner to postgres;

create operator pg_catalog.= (procedure = pg_lsn_eq, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.=(pg_lsn, pg_lsn)
is 'equal';

alter operator pg_catalog.=(pg_lsn, pg_lsn)
  owner to postgres;

create operator pg_catalog.<> (procedure = pg_lsn_ne, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<>(pg_lsn, pg_lsn)
is 'not equal';

alter operator pg_catalog.<>(pg_lsn, pg_lsn)
  owner to postgres;

create operator pg_catalog.< (procedure = pg_lsn_lt, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<(pg_lsn, pg_lsn)
is 'less than';

alter operator pg_catalog.<(pg_lsn, pg_lsn)
  owner to postgres;

create operator pg_catalog.> (procedure = pg_lsn_gt, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.>(pg_lsn, pg_lsn)
is 'greater than';

alter operator pg_catalog.>(pg_lsn, pg_lsn)
  owner to postgres;

create operator pg_catalog.<= (procedure = pg_lsn_le, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<=(pg_lsn, pg_lsn)
is 'less than or equal';

alter operator pg_catalog.<=(pg_lsn, pg_lsn)
  owner to postgres;

create operator pg_catalog.>= (procedure = pg_lsn_ge, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.>=(pg_lsn, pg_lsn)
is 'greater than or equal';

alter operator pg_catalog.>=(pg_lsn, pg_lsn)
  owner to postgres;

create operator pg_catalog.- (procedure = pg_lsn_mi, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.-(pg_lsn, pg_lsn)
is 'minus';

alter operator pg_catalog.-(pg_lsn, pg_lsn)
  owner to postgres;

create operator pg_catalog.= (procedure = jsonb_eq, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.=(jsonb, jsonb)
is 'equal';

alter operator pg_catalog.=(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.<> (procedure = jsonb_ne, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<>(jsonb, jsonb)
is 'not equal';

alter operator pg_catalog.<>(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.< (procedure = jsonb_lt, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<(jsonb, jsonb)
is 'less than';

alter operator pg_catalog.<(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.> (procedure = jsonb_gt, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.>(jsonb, jsonb)
is 'greater than';

alter operator pg_catalog.>(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.<= (procedure = jsonb_le, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<=(jsonb, jsonb)
is 'less than or equal';

alter operator pg_catalog.<=(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.>= (procedure = jsonb_ge, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.>=(jsonb, jsonb)
is 'greater than or equal';

alter operator pg_catalog.>=(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.@> (procedure = jsonb_contains, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.@>(jsonb, jsonb)
is 'contains';

alter operator pg_catalog.@>(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.? ( procedure = jsonb_exists, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.? (jsonb, text) is 'key exists';

alter operator pg_catalog.? (jsonb, text) owner to postgres;

create operator pg_catalog.?| (procedure = jsonb_exists_any, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.?|(jsonb, text [])
is 'any key exists';

alter operator pg_catalog.?|(jsonb, text [])
  owner to postgres;

create operator pg_catalog.?& (procedure = jsonb_exists_all, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.?&(jsonb, text [])
is 'all keys exist';

alter operator pg_catalog.?&(jsonb, text [])
  owner to postgres;

create operator pg_catalog.<@ (procedure = jsonb_contained, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<@(jsonb, jsonb)
is 'is contained by';

alter operator pg_catalog.<@(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_ppoly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.<->(point, polygon)
is 'distance between';

alter operator pg_catalog.<->(point, polygon)
  owner to postgres;

create operator pg_catalog.|| (procedure = jsonb_concat, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.||(jsonb, jsonb)
is 'concatenate';

alter operator pg_catalog.||(jsonb, jsonb)
  owner to postgres;

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.-(jsonb, text)
is 'delete object field';

alter operator pg_catalog.-(jsonb, text)
  owner to postgres;

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.-(jsonb, integer)
is 'delete array element';

alter operator pg_catalog.-(jsonb, integer)
  owner to postgres;

create operator pg_catalog.#- (procedure = jsonb_delete_path, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.#-(jsonb, text [])
is 'delete path';

alter operator pg_catalog.#-(jsonb, text [])
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_polyp, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.<->(polygon, point)
is 'distance between';

alter operator pg_catalog.<->(polygon, point)
  owner to postgres;

create operator pg_catalog.<-> (procedure = dist_cpoint, leftarg = circle, rightarg = point);

comment on operator pg_catalog.<->(circle, point)
is 'distance between';

alter operator pg_catalog.<->(circle, point)
  owner to postgres;

create operator pg_catalog.<> (procedure = xidneq, leftarg = xid, rightarg = xid);

comment on operator pg_catalog.<>(xid, xid)
is 'not equal';

alter operator pg_catalog.<>(xid, xid)
  owner to postgres;

create operator pg_catalog.<> (procedure = xidneqint4, leftarg = xid, rightarg = integer);

comment on operator pg_catalog.<>(xid, integer)
is 'not equal';

alter operator pg_catalog.<>(xid, integer)
  owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog.*(money, bigint)
is 'multiply';

alter operator pg_catalog.*(money, bigint)
  owner to postgres;

create operator pg_catalog./ (procedure = cash_div_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog./(money, bigint)
is 'divide';

alter operator pg_catalog./(money, bigint)
  owner to postgres;

create operator pg_catalog.* (procedure = int8_mul_cash, leftarg = bigint, rightarg = money);

comment on operator pg_catalog.*(bigint, money)
is 'multiply';

alter operator pg_catalog.*(bigint, money)
  owner to postgres;

create operator pg_catalog.= (procedure = macaddr8_eq, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.=(macaddr8, macaddr8)
is 'equal';

alter operator pg_catalog.=(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.<> (procedure = macaddr8_ne, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.<>(macaddr8, macaddr8)
is 'not equal';

alter operator pg_catalog.<>(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.< (procedure = macaddr8_lt, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.<(macaddr8, macaddr8)
is 'less than';

alter operator pg_catalog.<(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.<= (procedure = macaddr8_le, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.<=(macaddr8, macaddr8)
is 'less than or equal';

alter operator pg_catalog.<=(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.> (procedure = macaddr8_gt, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.>(macaddr8, macaddr8)
is 'greater than';

alter operator pg_catalog.>(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.>= (procedure = macaddr8_ge, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.>=(macaddr8, macaddr8)
is 'greater than or equal';

alter operator pg_catalog.>=(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.~ (procedure = macaddr8_not, rightarg = macaddr8);

comment on operator pg_catalog.~(none, macaddr8)
is 'bitwise not';

alter operator pg_catalog.~(none, macaddr8)
  owner to postgres;

create operator pg_catalog.& (procedure = macaddr8_and, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.&(macaddr8, macaddr8)
is 'bitwise and';

alter operator pg_catalog.&(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.| (procedure = macaddr8_or, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.|(macaddr8, macaddr8)
is 'bitwise or';

alter operator pg_catalog.|(macaddr8, macaddr8)
  owner to postgres;

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.-(jsonb, text [])
is 'delete object fields';

alter operator pg_catalog.-(jsonb, text [])
  owner to postgres;

create operator pg_catalog.->> (procedure = jsonb_object_field_text, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->>(jsonb, text)
is 'get jsonb object field as text';

alter operator pg_catalog.->>(jsonb, text)
  owner to postgres;

create operator pg_catalog.->> (procedure = jsonb_array_element_text, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->>(jsonb, integer)
is 'get jsonb array element as text';

alter operator pg_catalog.->>(jsonb, integer)
  owner to postgres;

create operator pg_catalog.= (procedure = enum_eq, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.=(anyenum, anyenum)
is 'equal';

alter operator pg_catalog.=(anyenum, anyenum)
  owner to postgres;

create operator pg_catalog.<> (procedure = enum_ne, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<>(anyenum, anyenum)
is 'not equal';

alter operator pg_catalog.<>(anyenum, anyenum)
  owner to postgres;

create operator pg_catalog.< (procedure = enum_lt, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<(anyenum, anyenum)
is 'less than';

alter operator pg_catalog.<(anyenum, anyenum)
  owner to postgres;

create operator pg_catalog.> (procedure = enum_gt, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.>(anyenum, anyenum)
is 'greater than';

alter operator pg_catalog.>(anyenum, anyenum)
  owner to postgres;

create operator pg_catalog.<= (procedure = enum_le, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<=(anyenum, anyenum)
is 'less than or equal';

alter operator pg_catalog.<=(anyenum, anyenum)
  owner to postgres;

create operator pg_catalog.>= (procedure = enum_ge, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.>=(anyenum, anyenum)
is 'greater than or equal';

alter operator pg_catalog.>=(anyenum, anyenum)
  owner to postgres;

create operator pg_catalog.&& (procedure = network_overlap, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&&(inet, inet)
is 'overlaps (is subnet or supernet)';

alter operator pg_catalog.&&(inet, inet)
  owner to postgres;

create operator pg_catalog.< (procedure = tsvector_lt, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<(tsvector, tsvector)
is 'less than';

alter operator pg_catalog.<(tsvector, tsvector)
  owner to postgres;

create operator pg_catalog.<= (procedure = tsvector_le, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<=(tsvector, tsvector)
is 'less than or equal';

alter operator pg_catalog.<=(tsvector, tsvector)
  owner to postgres;

create operator pg_catalog.= (procedure = tsvector_eq, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.=(tsvector, tsvector)
is 'equal';

alter operator pg_catalog.=(tsvector, tsvector)
  owner to postgres;

create operator pg_catalog.<> (procedure = tsvector_ne, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<>(tsvector, tsvector)
is 'not equal';

alter operator pg_catalog.<>(tsvector, tsvector)
  owner to postgres;

create operator pg_catalog.>= (procedure = tsvector_ge, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.>=(tsvector, tsvector)
is 'greater than or equal';

alter operator pg_catalog.>=(tsvector, tsvector)
  owner to postgres;

create operator pg_catalog.> (procedure = tsvector_gt, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.>(tsvector, tsvector)
is 'greater than';

alter operator pg_catalog.>(tsvector, tsvector)
  owner to postgres;

create operator pg_catalog.|| (procedure = tsvector_concat, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.||(tsvector, tsvector)
is 'concatenate';

alter operator pg_catalog.||(tsvector, tsvector)
  owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery);

comment on operator pg_catalog.@@(tsvector, tsquery)
is 'text search match';

alter operator pg_catalog.@@(tsvector, tsquery)
  owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector);

comment on operator pg_catalog.@@(tsquery, tsvector)
is 'text search match';

alter operator pg_catalog.@@(tsquery, tsvector)
  owner to postgres;

create operator pg_catalog.@@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery);

comment on operator pg_catalog.@@@(tsvector, tsquery)
is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsvector, tsquery)
  owner to postgres;

create operator pg_catalog.@@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector);

comment on operator pg_catalog.@@@(tsquery, tsvector)
is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsquery, tsvector)
  owner to postgres;

create operator pg_catalog.< (procedure = tsquery_lt, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<(tsquery, tsquery)
is 'less than';

alter operator pg_catalog.<(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.<= (procedure = tsquery_le, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<=(tsquery, tsquery)
is 'less than or equal';

alter operator pg_catalog.<=(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.= (procedure = tsquery_eq, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.=(tsquery, tsquery)
is 'equal';

alter operator pg_catalog.=(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.<> (procedure = tsquery_ne, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<>(tsquery, tsquery)
is 'not equal';

alter operator pg_catalog.<>(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.>= (procedure = tsquery_ge, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.>=(tsquery, tsquery)
is 'greater than or equal';

alter operator pg_catalog.>=(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.> (procedure = tsquery_gt, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.>(tsquery, tsquery)
is 'greater than';

alter operator pg_catalog.>(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.&& (procedure = tsquery_and, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.&&(tsquery, tsquery)
is 'AND-concatenate';

alter operator pg_catalog.&&(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.|| (procedure = tsquery_or, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.||(tsquery, tsquery)
is 'OR-concatenate';

alter operator pg_catalog.||(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.!! (procedure = tsquery_not, rightarg = tsquery);

comment on operator pg_catalog.!!(none, tsquery)
is 'NOT tsquery';

alter operator pg_catalog.!!(none, tsquery)
  owner to postgres;

create operator pg_catalog.@> (procedure = tsq_mcontains, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.@>(tsquery, tsquery)
is 'contains';

alter operator pg_catalog.@>(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.<@ (procedure = tsq_mcontained, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<@(tsquery, tsquery)
is 'is contained by';

alter operator pg_catalog.<@(tsquery, tsquery)
  owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_tt, leftarg = text, rightarg = text);

comment on operator pg_catalog.@@(text, text)
is 'text search match';

alter operator pg_catalog.@@(text, text)
  owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_tq, leftarg = text, rightarg = tsquery);

comment on operator pg_catalog.@@(text, tsquery)
is 'text search match';

alter operator pg_catalog.@@(text, tsquery)
  owner to postgres;

create operator pg_catalog./ (procedure = cash_div_cash, leftarg = money, rightarg = money);

comment on operator pg_catalog./(money, money)
is 'divide';

alter operator pg_catalog./(money, money)
  owner to postgres;

create operator pg_catalog.= (procedure = range_eq, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.=(anyrange, anyrange)
is 'equal';

alter operator pg_catalog.=(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.<> (procedure = range_ne, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<>(anyrange, anyrange)
is 'not equal';

alter operator pg_catalog.<>(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.< (procedure = range_lt, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<(anyrange, anyrange)
is 'less than';

alter operator pg_catalog.<(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.<= (procedure = range_le, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<=(anyrange, anyrange)
is 'less than or equal';

alter operator pg_catalog.<=(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.>= (procedure = range_ge, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>=(anyrange, anyrange)
is 'greater than or equal';

alter operator pg_catalog.>=(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.> (procedure = range_gt, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>(anyrange, anyrange)
is 'greater than';

alter operator pg_catalog.>(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.&& (procedure = range_overlaps, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&&(anyrange, anyrange)
is 'overlaps';

alter operator pg_catalog.&&(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.@> (procedure = range_contains_elem, leftarg = anyrange, rightarg = anyelement);

comment on operator pg_catalog.@>(anyrange, anyelement)
is 'contains';

alter operator pg_catalog.@>(anyrange, anyelement)
  owner to postgres;

create operator pg_catalog.@> (procedure = range_contains, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.@>(anyrange, anyrange)
is 'contains';

alter operator pg_catalog.@>(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.<@ (procedure = elem_contained_by_range, leftarg = anyelement, rightarg = anyrange);

comment on operator pg_catalog.<@(anyelement, anyrange)
is 'is contained by';

alter operator pg_catalog.<@(anyelement, anyrange)
  owner to postgres;

create operator pg_catalog.<@ (procedure = range_contained_by, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<@(anyrange, anyrange)
is 'is contained by';

alter operator pg_catalog.<@(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.<< (procedure = range_before, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<<(anyrange, anyrange)
is 'is left of';

alter operator pg_catalog.<<(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.>> (procedure = range_after, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>>(anyrange, anyrange)
is 'is right of';

alter operator pg_catalog.>>(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.&< (procedure = range_overleft, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&<(anyrange, anyrange)
is 'overlaps or is left of';

alter operator pg_catalog.&<(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.&> (procedure = range_overright, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&>(anyrange, anyrange)
is 'overlaps or is right of';

alter operator pg_catalog.&>(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.-|- (procedure = range_adjacent, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-|-(anyrange, anyrange)
is 'is adjacent to';

alter operator pg_catalog.-|-(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.+ (procedure = range_union, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.+(anyrange, anyrange)
is 'range union';

alter operator pg_catalog.+(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.- (procedure = range_minus, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-(anyrange, anyrange)
is 'range difference';

alter operator pg_catalog.-(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.* (procedure = range_intersect, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.*(anyrange, anyrange)
is 'range intersection';

alter operator pg_catalog.*(anyrange, anyrange)
  owner to postgres;

create operator pg_catalog.-> (procedure = json_object_field, leftarg = json, rightarg = text);

comment on operator pg_catalog.->(json, text)
is 'get json object field';

alter operator pg_catalog.->(json, text)
  owner to postgres;

create operator pg_catalog.->> (procedure = json_object_field_text, leftarg = json, rightarg = text);

comment on operator pg_catalog.->>(json, text)
is 'get json object field as text';

alter operator pg_catalog.->>(json, text)
  owner to postgres;

create operator pg_catalog.-> (procedure = json_array_element, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->(json, integer)
is 'get json array element';

alter operator pg_catalog.->(json, integer)
  owner to postgres;

create operator pg_catalog.->> (procedure = json_array_element_text, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->>(json, integer)
is 'get json array element as text';

alter operator pg_catalog.->>(json, integer)
  owner to postgres;

create operator pg_catalog.#> (procedure = json_extract_path, leftarg = json, rightarg = text []);

comment on operator pg_catalog.#>(json, text [])
is 'get value from json with path elements';

alter operator pg_catalog.#>(json, text [])
  owner to postgres;

create operator pg_catalog.#>> (procedure = json_extract_path_text, leftarg = json, rightarg = text []);

comment on operator pg_catalog.#>>(json, text [])
is 'get value from json as text with path elements';

alter operator pg_catalog.#>>(json, text [])
  owner to postgres;

create operator pg_catalog.<-> (procedure = "pg_catalog.tsquery_phrase", leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<->(tsquery, tsquery)
is 'phrase-concatenate';

alter operator pg_catalog.<->(tsquery, tsquery)
  owner to postgres;

comment on collation pg_catalog."default"
is 'database''s default collation';

alter collation pg_catalog."default"
  owner to postgres;

create collation pg_catalog."C" (
  locale = 'C'
);

comment on collation pg_catalog."C"
is 'standard C collation';

alter collation pg_catalog."C"
  owner to postgres;

create collation pg_catalog."POSIX" (
  locale = 'POSIX'
);

comment on collation pg_catalog."POSIX"
is 'standard POSIX collation';

alter collation pg_catalog."POSIX"
  owner to postgres;

create collation pg_catalog.ucs_basic (
  locale = 'C'
);

alter collation pg_catalog.ucs_basic
  owner to postgres;

create collation pg_catalog."C.UTF-8" (
  locale = 'C.UTF-8'
);

alter collation pg_catalog."C.UTF-8"
  owner to postgres;

create collation pg_catalog."en_US.utf8" (
  locale = 'en_US.utf8'
);

alter collation pg_catalog."en_US.utf8"
  owner to postgres;

create collation pg_catalog."en_US" (
  locale = 'en_US.utf8'
);

alter collation pg_catalog."en_US"
  owner to postgres;

create collation pg_catalog."und-x-icu" (
  locale = 'und'
);

alter collation pg_catalog."und-x-icu"
  owner to postgres;

create collation pg_catalog."af-x-icu" (
  locale = 'af'
);

comment on collation pg_catalog."af-x-icu"
is 'Afrikaans';

alter collation pg_catalog."af-x-icu"
  owner to postgres;

create collation pg_catalog."af-NA-x-icu" (
  locale = 'af-NA'
);

comment on collation pg_catalog."af-NA-x-icu"
is 'Afrikaans (Namibia)';

alter collation pg_catalog."af-NA-x-icu"
  owner to postgres;

create collation pg_catalog."af-ZA-x-icu" (
  locale = 'af-ZA'
);

comment on collation pg_catalog."af-ZA-x-icu"
is 'Afrikaans (South Africa)';

alter collation pg_catalog."af-ZA-x-icu"
  owner to postgres;

create collation pg_catalog."agq-x-icu" (
  locale = 'agq'
);

comment on collation pg_catalog."agq-x-icu"
is 'Aghem';

alter collation pg_catalog."agq-x-icu"
  owner to postgres;

create collation pg_catalog."agq-CM-x-icu" (
  locale = 'agq-CM'
);

comment on collation pg_catalog."agq-CM-x-icu"
is 'Aghem (Cameroon)';

alter collation pg_catalog."agq-CM-x-icu"
  owner to postgres;

create collation pg_catalog."ak-x-icu" (
  locale = 'ak'
);

comment on collation pg_catalog."ak-x-icu"
is 'Akan';

alter collation pg_catalog."ak-x-icu"
  owner to postgres;

create collation pg_catalog."ak-GH-x-icu" (
  locale = 'ak-GH'
);

comment on collation pg_catalog."ak-GH-x-icu"
is 'Akan (Ghana)';

alter collation pg_catalog."ak-GH-x-icu"
  owner to postgres;

create collation pg_catalog."am-x-icu" (
  locale = 'am'
);

comment on collation pg_catalog."am-x-icu"
is 'Amharic';

alter collation pg_catalog."am-x-icu"
  owner to postgres;

create collation pg_catalog."am-ET-x-icu" (
  locale = 'am-ET'
);

comment on collation pg_catalog."am-ET-x-icu"
is 'Amharic (Ethiopia)';

alter collation pg_catalog."am-ET-x-icu"
  owner to postgres;

create collation pg_catalog."ar-x-icu" (
  locale = 'ar'
);

comment on collation pg_catalog."ar-x-icu"
is 'Arabic';

alter collation pg_catalog."ar-x-icu"
  owner to postgres;

create collation pg_catalog."ar-001-x-icu" (
  locale = 'ar-001'
);

comment on collation pg_catalog."ar-001-x-icu"
is 'Arabic (World)';

alter collation pg_catalog."ar-001-x-icu"
  owner to postgres;

create collation pg_catalog."ar-AE-x-icu" (
  locale = 'ar-AE'
);

comment on collation pg_catalog."ar-AE-x-icu"
is 'Arabic (United Arab Emirates)';

alter collation pg_catalog."ar-AE-x-icu"
  owner to postgres;

create collation pg_catalog."ar-BH-x-icu" (
  locale = 'ar-BH'
);

comment on collation pg_catalog."ar-BH-x-icu"
is 'Arabic (Bahrain)';

alter collation pg_catalog."ar-BH-x-icu"
  owner to postgres;

create collation pg_catalog."ar-DJ-x-icu" (
  locale = 'ar-DJ'
);

comment on collation pg_catalog."ar-DJ-x-icu"
is 'Arabic (Djibouti)';

alter collation pg_catalog."ar-DJ-x-icu"
  owner to postgres;

create collation pg_catalog."ar-DZ-x-icu" (
  locale = 'ar-DZ'
);

comment on collation pg_catalog."ar-DZ-x-icu"
is 'Arabic (Algeria)';

alter collation pg_catalog."ar-DZ-x-icu"
  owner to postgres;

create collation pg_catalog."ar-EG-x-icu" (
  locale = 'ar-EG'
);

comment on collation pg_catalog."ar-EG-x-icu"
is 'Arabic (Egypt)';

alter collation pg_catalog."ar-EG-x-icu"
  owner to postgres;

create collation pg_catalog."ar-EH-x-icu" (
  locale = 'ar-EH'
);

comment on collation pg_catalog."ar-EH-x-icu"
is 'Arabic (Western Sahara)';

alter collation pg_catalog."ar-EH-x-icu"
  owner to postgres;

create collation pg_catalog."ar-ER-x-icu" (
  locale = 'ar-ER'
);

comment on collation pg_catalog."ar-ER-x-icu"
is 'Arabic (Eritrea)';

alter collation pg_catalog."ar-ER-x-icu"
  owner to postgres;

create collation pg_catalog."ar-IL-x-icu" (
  locale = 'ar-IL'
);

comment on collation pg_catalog."ar-IL-x-icu"
is 'Arabic (Israel)';

alter collation pg_catalog."ar-IL-x-icu"
  owner to postgres;

create collation pg_catalog."ar-IQ-x-icu" (
  locale = 'ar-IQ'
);

comment on collation pg_catalog."ar-IQ-x-icu"
is 'Arabic (Iraq)';

alter collation pg_catalog."ar-IQ-x-icu"
  owner to postgres;

create collation pg_catalog."ar-JO-x-icu" (
  locale = 'ar-JO'
);

comment on collation pg_catalog."ar-JO-x-icu"
is 'Arabic (Jordan)';

alter collation pg_catalog."ar-JO-x-icu"
  owner to postgres;

create collation pg_catalog."ar-KM-x-icu" (
  locale = 'ar-KM'
);

comment on collation pg_catalog."ar-KM-x-icu"
is 'Arabic (Comoros)';

alter collation pg_catalog."ar-KM-x-icu"
  owner to postgres;

create collation pg_catalog."ar-KW-x-icu" (
  locale = 'ar-KW'
);

comment on collation pg_catalog."ar-KW-x-icu"
is 'Arabic (Kuwait)';

alter collation pg_catalog."ar-KW-x-icu"
  owner to postgres;

create collation pg_catalog."ar-LB-x-icu" (
  locale = 'ar-LB'
);

comment on collation pg_catalog."ar-LB-x-icu"
is 'Arabic (Lebanon)';

alter collation pg_catalog."ar-LB-x-icu"
  owner to postgres;

create collation pg_catalog."ar-LY-x-icu" (
  locale = 'ar-LY'
);

comment on collation pg_catalog."ar-LY-x-icu"
is 'Arabic (Libya)';

alter collation pg_catalog."ar-LY-x-icu"
  owner to postgres;

create collation pg_catalog."ar-MA-x-icu" (
  locale = 'ar-MA'
);

comment on collation pg_catalog."ar-MA-x-icu"
is 'Arabic (Morocco)';

alter collation pg_catalog."ar-MA-x-icu"
  owner to postgres;

create collation pg_catalog."ar-MR-x-icu" (
  locale = 'ar-MR'
);

comment on collation pg_catalog."ar-MR-x-icu"
is 'Arabic (Mauritania)';

alter collation pg_catalog."ar-MR-x-icu"
  owner to postgres;

create collation pg_catalog."ar-OM-x-icu" (
  locale = 'ar-OM'
);

comment on collation pg_catalog."ar-OM-x-icu"
is 'Arabic (Oman)';

alter collation pg_catalog."ar-OM-x-icu"
  owner to postgres;

create collation pg_catalog."ar-PS-x-icu" (
  locale = 'ar-PS'
);

comment on collation pg_catalog."ar-PS-x-icu"
is 'Arabic (Palestinian Territories)';

alter collation pg_catalog."ar-PS-x-icu"
  owner to postgres;

create collation pg_catalog."ar-QA-x-icu" (
  locale = 'ar-QA'
);

comment on collation pg_catalog."ar-QA-x-icu"
is 'Arabic (Qatar)';

alter collation pg_catalog."ar-QA-x-icu"
  owner to postgres;

create collation pg_catalog."ar-SA-x-icu" (
  locale = 'ar-SA'
);

comment on collation pg_catalog."ar-SA-x-icu"
is 'Arabic (Saudi Arabia)';

alter collation pg_catalog."ar-SA-x-icu"
  owner to postgres;

create collation pg_catalog."ar-SD-x-icu" (
  locale = 'ar-SD'
);

comment on collation pg_catalog."ar-SD-x-icu"
is 'Arabic (Sudan)';

alter collation pg_catalog."ar-SD-x-icu"
  owner to postgres;

create collation pg_catalog."ar-SO-x-icu" (
  locale = 'ar-SO'
);

comment on collation pg_catalog."ar-SO-x-icu"
is 'Arabic (Somalia)';

alter collation pg_catalog."ar-SO-x-icu"
  owner to postgres;

create collation pg_catalog."ar-SS-x-icu" (
  locale = 'ar-SS'
);

comment on collation pg_catalog."ar-SS-x-icu"
is 'Arabic (South Sudan)';

alter collation pg_catalog."ar-SS-x-icu"
  owner to postgres;

create collation pg_catalog."ar-SY-x-icu" (
  locale = 'ar-SY'
);

comment on collation pg_catalog."ar-SY-x-icu"
is 'Arabic (Syria)';

alter collation pg_catalog."ar-SY-x-icu"
  owner to postgres;

create collation pg_catalog."ar-TD-x-icu" (
  locale = 'ar-TD'
);

comment on collation pg_catalog."ar-TD-x-icu"
is 'Arabic (Chad)';

alter collation pg_catalog."ar-TD-x-icu"
  owner to postgres;

create collation pg_catalog."ar-TN-x-icu" (
  locale = 'ar-TN'
);

comment on collation pg_catalog."ar-TN-x-icu"
is 'Arabic (Tunisia)';

alter collation pg_catalog."ar-TN-x-icu"
  owner to postgres;

create collation pg_catalog."ar-YE-x-icu" (
  locale = 'ar-YE'
);

comment on collation pg_catalog."ar-YE-x-icu"
is 'Arabic (Yemen)';

alter collation pg_catalog."ar-YE-x-icu"
  owner to postgres;

create collation pg_catalog."as-x-icu" (
  locale = 'as'
);

comment on collation pg_catalog."as-x-icu"
is 'Assamese';

alter collation pg_catalog."as-x-icu"
  owner to postgres;

create collation pg_catalog."as-IN-x-icu" (
  locale = 'as-IN'
);

comment on collation pg_catalog."as-IN-x-icu"
is 'Assamese (India)';

alter collation pg_catalog."as-IN-x-icu"
  owner to postgres;

create collation pg_catalog."asa-x-icu" (
  locale = 'asa'
);

comment on collation pg_catalog."asa-x-icu"
is 'Asu';

alter collation pg_catalog."asa-x-icu"
  owner to postgres;

create collation pg_catalog."asa-TZ-x-icu" (
  locale = 'asa-TZ'
);

comment on collation pg_catalog."asa-TZ-x-icu"
is 'Asu (Tanzania)';

alter collation pg_catalog."asa-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."ast-x-icu" (
  locale = 'ast'
);

comment on collation pg_catalog."ast-x-icu"
is 'Asturian';

alter collation pg_catalog."ast-x-icu"
  owner to postgres;

create collation pg_catalog."ast-ES-x-icu" (
  locale = 'ast-ES'
);

comment on collation pg_catalog."ast-ES-x-icu"
is 'Asturian (Spain)';

alter collation pg_catalog."ast-ES-x-icu"
  owner to postgres;

create collation pg_catalog."az-x-icu" (
  locale = 'az'
);

comment on collation pg_catalog."az-x-icu"
is 'Azerbaijani';

alter collation pg_catalog."az-x-icu"
  owner to postgres;

create collation pg_catalog."az-Cyrl-x-icu" (
  locale = 'az-Cyrl'
);

comment on collation pg_catalog."az-Cyrl-x-icu"
is 'Azerbaijani (Cyrillic)';

alter collation pg_catalog."az-Cyrl-x-icu"
  owner to postgres;

create collation pg_catalog."az-Cyrl-AZ-x-icu" (
  locale = 'az-Cyrl-AZ'
);

comment on collation pg_catalog."az-Cyrl-AZ-x-icu"
is 'Azerbaijani (Cyrillic, Azerbaijan)';

alter collation pg_catalog."az-Cyrl-AZ-x-icu"
  owner to postgres;

create collation pg_catalog."az-Latn-x-icu" (
  locale = 'az-Latn'
);

comment on collation pg_catalog."az-Latn-x-icu"
is 'Azerbaijani (Latin)';

alter collation pg_catalog."az-Latn-x-icu"
  owner to postgres;

create collation pg_catalog."az-Latn-AZ-x-icu" (
  locale = 'az-Latn-AZ'
);

comment on collation pg_catalog."az-Latn-AZ-x-icu"
is 'Azerbaijani (Latin, Azerbaijan)';

alter collation pg_catalog."az-Latn-AZ-x-icu"
  owner to postgres;

create collation pg_catalog."bas-x-icu" (
  locale = 'bas'
);

comment on collation pg_catalog."bas-x-icu"
is 'Basaa';

alter collation pg_catalog."bas-x-icu"
  owner to postgres;

create collation pg_catalog."bas-CM-x-icu" (
  locale = 'bas-CM'
);

comment on collation pg_catalog."bas-CM-x-icu"
is 'Basaa (Cameroon)';

alter collation pg_catalog."bas-CM-x-icu"
  owner to postgres;

create collation pg_catalog."be-x-icu" (
  locale = 'be'
);

comment on collation pg_catalog."be-x-icu"
is 'Belarusian';

alter collation pg_catalog."be-x-icu"
  owner to postgres;

create collation pg_catalog."be-BY-x-icu" (
  locale = 'be-BY'
);

comment on collation pg_catalog."be-BY-x-icu"
is 'Belarusian (Belarus)';

alter collation pg_catalog."be-BY-x-icu"
  owner to postgres;

create collation pg_catalog."bem-x-icu" (
  locale = 'bem'
);

comment on collation pg_catalog."bem-x-icu"
is 'Bemba';

alter collation pg_catalog."bem-x-icu"
  owner to postgres;

create collation pg_catalog."bem-ZM-x-icu" (
  locale = 'bem-ZM'
);

comment on collation pg_catalog."bem-ZM-x-icu"
is 'Bemba (Zambia)';

alter collation pg_catalog."bem-ZM-x-icu"
  owner to postgres;

create collation pg_catalog."bez-x-icu" (
  locale = 'bez'
);

comment on collation pg_catalog."bez-x-icu"
is 'Bena';

alter collation pg_catalog."bez-x-icu"
  owner to postgres;

create collation pg_catalog."bez-TZ-x-icu" (
  locale = 'bez-TZ'
);

comment on collation pg_catalog."bez-TZ-x-icu"
is 'Bena (Tanzania)';

alter collation pg_catalog."bez-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."bg-x-icu" (
  locale = 'bg'
);

comment on collation pg_catalog."bg-x-icu"
is 'Bulgarian';

alter collation pg_catalog."bg-x-icu"
  owner to postgres;

create collation pg_catalog."bg-BG-x-icu" (
  locale = 'bg-BG'
);

comment on collation pg_catalog."bg-BG-x-icu"
is 'Bulgarian (Bulgaria)';

alter collation pg_catalog."bg-BG-x-icu"
  owner to postgres;

create collation pg_catalog."bm-x-icu" (
  locale = 'bm'
);

comment on collation pg_catalog."bm-x-icu"
is 'Bambara';

alter collation pg_catalog."bm-x-icu"
  owner to postgres;

create collation pg_catalog."bm-ML-x-icu" (
  locale = 'bm-ML'
);

comment on collation pg_catalog."bm-ML-x-icu"
is 'Bambara (Mali)';

alter collation pg_catalog."bm-ML-x-icu"
  owner to postgres;

create collation pg_catalog."bn-x-icu" (
  locale = 'bn'
);

comment on collation pg_catalog."bn-x-icu"
is 'Bengali';

alter collation pg_catalog."bn-x-icu"
  owner to postgres;

create collation pg_catalog."bn-BD-x-icu" (
  locale = 'bn-BD'
);

comment on collation pg_catalog."bn-BD-x-icu"
is 'Bengali (Bangladesh)';

alter collation pg_catalog."bn-BD-x-icu"
  owner to postgres;

create collation pg_catalog."bn-IN-x-icu" (
  locale = 'bn-IN'
);

comment on collation pg_catalog."bn-IN-x-icu"
is 'Bengali (India)';

alter collation pg_catalog."bn-IN-x-icu"
  owner to postgres;

create collation pg_catalog."bo-x-icu" (
  locale = 'bo'
);

comment on collation pg_catalog."bo-x-icu"
is 'Tibetan';

alter collation pg_catalog."bo-x-icu"
  owner to postgres;

create collation pg_catalog."bo-CN-x-icu" (
  locale = 'bo-CN'
);

comment on collation pg_catalog."bo-CN-x-icu"
is 'Tibetan (China)';

alter collation pg_catalog."bo-CN-x-icu"
  owner to postgres;

create collation pg_catalog."bo-IN-x-icu" (
  locale = 'bo-IN'
);

comment on collation pg_catalog."bo-IN-x-icu"
is 'Tibetan (India)';

alter collation pg_catalog."bo-IN-x-icu"
  owner to postgres;

create collation pg_catalog."br-x-icu" (
  locale = 'br'
);

comment on collation pg_catalog."br-x-icu"
is 'Breton';

alter collation pg_catalog."br-x-icu"
  owner to postgres;

create collation pg_catalog."br-FR-x-icu" (
  locale = 'br-FR'
);

comment on collation pg_catalog."br-FR-x-icu"
is 'Breton (France)';

alter collation pg_catalog."br-FR-x-icu"
  owner to postgres;

create collation pg_catalog."brx-x-icu" (
  locale = 'brx'
);

comment on collation pg_catalog."brx-x-icu"
is 'Bodo';

alter collation pg_catalog."brx-x-icu"
  owner to postgres;

create collation pg_catalog."brx-IN-x-icu" (
  locale = 'brx-IN'
);

comment on collation pg_catalog."brx-IN-x-icu"
is 'Bodo (India)';

alter collation pg_catalog."brx-IN-x-icu"
  owner to postgres;

create collation pg_catalog."bs-x-icu" (
  locale = 'bs'
);

comment on collation pg_catalog."bs-x-icu"
is 'Bosnian';

alter collation pg_catalog."bs-x-icu"
  owner to postgres;

create collation pg_catalog."bs-Cyrl-x-icu" (
  locale = 'bs-Cyrl'
);

comment on collation pg_catalog."bs-Cyrl-x-icu"
is 'Bosnian (Cyrillic)';

alter collation pg_catalog."bs-Cyrl-x-icu"
  owner to postgres;

create collation pg_catalog."bs-Cyrl-BA-x-icu" (
  locale = 'bs-Cyrl-BA'
);

comment on collation pg_catalog."bs-Cyrl-BA-x-icu"
is 'Bosnian (Cyrillic, Bosnia & Herzegovina)';

alter collation pg_catalog."bs-Cyrl-BA-x-icu"
  owner to postgres;

create collation pg_catalog."bs-Latn-x-icu" (
  locale = 'bs-Latn'
);

comment on collation pg_catalog."bs-Latn-x-icu"
is 'Bosnian (Latin)';

alter collation pg_catalog."bs-Latn-x-icu"
  owner to postgres;

create collation pg_catalog."bs-Latn-BA-x-icu" (
  locale = 'bs-Latn-BA'
);

comment on collation pg_catalog."bs-Latn-BA-x-icu"
is 'Bosnian (Latin, Bosnia & Herzegovina)';

alter collation pg_catalog."bs-Latn-BA-x-icu"
  owner to postgres;

create collation pg_catalog."ca-x-icu" (
  locale = 'ca'
);

comment on collation pg_catalog."ca-x-icu"
is 'Catalan';

alter collation pg_catalog."ca-x-icu"
  owner to postgres;

create collation pg_catalog."ca-AD-x-icu" (
  locale = 'ca-AD'
);

comment on collation pg_catalog."ca-AD-x-icu"
is 'Catalan (Andorra)';

alter collation pg_catalog."ca-AD-x-icu"
  owner to postgres;

create collation pg_catalog."ca-ES-x-icu" (
  locale = 'ca-ES'
);

comment on collation pg_catalog."ca-ES-x-icu"
is 'Catalan (Spain)';

alter collation pg_catalog."ca-ES-x-icu"
  owner to postgres;

create collation pg_catalog."ca-FR-x-icu" (
  locale = 'ca-FR'
);

comment on collation pg_catalog."ca-FR-x-icu"
is 'Catalan (France)';

alter collation pg_catalog."ca-FR-x-icu"
  owner to postgres;

create collation pg_catalog."ca-IT-x-icu" (
  locale = 'ca-IT'
);

comment on collation pg_catalog."ca-IT-x-icu"
is 'Catalan (Italy)';

alter collation pg_catalog."ca-IT-x-icu"
  owner to postgres;

create collation pg_catalog."ce-x-icu" (
  locale = 'ce'
);

comment on collation pg_catalog."ce-x-icu"
is 'Chechen';

alter collation pg_catalog."ce-x-icu"
  owner to postgres;

create collation pg_catalog."ce-RU-x-icu" (
  locale = 'ce-RU'
);

comment on collation pg_catalog."ce-RU-x-icu"
is 'Chechen (Russia)';

alter collation pg_catalog."ce-RU-x-icu"
  owner to postgres;

create collation pg_catalog."cgg-x-icu" (
  locale = 'cgg'
);

comment on collation pg_catalog."cgg-x-icu"
is 'Chiga';

alter collation pg_catalog."cgg-x-icu"
  owner to postgres;

create collation pg_catalog."cgg-UG-x-icu" (
  locale = 'cgg-UG'
);

comment on collation pg_catalog."cgg-UG-x-icu"
is 'Chiga (Uganda)';

alter collation pg_catalog."cgg-UG-x-icu"
  owner to postgres;

create collation pg_catalog."chr-x-icu" (
  locale = 'chr'
);

comment on collation pg_catalog."chr-x-icu"
is 'Cherokee';

alter collation pg_catalog."chr-x-icu"
  owner to postgres;

create collation pg_catalog."chr-US-x-icu" (
  locale = 'chr-US'
);

comment on collation pg_catalog."chr-US-x-icu"
is 'Cherokee (United States)';

alter collation pg_catalog."chr-US-x-icu"
  owner to postgres;

create collation pg_catalog."cs-x-icu" (
  locale = 'cs'
);

comment on collation pg_catalog."cs-x-icu"
is 'Czech';

alter collation pg_catalog."cs-x-icu"
  owner to postgres;

create collation pg_catalog."cs-CZ-x-icu" (
  locale = 'cs-CZ'
);

comment on collation pg_catalog."cs-CZ-x-icu"
is 'Czech (Czech Republic)';

alter collation pg_catalog."cs-CZ-x-icu"
  owner to postgres;

create collation pg_catalog."cy-x-icu" (
  locale = 'cy'
);

comment on collation pg_catalog."cy-x-icu"
is 'Welsh';

alter collation pg_catalog."cy-x-icu"
  owner to postgres;

create collation pg_catalog."cy-GB-x-icu" (
  locale = 'cy-GB'
);

comment on collation pg_catalog."cy-GB-x-icu"
is 'Welsh (United Kingdom)';

alter collation pg_catalog."cy-GB-x-icu"
  owner to postgres;

create collation pg_catalog."da-x-icu" (
  locale = 'da'
);

comment on collation pg_catalog."da-x-icu"
is 'Danish';

alter collation pg_catalog."da-x-icu"
  owner to postgres;

create collation pg_catalog."da-DK-x-icu" (
  locale = 'da-DK'
);

comment on collation pg_catalog."da-DK-x-icu"
is 'Danish (Denmark)';

alter collation pg_catalog."da-DK-x-icu"
  owner to postgres;

create collation pg_catalog."da-GL-x-icu" (
  locale = 'da-GL'
);

comment on collation pg_catalog."da-GL-x-icu"
is 'Danish (Greenland)';

alter collation pg_catalog."da-GL-x-icu"
  owner to postgres;

create collation pg_catalog."dav-x-icu" (
  locale = 'dav'
);

comment on collation pg_catalog."dav-x-icu"
is 'Taita';

alter collation pg_catalog."dav-x-icu"
  owner to postgres;

create collation pg_catalog."dav-KE-x-icu" (
  locale = 'dav-KE'
);

comment on collation pg_catalog."dav-KE-x-icu"
is 'Taita (Kenya)';

alter collation pg_catalog."dav-KE-x-icu"
  owner to postgres;

create collation pg_catalog."de-x-icu" (
  locale = 'de'
);

comment on collation pg_catalog."de-x-icu"
is 'German';

alter collation pg_catalog."de-x-icu"
  owner to postgres;

create collation pg_catalog."de-AT-x-icu" (
  locale = 'de-AT'
);

comment on collation pg_catalog."de-AT-x-icu"
is 'German (Austria)';

alter collation pg_catalog."de-AT-x-icu"
  owner to postgres;

create collation pg_catalog."de-BE-x-icu" (
  locale = 'de-BE'
);

comment on collation pg_catalog."de-BE-x-icu"
is 'German (Belgium)';

alter collation pg_catalog."de-BE-x-icu"
  owner to postgres;

create collation pg_catalog."de-CH-x-icu" (
  locale = 'de-CH'
);

comment on collation pg_catalog."de-CH-x-icu"
is 'German (Switzerland)';

alter collation pg_catalog."de-CH-x-icu"
  owner to postgres;

create collation pg_catalog."de-DE-x-icu" (
  locale = 'de-DE'
);

comment on collation pg_catalog."de-DE-x-icu"
is 'German (Germany)';

alter collation pg_catalog."de-DE-x-icu"
  owner to postgres;

create collation pg_catalog."de-LI-x-icu" (
  locale = 'de-LI'
);

comment on collation pg_catalog."de-LI-x-icu"
is 'German (Liechtenstein)';

alter collation pg_catalog."de-LI-x-icu"
  owner to postgres;

create collation pg_catalog."de-LU-x-icu" (
  locale = 'de-LU'
);

comment on collation pg_catalog."de-LU-x-icu"
is 'German (Luxembourg)';

alter collation pg_catalog."de-LU-x-icu"
  owner to postgres;

create collation pg_catalog."dje-x-icu" (
  locale = 'dje'
);

comment on collation pg_catalog."dje-x-icu"
is 'Zarma';

alter collation pg_catalog."dje-x-icu"
  owner to postgres;

create collation pg_catalog."dje-NE-x-icu" (
  locale = 'dje-NE'
);

comment on collation pg_catalog."dje-NE-x-icu"
is 'Zarma (Niger)';

alter collation pg_catalog."dje-NE-x-icu"
  owner to postgres;

create collation pg_catalog."dsb-x-icu" (
  locale = 'dsb'
);

comment on collation pg_catalog."dsb-x-icu"
is 'Lower Sorbian';

alter collation pg_catalog."dsb-x-icu"
  owner to postgres;

create collation pg_catalog."dsb-DE-x-icu" (
  locale = 'dsb-DE'
);

comment on collation pg_catalog."dsb-DE-x-icu"
is 'Lower Sorbian (Germany)';

alter collation pg_catalog."dsb-DE-x-icu"
  owner to postgres;

create collation pg_catalog."dua-x-icu" (
  locale = 'dua'
);

comment on collation pg_catalog."dua-x-icu"
is 'Duala';

alter collation pg_catalog."dua-x-icu"
  owner to postgres;

create collation pg_catalog."dua-CM-x-icu" (
  locale = 'dua-CM'
);

comment on collation pg_catalog."dua-CM-x-icu"
is 'Duala (Cameroon)';

alter collation pg_catalog."dua-CM-x-icu"
  owner to postgres;

create collation pg_catalog."dyo-x-icu" (
  locale = 'dyo'
);

comment on collation pg_catalog."dyo-x-icu"
is 'Jola-Fonyi';

alter collation pg_catalog."dyo-x-icu"
  owner to postgres;

create collation pg_catalog."dyo-SN-x-icu" (
  locale = 'dyo-SN'
);

comment on collation pg_catalog."dyo-SN-x-icu"
is 'Jola-Fonyi (Senegal)';

alter collation pg_catalog."dyo-SN-x-icu"
  owner to postgres;

create collation pg_catalog."dz-x-icu" (
  locale = 'dz'
);

comment on collation pg_catalog."dz-x-icu"
is 'Dzongkha';

alter collation pg_catalog."dz-x-icu"
  owner to postgres;

create collation pg_catalog."dz-BT-x-icu" (
  locale = 'dz-BT'
);

comment on collation pg_catalog."dz-BT-x-icu"
is 'Dzongkha (Bhutan)';

alter collation pg_catalog."dz-BT-x-icu"
  owner to postgres;

create collation pg_catalog."ebu-x-icu" (
  locale = 'ebu'
);

comment on collation pg_catalog."ebu-x-icu"
is 'Embu';

alter collation pg_catalog."ebu-x-icu"
  owner to postgres;

create collation pg_catalog."ebu-KE-x-icu" (
  locale = 'ebu-KE'
);

comment on collation pg_catalog."ebu-KE-x-icu"
is 'Embu (Kenya)';

alter collation pg_catalog."ebu-KE-x-icu"
  owner to postgres;

create collation pg_catalog."ee-x-icu" (
  locale = 'ee'
);

comment on collation pg_catalog."ee-x-icu"
is 'Ewe';

alter collation pg_catalog."ee-x-icu"
  owner to postgres;

create collation pg_catalog."ee-GH-x-icu" (
  locale = 'ee-GH'
);

comment on collation pg_catalog."ee-GH-x-icu"
is 'Ewe (Ghana)';

alter collation pg_catalog."ee-GH-x-icu"
  owner to postgres;

create collation pg_catalog."ee-TG-x-icu" (
  locale = 'ee-TG'
);

comment on collation pg_catalog."ee-TG-x-icu"
is 'Ewe (Togo)';

alter collation pg_catalog."ee-TG-x-icu"
  owner to postgres;

create collation pg_catalog."el-x-icu" (
  locale = 'el'
);

comment on collation pg_catalog."el-x-icu"
is 'Greek';

alter collation pg_catalog."el-x-icu"
  owner to postgres;

create collation pg_catalog."el-CY-x-icu" (
  locale = 'el-CY'
);

comment on collation pg_catalog."el-CY-x-icu"
is 'Greek (Cyprus)';

alter collation pg_catalog."el-CY-x-icu"
  owner to postgres;

create collation pg_catalog."el-GR-x-icu" (
  locale = 'el-GR'
);

comment on collation pg_catalog."el-GR-x-icu"
is 'Greek (Greece)';

alter collation pg_catalog."el-GR-x-icu"
  owner to postgres;

create collation pg_catalog."en-x-icu" (
  locale = 'en'
);

comment on collation pg_catalog."en-x-icu"
is 'English';

alter collation pg_catalog."en-x-icu"
  owner to postgres;

create collation pg_catalog."en-001-x-icu" (
  locale = 'en-001'
);

comment on collation pg_catalog."en-001-x-icu"
is 'English (World)';

alter collation pg_catalog."en-001-x-icu"
  owner to postgres;

create collation pg_catalog."en-150-x-icu" (
  locale = 'en-150'
);

comment on collation pg_catalog."en-150-x-icu"
is 'English (Europe)';

alter collation pg_catalog."en-150-x-icu"
  owner to postgres;

create collation pg_catalog."en-AG-x-icu" (
  locale = 'en-AG'
);

comment on collation pg_catalog."en-AG-x-icu"
is 'English (Antigua & Barbuda)';

alter collation pg_catalog."en-AG-x-icu"
  owner to postgres;

create collation pg_catalog."en-AI-x-icu" (
  locale = 'en-AI'
);

comment on collation pg_catalog."en-AI-x-icu"
is 'English (Anguilla)';

alter collation pg_catalog."en-AI-x-icu"
  owner to postgres;

create collation pg_catalog."en-AS-x-icu" (
  locale = 'en-AS'
);

comment on collation pg_catalog."en-AS-x-icu"
is 'English (American Samoa)';

alter collation pg_catalog."en-AS-x-icu"
  owner to postgres;

create collation pg_catalog."en-AT-x-icu" (
  locale = 'en-AT'
);

comment on collation pg_catalog."en-AT-x-icu"
is 'English (Austria)';

alter collation pg_catalog."en-AT-x-icu"
  owner to postgres;

create collation pg_catalog."en-AU-x-icu" (
  locale = 'en-AU'
);

comment on collation pg_catalog."en-AU-x-icu"
is 'English (Australia)';

alter collation pg_catalog."en-AU-x-icu"
  owner to postgres;

create collation pg_catalog."en-BB-x-icu" (
  locale = 'en-BB'
);

comment on collation pg_catalog."en-BB-x-icu"
is 'English (Barbados)';

alter collation pg_catalog."en-BB-x-icu"
  owner to postgres;

create collation pg_catalog."en-BE-x-icu" (
  locale = 'en-BE'
);

comment on collation pg_catalog."en-BE-x-icu"
is 'English (Belgium)';

alter collation pg_catalog."en-BE-x-icu"
  owner to postgres;

create collation pg_catalog."en-BI-x-icu" (
  locale = 'en-BI'
);

comment on collation pg_catalog."en-BI-x-icu"
is 'English (Burundi)';

alter collation pg_catalog."en-BI-x-icu"
  owner to postgres;

create collation pg_catalog."en-BM-x-icu" (
  locale = 'en-BM'
);

comment on collation pg_catalog."en-BM-x-icu"
is 'English (Bermuda)';

alter collation pg_catalog."en-BM-x-icu"
  owner to postgres;

create collation pg_catalog."en-BS-x-icu" (
  locale = 'en-BS'
);

comment on collation pg_catalog."en-BS-x-icu"
is 'English (Bahamas)';

alter collation pg_catalog."en-BS-x-icu"
  owner to postgres;

create collation pg_catalog."en-BW-x-icu" (
  locale = 'en-BW'
);

comment on collation pg_catalog."en-BW-x-icu"
is 'English (Botswana)';

alter collation pg_catalog."en-BW-x-icu"
  owner to postgres;

create collation pg_catalog."en-BZ-x-icu" (
  locale = 'en-BZ'
);

comment on collation pg_catalog."en-BZ-x-icu"
is 'English (Belize)';

alter collation pg_catalog."en-BZ-x-icu"
  owner to postgres;

create collation pg_catalog."en-CA-x-icu" (
  locale = 'en-CA'
);

comment on collation pg_catalog."en-CA-x-icu"
is 'English (Canada)';

alter collation pg_catalog."en-CA-x-icu"
  owner to postgres;

create collation pg_catalog."en-CC-x-icu" (
  locale = 'en-CC'
);

comment on collation pg_catalog."en-CC-x-icu"
is 'English (Cocos [Keeling] Islands)';

alter collation pg_catalog."en-CC-x-icu"
  owner to postgres;

create collation pg_catalog."en-CH-x-icu" (
  locale = 'en-CH'
);

comment on collation pg_catalog."en-CH-x-icu"
is 'English (Switzerland)';

alter collation pg_catalog."en-CH-x-icu"
  owner to postgres;

create collation pg_catalog."en-CK-x-icu" (
  locale = 'en-CK'
);

comment on collation pg_catalog."en-CK-x-icu"
is 'English (Cook Islands)';

alter collation pg_catalog."en-CK-x-icu"
  owner to postgres;

create collation pg_catalog."en-CM-x-icu" (
  locale = 'en-CM'
);

comment on collation pg_catalog."en-CM-x-icu"
is 'English (Cameroon)';

alter collation pg_catalog."en-CM-x-icu"
  owner to postgres;

create collation pg_catalog."en-CX-x-icu" (
  locale = 'en-CX'
);

comment on collation pg_catalog."en-CX-x-icu"
is 'English (Christmas Island)';

alter collation pg_catalog."en-CX-x-icu"
  owner to postgres;

create collation pg_catalog."en-CY-x-icu" (
  locale = 'en-CY'
);

comment on collation pg_catalog."en-CY-x-icu"
is 'English (Cyprus)';

alter collation pg_catalog."en-CY-x-icu"
  owner to postgres;

create collation pg_catalog."en-DE-x-icu" (
  locale = 'en-DE'
);

comment on collation pg_catalog."en-DE-x-icu"
is 'English (Germany)';

alter collation pg_catalog."en-DE-x-icu"
  owner to postgres;

create collation pg_catalog."en-DG-x-icu" (
  locale = 'en-DG'
);

comment on collation pg_catalog."en-DG-x-icu"
is 'English (Diego Garcia)';

alter collation pg_catalog."en-DG-x-icu"
  owner to postgres;

create collation pg_catalog."en-DK-x-icu" (
  locale = 'en-DK'
);

comment on collation pg_catalog."en-DK-x-icu"
is 'English (Denmark)';

alter collation pg_catalog."en-DK-x-icu"
  owner to postgres;

create collation pg_catalog."en-DM-x-icu" (
  locale = 'en-DM'
);

comment on collation pg_catalog."en-DM-x-icu"
is 'English (Dominica)';

alter collation pg_catalog."en-DM-x-icu"
  owner to postgres;

create collation pg_catalog."en-ER-x-icu" (
  locale = 'en-ER'
);

comment on collation pg_catalog."en-ER-x-icu"
is 'English (Eritrea)';

alter collation pg_catalog."en-ER-x-icu"
  owner to postgres;

create collation pg_catalog."en-FI-x-icu" (
  locale = 'en-FI'
);

comment on collation pg_catalog."en-FI-x-icu"
is 'English (Finland)';

alter collation pg_catalog."en-FI-x-icu"
  owner to postgres;

create collation pg_catalog."en-FJ-x-icu" (
  locale = 'en-FJ'
);

comment on collation pg_catalog."en-FJ-x-icu"
is 'English (Fiji)';

alter collation pg_catalog."en-FJ-x-icu"
  owner to postgres;

create collation pg_catalog."en-FK-x-icu" (
  locale = 'en-FK'
);

comment on collation pg_catalog."en-FK-x-icu"
is 'English (Falkland Islands)';

alter collation pg_catalog."en-FK-x-icu"
  owner to postgres;

create collation pg_catalog."en-FM-x-icu" (
  locale = 'en-FM'
);

comment on collation pg_catalog."en-FM-x-icu"
is 'English (Micronesia)';

alter collation pg_catalog."en-FM-x-icu"
  owner to postgres;

create collation pg_catalog."en-GB-x-icu" (
  locale = 'en-GB'
);

comment on collation pg_catalog."en-GB-x-icu"
is 'English (United Kingdom)';

alter collation pg_catalog."en-GB-x-icu"
  owner to postgres;

create collation pg_catalog."en-GD-x-icu" (
  locale = 'en-GD'
);

comment on collation pg_catalog."en-GD-x-icu"
is 'English (Grenada)';

alter collation pg_catalog."en-GD-x-icu"
  owner to postgres;

create collation pg_catalog."en-GG-x-icu" (
  locale = 'en-GG'
);

comment on collation pg_catalog."en-GG-x-icu"
is 'English (Guernsey)';

alter collation pg_catalog."en-GG-x-icu"
  owner to postgres;

create collation pg_catalog."en-GH-x-icu" (
  locale = 'en-GH'
);

comment on collation pg_catalog."en-GH-x-icu"
is 'English (Ghana)';

alter collation pg_catalog."en-GH-x-icu"
  owner to postgres;

create collation pg_catalog."en-GI-x-icu" (
  locale = 'en-GI'
);

comment on collation pg_catalog."en-GI-x-icu"
is 'English (Gibraltar)';

alter collation pg_catalog."en-GI-x-icu"
  owner to postgres;

create collation pg_catalog."en-GM-x-icu" (
  locale = 'en-GM'
);

comment on collation pg_catalog."en-GM-x-icu"
is 'English (Gambia)';

alter collation pg_catalog."en-GM-x-icu"
  owner to postgres;

create collation pg_catalog."en-GU-x-icu" (
  locale = 'en-GU'
);

comment on collation pg_catalog."en-GU-x-icu"
is 'English (Guam)';

alter collation pg_catalog."en-GU-x-icu"
  owner to postgres;

create collation pg_catalog."en-GY-x-icu" (
  locale = 'en-GY'
);

comment on collation pg_catalog."en-GY-x-icu"
is 'English (Guyana)';

alter collation pg_catalog."en-GY-x-icu"
  owner to postgres;

create collation pg_catalog."en-HK-x-icu" (
  locale = 'en-HK'
);

comment on collation pg_catalog."en-HK-x-icu"
is 'English (Hong Kong SAR China)';

alter collation pg_catalog."en-HK-x-icu"
  owner to postgres;

create collation pg_catalog."en-IE-x-icu" (
  locale = 'en-IE'
);

comment on collation pg_catalog."en-IE-x-icu"
is 'English (Ireland)';

alter collation pg_catalog."en-IE-x-icu"
  owner to postgres;

create collation pg_catalog."en-IL-x-icu" (
  locale = 'en-IL'
);

comment on collation pg_catalog."en-IL-x-icu"
is 'English (Israel)';

alter collation pg_catalog."en-IL-x-icu"
  owner to postgres;

create collation pg_catalog."en-IM-x-icu" (
  locale = 'en-IM'
);

comment on collation pg_catalog."en-IM-x-icu"
is 'English (Isle of Man)';

alter collation pg_catalog."en-IM-x-icu"
  owner to postgres;

create collation pg_catalog."en-IN-x-icu" (
  locale = 'en-IN'
);

comment on collation pg_catalog."en-IN-x-icu"
is 'English (India)';

alter collation pg_catalog."en-IN-x-icu"
  owner to postgres;

create collation pg_catalog."en-IO-x-icu" (
  locale = 'en-IO'
);

comment on collation pg_catalog."en-IO-x-icu"
is 'English (British Indian Ocean Territory)';

alter collation pg_catalog."en-IO-x-icu"
  owner to postgres;

create collation pg_catalog."en-JE-x-icu" (
  locale = 'en-JE'
);

comment on collation pg_catalog."en-JE-x-icu"
is 'English (Jersey)';

alter collation pg_catalog."en-JE-x-icu"
  owner to postgres;

create collation pg_catalog."en-JM-x-icu" (
  locale = 'en-JM'
);

comment on collation pg_catalog."en-JM-x-icu"
is 'English (Jamaica)';

alter collation pg_catalog."en-JM-x-icu"
  owner to postgres;

create collation pg_catalog."en-KE-x-icu" (
  locale = 'en-KE'
);

comment on collation pg_catalog."en-KE-x-icu"
is 'English (Kenya)';

alter collation pg_catalog."en-KE-x-icu"
  owner to postgres;

create collation pg_catalog."en-KI-x-icu" (
  locale = 'en-KI'
);

comment on collation pg_catalog."en-KI-x-icu"
is 'English (Kiribati)';

alter collation pg_catalog."en-KI-x-icu"
  owner to postgres;

create collation pg_catalog."en-KN-x-icu" (
  locale = 'en-KN'
);

comment on collation pg_catalog."en-KN-x-icu"
is 'English (St. Kitts & Nevis)';

alter collation pg_catalog."en-KN-x-icu"
  owner to postgres;

create collation pg_catalog."en-KY-x-icu" (
  locale = 'en-KY'
);

comment on collation pg_catalog."en-KY-x-icu"
is 'English (Cayman Islands)';

alter collation pg_catalog."en-KY-x-icu"
  owner to postgres;

create collation pg_catalog."en-LC-x-icu" (
  locale = 'en-LC'
);

comment on collation pg_catalog."en-LC-x-icu"
is 'English (St. Lucia)';

alter collation pg_catalog."en-LC-x-icu"
  owner to postgres;

create collation pg_catalog."en-LR-x-icu" (
  locale = 'en-LR'
);

comment on collation pg_catalog."en-LR-x-icu"
is 'English (Liberia)';

alter collation pg_catalog."en-LR-x-icu"
  owner to postgres;

create collation pg_catalog."en-LS-x-icu" (
  locale = 'en-LS'
);

comment on collation pg_catalog."en-LS-x-icu"
is 'English (Lesotho)';

alter collation pg_catalog."en-LS-x-icu"
  owner to postgres;

create collation pg_catalog."en-MG-x-icu" (
  locale = 'en-MG'
);

comment on collation pg_catalog."en-MG-x-icu"
is 'English (Madagascar)';

alter collation pg_catalog."en-MG-x-icu"
  owner to postgres;

create collation pg_catalog."en-MH-x-icu" (
  locale = 'en-MH'
);

comment on collation pg_catalog."en-MH-x-icu"
is 'English (Marshall Islands)';

alter collation pg_catalog."en-MH-x-icu"
  owner to postgres;

create collation pg_catalog."en-MO-x-icu" (
  locale = 'en-MO'
);

comment on collation pg_catalog."en-MO-x-icu"
is 'English (Macau SAR China)';

alter collation pg_catalog."en-MO-x-icu"
  owner to postgres;

create collation pg_catalog."en-MP-x-icu" (
  locale = 'en-MP'
);

comment on collation pg_catalog."en-MP-x-icu"
is 'English (Northern Mariana Islands)';

alter collation pg_catalog."en-MP-x-icu"
  owner to postgres;

create collation pg_catalog."en-MS-x-icu" (
  locale = 'en-MS'
);

comment on collation pg_catalog."en-MS-x-icu"
is 'English (Montserrat)';

alter collation pg_catalog."en-MS-x-icu"
  owner to postgres;

create collation pg_catalog."en-MT-x-icu" (
  locale = 'en-MT'
);

comment on collation pg_catalog."en-MT-x-icu"
is 'English (Malta)';

alter collation pg_catalog."en-MT-x-icu"
  owner to postgres;

create collation pg_catalog."en-MU-x-icu" (
  locale = 'en-MU'
);

comment on collation pg_catalog."en-MU-x-icu"
is 'English (Mauritius)';

alter collation pg_catalog."en-MU-x-icu"
  owner to postgres;

create collation pg_catalog."en-MW-x-icu" (
  locale = 'en-MW'
);

comment on collation pg_catalog."en-MW-x-icu"
is 'English (Malawi)';

alter collation pg_catalog."en-MW-x-icu"
  owner to postgres;

create collation pg_catalog."en-MY-x-icu" (
  locale = 'en-MY'
);

comment on collation pg_catalog."en-MY-x-icu"
is 'English (Malaysia)';

alter collation pg_catalog."en-MY-x-icu"
  owner to postgres;

create collation pg_catalog."en-NA-x-icu" (
  locale = 'en-NA'
);

comment on collation pg_catalog."en-NA-x-icu"
is 'English (Namibia)';

alter collation pg_catalog."en-NA-x-icu"
  owner to postgres;

create collation pg_catalog."en-NF-x-icu" (
  locale = 'en-NF'
);

comment on collation pg_catalog."en-NF-x-icu"
is 'English (Norfolk Island)';

alter collation pg_catalog."en-NF-x-icu"
  owner to postgres;

create collation pg_catalog."en-NG-x-icu" (
  locale = 'en-NG'
);

comment on collation pg_catalog."en-NG-x-icu"
is 'English (Nigeria)';

alter collation pg_catalog."en-NG-x-icu"
  owner to postgres;

create collation pg_catalog."en-NL-x-icu" (
  locale = 'en-NL'
);

comment on collation pg_catalog."en-NL-x-icu"
is 'English (Netherlands)';

alter collation pg_catalog."en-NL-x-icu"
  owner to postgres;

create collation pg_catalog."en-NR-x-icu" (
  locale = 'en-NR'
);

comment on collation pg_catalog."en-NR-x-icu"
is 'English (Nauru)';

alter collation pg_catalog."en-NR-x-icu"
  owner to postgres;

create collation pg_catalog."en-NU-x-icu" (
  locale = 'en-NU'
);

comment on collation pg_catalog."en-NU-x-icu"
is 'English (Niue)';

alter collation pg_catalog."en-NU-x-icu"
  owner to postgres;

create collation pg_catalog."en-NZ-x-icu" (
  locale = 'en-NZ'
);

comment on collation pg_catalog."en-NZ-x-icu"
is 'English (New Zealand)';

alter collation pg_catalog."en-NZ-x-icu"
  owner to postgres;

create collation pg_catalog."en-PG-x-icu" (
  locale = 'en-PG'
);

comment on collation pg_catalog."en-PG-x-icu"
is 'English (Papua New Guinea)';

alter collation pg_catalog."en-PG-x-icu"
  owner to postgres;

create collation pg_catalog."en-PH-x-icu" (
  locale = 'en-PH'
);

comment on collation pg_catalog."en-PH-x-icu"
is 'English (Philippines)';

alter collation pg_catalog."en-PH-x-icu"
  owner to postgres;

create collation pg_catalog."en-PK-x-icu" (
  locale = 'en-PK'
);

comment on collation pg_catalog."en-PK-x-icu"
is 'English (Pakistan)';

alter collation pg_catalog."en-PK-x-icu"
  owner to postgres;

create collation pg_catalog."en-PN-x-icu" (
  locale = 'en-PN'
);

comment on collation pg_catalog."en-PN-x-icu"
is 'English (Pitcairn Islands)';

alter collation pg_catalog."en-PN-x-icu"
  owner to postgres;

create collation pg_catalog."en-PR-x-icu" (
  locale = 'en-PR'
);

comment on collation pg_catalog."en-PR-x-icu"
is 'English (Puerto Rico)';

alter collation pg_catalog."en-PR-x-icu"
  owner to postgres;

create collation pg_catalog."en-PW-x-icu" (
  locale = 'en-PW'
);

comment on collation pg_catalog."en-PW-x-icu"
is 'English (Palau)';

alter collation pg_catalog."en-PW-x-icu"
  owner to postgres;

create collation pg_catalog."en-RW-x-icu" (
  locale = 'en-RW'
);

comment on collation pg_catalog."en-RW-x-icu"
is 'English (Rwanda)';

alter collation pg_catalog."en-RW-x-icu"
  owner to postgres;

create collation pg_catalog."en-SB-x-icu" (
  locale = 'en-SB'
);

comment on collation pg_catalog."en-SB-x-icu"
is 'English (Solomon Islands)';

alter collation pg_catalog."en-SB-x-icu"
  owner to postgres;

create collation pg_catalog."en-SC-x-icu" (
  locale = 'en-SC'
);

comment on collation pg_catalog."en-SC-x-icu"
is 'English (Seychelles)';

alter collation pg_catalog."en-SC-x-icu"
  owner to postgres;

create collation pg_catalog."en-SD-x-icu" (
  locale = 'en-SD'
);

comment on collation pg_catalog."en-SD-x-icu"
is 'English (Sudan)';

alter collation pg_catalog."en-SD-x-icu"
  owner to postgres;

create collation pg_catalog."en-SE-x-icu" (
  locale = 'en-SE'
);

comment on collation pg_catalog."en-SE-x-icu"
is 'English (Sweden)';

alter collation pg_catalog."en-SE-x-icu"
  owner to postgres;

create collation pg_catalog."en-SG-x-icu" (
  locale = 'en-SG'
);

comment on collation pg_catalog."en-SG-x-icu"
is 'English (Singapore)';

alter collation pg_catalog."en-SG-x-icu"
  owner to postgres;

create collation pg_catalog."en-SH-x-icu" (
  locale = 'en-SH'
);

comment on collation pg_catalog."en-SH-x-icu"
is 'English (St. Helena)';

alter collation pg_catalog."en-SH-x-icu"
  owner to postgres;

create collation pg_catalog."en-SI-x-icu" (
  locale = 'en-SI'
);

comment on collation pg_catalog."en-SI-x-icu"
is 'English (Slovenia)';

alter collation pg_catalog."en-SI-x-icu"
  owner to postgres;

create collation pg_catalog."en-SL-x-icu" (
  locale = 'en-SL'
);

comment on collation pg_catalog."en-SL-x-icu"
is 'English (Sierra Leone)';

alter collation pg_catalog."en-SL-x-icu"
  owner to postgres;

create collation pg_catalog."en-SS-x-icu" (
  locale = 'en-SS'
);

comment on collation pg_catalog."en-SS-x-icu"
is 'English (South Sudan)';

alter collation pg_catalog."en-SS-x-icu"
  owner to postgres;

create collation pg_catalog."en-SX-x-icu" (
  locale = 'en-SX'
);

comment on collation pg_catalog."en-SX-x-icu"
is 'English (Sint Maarten)';

alter collation pg_catalog."en-SX-x-icu"
  owner to postgres;

create collation pg_catalog."en-SZ-x-icu" (
  locale = 'en-SZ'
);

comment on collation pg_catalog."en-SZ-x-icu"
is 'English (Swaziland)';

alter collation pg_catalog."en-SZ-x-icu"
  owner to postgres;

create collation pg_catalog."en-TC-x-icu" (
  locale = 'en-TC'
);

comment on collation pg_catalog."en-TC-x-icu"
is 'English (Turks & Caicos Islands)';

alter collation pg_catalog."en-TC-x-icu"
  owner to postgres;

create collation pg_catalog."en-TK-x-icu" (
  locale = 'en-TK'
);

comment on collation pg_catalog."en-TK-x-icu"
is 'English (Tokelau)';

alter collation pg_catalog."en-TK-x-icu"
  owner to postgres;

create collation pg_catalog."en-TO-x-icu" (
  locale = 'en-TO'
);

comment on collation pg_catalog."en-TO-x-icu"
is 'English (Tonga)';

alter collation pg_catalog."en-TO-x-icu"
  owner to postgres;

create collation pg_catalog."en-TT-x-icu" (
  locale = 'en-TT'
);

comment on collation pg_catalog."en-TT-x-icu"
is 'English (Trinidad & Tobago)';

alter collation pg_catalog."en-TT-x-icu"
  owner to postgres;

create collation pg_catalog."en-TV-x-icu" (
  locale = 'en-TV'
);

comment on collation pg_catalog."en-TV-x-icu"
is 'English (Tuvalu)';

alter collation pg_catalog."en-TV-x-icu"
  owner to postgres;

create collation pg_catalog."en-TZ-x-icu" (
  locale = 'en-TZ'
);

comment on collation pg_catalog."en-TZ-x-icu"
is 'English (Tanzania)';

alter collation pg_catalog."en-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."en-UG-x-icu" (
  locale = 'en-UG'
);

comment on collation pg_catalog."en-UG-x-icu"
is 'English (Uganda)';

alter collation pg_catalog."en-UG-x-icu"
  owner to postgres;

create collation pg_catalog."en-UM-x-icu" (
  locale = 'en-UM'
);

comment on collation pg_catalog."en-UM-x-icu"
is 'English (U.S. Outlying Islands)';

alter collation pg_catalog."en-UM-x-icu"
  owner to postgres;

create collation pg_catalog."en-US-x-icu" (
  locale = 'en-US'
);

comment on collation pg_catalog."en-US-x-icu"
is 'English (United States)';

alter collation pg_catalog."en-US-x-icu"
  owner to postgres;

create collation pg_catalog."en-US-u-va-posix-x-icu" (
  locale = 'en-US-u-va-posix'
);

comment on collation pg_catalog."en-US-u-va-posix-x-icu"
is 'English (United States, Computer)';

alter collation pg_catalog."en-US-u-va-posix-x-icu"
  owner to postgres;

create collation pg_catalog."en-VC-x-icu" (
  locale = 'en-VC'
);

comment on collation pg_catalog."en-VC-x-icu"
is 'English (St. Vincent & Grenadines)';

alter collation pg_catalog."en-VC-x-icu"
  owner to postgres;

create collation pg_catalog."en-VG-x-icu" (
  locale = 'en-VG'
);

comment on collation pg_catalog."en-VG-x-icu"
is 'English (British Virgin Islands)';

alter collation pg_catalog."en-VG-x-icu"
  owner to postgres;

create collation pg_catalog."en-VI-x-icu" (
  locale = 'en-VI'
);

comment on collation pg_catalog."en-VI-x-icu"
is 'English (U.S. Virgin Islands)';

alter collation pg_catalog."en-VI-x-icu"
  owner to postgres;

create collation pg_catalog."en-VU-x-icu" (
  locale = 'en-VU'
);

comment on collation pg_catalog."en-VU-x-icu"
is 'English (Vanuatu)';

alter collation pg_catalog."en-VU-x-icu"
  owner to postgres;

create collation pg_catalog."en-WS-x-icu" (
  locale = 'en-WS'
);

comment on collation pg_catalog."en-WS-x-icu"
is 'English (Samoa)';

alter collation pg_catalog."en-WS-x-icu"
  owner to postgres;

create collation pg_catalog."en-ZA-x-icu" (
  locale = 'en-ZA'
);

comment on collation pg_catalog."en-ZA-x-icu"
is 'English (South Africa)';

alter collation pg_catalog."en-ZA-x-icu"
  owner to postgres;

create collation pg_catalog."en-ZM-x-icu" (
  locale = 'en-ZM'
);

comment on collation pg_catalog."en-ZM-x-icu"
is 'English (Zambia)';

alter collation pg_catalog."en-ZM-x-icu"
  owner to postgres;

create collation pg_catalog."en-ZW-x-icu" (
  locale = 'en-ZW'
);

comment on collation pg_catalog."en-ZW-x-icu"
is 'English (Zimbabwe)';

alter collation pg_catalog."en-ZW-x-icu"
  owner to postgres;

create collation pg_catalog."eo-x-icu" (
  locale = 'eo'
);

comment on collation pg_catalog."eo-x-icu"
is 'Esperanto';

alter collation pg_catalog."eo-x-icu"
  owner to postgres;

create collation pg_catalog."es-x-icu" (
  locale = 'es'
);

comment on collation pg_catalog."es-x-icu"
is 'Spanish';

alter collation pg_catalog."es-x-icu"
  owner to postgres;

create collation pg_catalog."es-419-x-icu" (
  locale = 'es-419'
);

comment on collation pg_catalog."es-419-x-icu"
is 'Spanish (Latin America)';

alter collation pg_catalog."es-419-x-icu"
  owner to postgres;

create collation pg_catalog."es-AR-x-icu" (
  locale = 'es-AR'
);

comment on collation pg_catalog."es-AR-x-icu"
is 'Spanish (Argentina)';

alter collation pg_catalog."es-AR-x-icu"
  owner to postgres;

create collation pg_catalog."es-BO-x-icu" (
  locale = 'es-BO'
);

comment on collation pg_catalog."es-BO-x-icu"
is 'Spanish (Bolivia)';

alter collation pg_catalog."es-BO-x-icu"
  owner to postgres;

create collation pg_catalog."es-CL-x-icu" (
  locale = 'es-CL'
);

comment on collation pg_catalog."es-CL-x-icu"
is 'Spanish (Chile)';

alter collation pg_catalog."es-CL-x-icu"
  owner to postgres;

create collation pg_catalog."es-CO-x-icu" (
  locale = 'es-CO'
);

comment on collation pg_catalog."es-CO-x-icu"
is 'Spanish (Colombia)';

alter collation pg_catalog."es-CO-x-icu"
  owner to postgres;

create collation pg_catalog."es-CR-x-icu" (
  locale = 'es-CR'
);

comment on collation pg_catalog."es-CR-x-icu"
is 'Spanish (Costa Rica)';

alter collation pg_catalog."es-CR-x-icu"
  owner to postgres;

create collation pg_catalog."es-CU-x-icu" (
  locale = 'es-CU'
);

comment on collation pg_catalog."es-CU-x-icu"
is 'Spanish (Cuba)';

alter collation pg_catalog."es-CU-x-icu"
  owner to postgres;

create collation pg_catalog."es-DO-x-icu" (
  locale = 'es-DO'
);

comment on collation pg_catalog."es-DO-x-icu"
is 'Spanish (Dominican Republic)';

alter collation pg_catalog."es-DO-x-icu"
  owner to postgres;

create collation pg_catalog."es-EA-x-icu" (
  locale = 'es-EA'
);

comment on collation pg_catalog."es-EA-x-icu"
is 'Spanish (Ceuta & Melilla)';

alter collation pg_catalog."es-EA-x-icu"
  owner to postgres;

create collation pg_catalog."es-EC-x-icu" (
  locale = 'es-EC'
);

comment on collation pg_catalog."es-EC-x-icu"
is 'Spanish (Ecuador)';

alter collation pg_catalog."es-EC-x-icu"
  owner to postgres;

create collation pg_catalog."es-ES-x-icu" (
  locale = 'es-ES'
);

comment on collation pg_catalog."es-ES-x-icu"
is 'Spanish (Spain)';

alter collation pg_catalog."es-ES-x-icu"
  owner to postgres;

create collation pg_catalog."es-GQ-x-icu" (
  locale = 'es-GQ'
);

comment on collation pg_catalog."es-GQ-x-icu"
is 'Spanish (Equatorial Guinea)';

alter collation pg_catalog."es-GQ-x-icu"
  owner to postgres;

create collation pg_catalog."es-GT-x-icu" (
  locale = 'es-GT'
);

comment on collation pg_catalog."es-GT-x-icu"
is 'Spanish (Guatemala)';

alter collation pg_catalog."es-GT-x-icu"
  owner to postgres;

create collation pg_catalog."es-HN-x-icu" (
  locale = 'es-HN'
);

comment on collation pg_catalog."es-HN-x-icu"
is 'Spanish (Honduras)';

alter collation pg_catalog."es-HN-x-icu"
  owner to postgres;

create collation pg_catalog."es-IC-x-icu" (
  locale = 'es-IC'
);

comment on collation pg_catalog."es-IC-x-icu"
is 'Spanish (Canary Islands)';

alter collation pg_catalog."es-IC-x-icu"
  owner to postgres;

create collation pg_catalog."es-MX-x-icu" (
  locale = 'es-MX'
);

comment on collation pg_catalog."es-MX-x-icu"
is 'Spanish (Mexico)';

alter collation pg_catalog."es-MX-x-icu"
  owner to postgres;

create collation pg_catalog."es-NI-x-icu" (
  locale = 'es-NI'
);

comment on collation pg_catalog."es-NI-x-icu"
is 'Spanish (Nicaragua)';

alter collation pg_catalog."es-NI-x-icu"
  owner to postgres;

create collation pg_catalog."es-PA-x-icu" (
  locale = 'es-PA'
);

comment on collation pg_catalog."es-PA-x-icu"
is 'Spanish (Panama)';

alter collation pg_catalog."es-PA-x-icu"
  owner to postgres;

create collation pg_catalog."es-PE-x-icu" (
  locale = 'es-PE'
);

comment on collation pg_catalog."es-PE-x-icu"
is 'Spanish (Peru)';

alter collation pg_catalog."es-PE-x-icu"
  owner to postgres;

create collation pg_catalog."es-PH-x-icu" (
  locale = 'es-PH'
);

comment on collation pg_catalog."es-PH-x-icu"
is 'Spanish (Philippines)';

alter collation pg_catalog."es-PH-x-icu"
  owner to postgres;

create collation pg_catalog."es-PR-x-icu" (
  locale = 'es-PR'
);

comment on collation pg_catalog."es-PR-x-icu"
is 'Spanish (Puerto Rico)';

alter collation pg_catalog."es-PR-x-icu"
  owner to postgres;

create collation pg_catalog."es-PY-x-icu" (
  locale = 'es-PY'
);

comment on collation pg_catalog."es-PY-x-icu"
is 'Spanish (Paraguay)';

alter collation pg_catalog."es-PY-x-icu"
  owner to postgres;

create collation pg_catalog."es-SV-x-icu" (
  locale = 'es-SV'
);

comment on collation pg_catalog."es-SV-x-icu"
is 'Spanish (El Salvador)';

alter collation pg_catalog."es-SV-x-icu"
  owner to postgres;

create collation pg_catalog."es-US-x-icu" (
  locale = 'es-US'
);

comment on collation pg_catalog."es-US-x-icu"
is 'Spanish (United States)';

alter collation pg_catalog."es-US-x-icu"
  owner to postgres;

create collation pg_catalog."es-UY-x-icu" (
  locale = 'es-UY'
);

comment on collation pg_catalog."es-UY-x-icu"
is 'Spanish (Uruguay)';

alter collation pg_catalog."es-UY-x-icu"
  owner to postgres;

create collation pg_catalog."es-VE-x-icu" (
  locale = 'es-VE'
);

comment on collation pg_catalog."es-VE-x-icu"
is 'Spanish (Venezuela)';

alter collation pg_catalog."es-VE-x-icu"
  owner to postgres;

create collation pg_catalog."et-x-icu" (
  locale = 'et'
);

comment on collation pg_catalog."et-x-icu"
is 'Estonian';

alter collation pg_catalog."et-x-icu"
  owner to postgres;

create collation pg_catalog."et-EE-x-icu" (
  locale = 'et-EE'
);

comment on collation pg_catalog."et-EE-x-icu"
is 'Estonian (Estonia)';

alter collation pg_catalog."et-EE-x-icu"
  owner to postgres;

create collation pg_catalog."eu-x-icu" (
  locale = 'eu'
);

comment on collation pg_catalog."eu-x-icu"
is 'Basque';

alter collation pg_catalog."eu-x-icu"
  owner to postgres;

create collation pg_catalog."eu-ES-x-icu" (
  locale = 'eu-ES'
);

comment on collation pg_catalog."eu-ES-x-icu"
is 'Basque (Spain)';

alter collation pg_catalog."eu-ES-x-icu"
  owner to postgres;

create collation pg_catalog."ewo-x-icu" (
  locale = 'ewo'
);

comment on collation pg_catalog."ewo-x-icu"
is 'Ewondo';

alter collation pg_catalog."ewo-x-icu"
  owner to postgres;

create collation pg_catalog."ewo-CM-x-icu" (
  locale = 'ewo-CM'
);

comment on collation pg_catalog."ewo-CM-x-icu"
is 'Ewondo (Cameroon)';

alter collation pg_catalog."ewo-CM-x-icu"
  owner to postgres;

create collation pg_catalog."fa-x-icu" (
  locale = 'fa'
);

comment on collation pg_catalog."fa-x-icu"
is 'Persian';

alter collation pg_catalog."fa-x-icu"
  owner to postgres;

create collation pg_catalog."fa-AF-x-icu" (
  locale = 'fa-AF'
);

comment on collation pg_catalog."fa-AF-x-icu"
is 'Persian (Afghanistan)';

alter collation pg_catalog."fa-AF-x-icu"
  owner to postgres;

create collation pg_catalog."fa-IR-x-icu" (
  locale = 'fa-IR'
);

comment on collation pg_catalog."fa-IR-x-icu"
is 'Persian (Iran)';

alter collation pg_catalog."fa-IR-x-icu"
  owner to postgres;

create collation pg_catalog."ff-x-icu" (
  locale = 'ff'
);

comment on collation pg_catalog."ff-x-icu"
is 'Fulah';

alter collation pg_catalog."ff-x-icu"
  owner to postgres;

create collation pg_catalog."ff-CM-x-icu" (
  locale = 'ff-CM'
);

comment on collation pg_catalog."ff-CM-x-icu"
is 'Fulah (Cameroon)';

alter collation pg_catalog."ff-CM-x-icu"
  owner to postgres;

create collation pg_catalog."ff-GN-x-icu" (
  locale = 'ff-GN'
);

comment on collation pg_catalog."ff-GN-x-icu"
is 'Fulah (Guinea)';

alter collation pg_catalog."ff-GN-x-icu"
  owner to postgres;

create collation pg_catalog."ff-MR-x-icu" (
  locale = 'ff-MR'
);

comment on collation pg_catalog."ff-MR-x-icu"
is 'Fulah (Mauritania)';

alter collation pg_catalog."ff-MR-x-icu"
  owner to postgres;

create collation pg_catalog."ff-SN-x-icu" (
  locale = 'ff-SN'
);

comment on collation pg_catalog."ff-SN-x-icu"
is 'Fulah (Senegal)';

alter collation pg_catalog."ff-SN-x-icu"
  owner to postgres;

create collation pg_catalog."fi-x-icu" (
  locale = 'fi'
);

comment on collation pg_catalog."fi-x-icu"
is 'Finnish';

alter collation pg_catalog."fi-x-icu"
  owner to postgres;

create collation pg_catalog."fi-FI-x-icu" (
  locale = 'fi-FI'
);

comment on collation pg_catalog."fi-FI-x-icu"
is 'Finnish (Finland)';

alter collation pg_catalog."fi-FI-x-icu"
  owner to postgres;

create collation pg_catalog."fil-x-icu" (
  locale = 'fil'
);

comment on collation pg_catalog."fil-x-icu"
is 'Filipino';

alter collation pg_catalog."fil-x-icu"
  owner to postgres;

create collation pg_catalog."fil-PH-x-icu" (
  locale = 'fil-PH'
);

comment on collation pg_catalog."fil-PH-x-icu"
is 'Filipino (Philippines)';

alter collation pg_catalog."fil-PH-x-icu"
  owner to postgres;

create collation pg_catalog."fo-x-icu" (
  locale = 'fo'
);

comment on collation pg_catalog."fo-x-icu"
is 'Faroese';

alter collation pg_catalog."fo-x-icu"
  owner to postgres;

create collation pg_catalog."fo-DK-x-icu" (
  locale = 'fo-DK'
);

comment on collation pg_catalog."fo-DK-x-icu"
is 'Faroese (Denmark)';

alter collation pg_catalog."fo-DK-x-icu"
  owner to postgres;

create collation pg_catalog."fo-FO-x-icu" (
  locale = 'fo-FO'
);

comment on collation pg_catalog."fo-FO-x-icu"
is 'Faroese (Faroe Islands)';

alter collation pg_catalog."fo-FO-x-icu"
  owner to postgres;

create collation pg_catalog."fr-x-icu" (
  locale = 'fr'
);

comment on collation pg_catalog."fr-x-icu"
is 'French';

alter collation pg_catalog."fr-x-icu"
  owner to postgres;

create collation pg_catalog."fr-BE-x-icu" (
  locale = 'fr-BE'
);

comment on collation pg_catalog."fr-BE-x-icu"
is 'French (Belgium)';

alter collation pg_catalog."fr-BE-x-icu"
  owner to postgres;

create collation pg_catalog."fr-BF-x-icu" (
  locale = 'fr-BF'
);

comment on collation pg_catalog."fr-BF-x-icu"
is 'French (Burkina Faso)';

alter collation pg_catalog."fr-BF-x-icu"
  owner to postgres;

create collation pg_catalog."fr-BI-x-icu" (
  locale = 'fr-BI'
);

comment on collation pg_catalog."fr-BI-x-icu"
is 'French (Burundi)';

alter collation pg_catalog."fr-BI-x-icu"
  owner to postgres;

create collation pg_catalog."fr-BJ-x-icu" (
  locale = 'fr-BJ'
);

comment on collation pg_catalog."fr-BJ-x-icu"
is 'French (Benin)';

alter collation pg_catalog."fr-BJ-x-icu"
  owner to postgres;

create collation pg_catalog."fr-BL-x-icu" (
  locale = 'fr-BL'
);

alter collation pg_catalog."fr-BL-x-icu"
  owner to postgres;

create collation pg_catalog."fr-CA-x-icu" (
  locale = 'fr-CA'
);

comment on collation pg_catalog."fr-CA-x-icu"
is 'French (Canada)';

alter collation pg_catalog."fr-CA-x-icu"
  owner to postgres;

create collation pg_catalog."fr-CD-x-icu" (
  locale = 'fr-CD'
);

comment on collation pg_catalog."fr-CD-x-icu"
is 'French (Congo - Kinshasa)';

alter collation pg_catalog."fr-CD-x-icu"
  owner to postgres;

create collation pg_catalog."fr-CF-x-icu" (
  locale = 'fr-CF'
);

comment on collation pg_catalog."fr-CF-x-icu"
is 'French (Central African Republic)';

alter collation pg_catalog."fr-CF-x-icu"
  owner to postgres;

create collation pg_catalog."fr-CG-x-icu" (
  locale = 'fr-CG'
);

comment on collation pg_catalog."fr-CG-x-icu"
is 'French (Congo - Brazzaville)';

alter collation pg_catalog."fr-CG-x-icu"
  owner to postgres;

create collation pg_catalog."fr-CH-x-icu" (
  locale = 'fr-CH'
);

comment on collation pg_catalog."fr-CH-x-icu"
is 'French (Switzerland)';

alter collation pg_catalog."fr-CH-x-icu"
  owner to postgres;

create collation pg_catalog."fr-CI-x-icu" (
  locale = 'fr-CI'
);

alter collation pg_catalog."fr-CI-x-icu"
  owner to postgres;

create collation pg_catalog."fr-CM-x-icu" (
  locale = 'fr-CM'
);

comment on collation pg_catalog."fr-CM-x-icu"
is 'French (Cameroon)';

alter collation pg_catalog."fr-CM-x-icu"
  owner to postgres;

create collation pg_catalog."fr-DJ-x-icu" (
  locale = 'fr-DJ'
);

comment on collation pg_catalog."fr-DJ-x-icu"
is 'French (Djibouti)';

alter collation pg_catalog."fr-DJ-x-icu"
  owner to postgres;

create collation pg_catalog."fr-DZ-x-icu" (
  locale = 'fr-DZ'
);

comment on collation pg_catalog."fr-DZ-x-icu"
is 'French (Algeria)';

alter collation pg_catalog."fr-DZ-x-icu"
  owner to postgres;

create collation pg_catalog."fr-FR-x-icu" (
  locale = 'fr-FR'
);

comment on collation pg_catalog."fr-FR-x-icu"
is 'French (France)';

alter collation pg_catalog."fr-FR-x-icu"
  owner to postgres;

create collation pg_catalog."fr-GA-x-icu" (
  locale = 'fr-GA'
);

comment on collation pg_catalog."fr-GA-x-icu"
is 'French (Gabon)';

alter collation pg_catalog."fr-GA-x-icu"
  owner to postgres;

create collation pg_catalog."fr-GF-x-icu" (
  locale = 'fr-GF'
);

comment on collation pg_catalog."fr-GF-x-icu"
is 'French (French Guiana)';

alter collation pg_catalog."fr-GF-x-icu"
  owner to postgres;

create collation pg_catalog."fr-GN-x-icu" (
  locale = 'fr-GN'
);

comment on collation pg_catalog."fr-GN-x-icu"
is 'French (Guinea)';

alter collation pg_catalog."fr-GN-x-icu"
  owner to postgres;

create collation pg_catalog."fr-GP-x-icu" (
  locale = 'fr-GP'
);

comment on collation pg_catalog."fr-GP-x-icu"
is 'French (Guadeloupe)';

alter collation pg_catalog."fr-GP-x-icu"
  owner to postgres;

create collation pg_catalog."fr-GQ-x-icu" (
  locale = 'fr-GQ'
);

comment on collation pg_catalog."fr-GQ-x-icu"
is 'French (Equatorial Guinea)';

alter collation pg_catalog."fr-GQ-x-icu"
  owner to postgres;

create collation pg_catalog."fr-HT-x-icu" (
  locale = 'fr-HT'
);

comment on collation pg_catalog."fr-HT-x-icu"
is 'French (Haiti)';

alter collation pg_catalog."fr-HT-x-icu"
  owner to postgres;

create collation pg_catalog."fr-KM-x-icu" (
  locale = 'fr-KM'
);

comment on collation pg_catalog."fr-KM-x-icu"
is 'French (Comoros)';

alter collation pg_catalog."fr-KM-x-icu"
  owner to postgres;

create collation pg_catalog."fr-LU-x-icu" (
  locale = 'fr-LU'
);

comment on collation pg_catalog."fr-LU-x-icu"
is 'French (Luxembourg)';

alter collation pg_catalog."fr-LU-x-icu"
  owner to postgres;

create collation pg_catalog."fr-MA-x-icu" (
  locale = 'fr-MA'
);

comment on collation pg_catalog."fr-MA-x-icu"
is 'French (Morocco)';

alter collation pg_catalog."fr-MA-x-icu"
  owner to postgres;

create collation pg_catalog."fr-MC-x-icu" (
  locale = 'fr-MC'
);

comment on collation pg_catalog."fr-MC-x-icu"
is 'French (Monaco)';

alter collation pg_catalog."fr-MC-x-icu"
  owner to postgres;

create collation pg_catalog."fr-MF-x-icu" (
  locale = 'fr-MF'
);

comment on collation pg_catalog."fr-MF-x-icu"
is 'French (St. Martin)';

alter collation pg_catalog."fr-MF-x-icu"
  owner to postgres;

create collation pg_catalog."fr-MG-x-icu" (
  locale = 'fr-MG'
);

comment on collation pg_catalog."fr-MG-x-icu"
is 'French (Madagascar)';

alter collation pg_catalog."fr-MG-x-icu"
  owner to postgres;

create collation pg_catalog."fr-ML-x-icu" (
  locale = 'fr-ML'
);

comment on collation pg_catalog."fr-ML-x-icu"
is 'French (Mali)';

alter collation pg_catalog."fr-ML-x-icu"
  owner to postgres;

create collation pg_catalog."fr-MQ-x-icu" (
  locale = 'fr-MQ'
);

comment on collation pg_catalog."fr-MQ-x-icu"
is 'French (Martinique)';

alter collation pg_catalog."fr-MQ-x-icu"
  owner to postgres;

create collation pg_catalog."fr-MR-x-icu" (
  locale = 'fr-MR'
);

comment on collation pg_catalog."fr-MR-x-icu"
is 'French (Mauritania)';

alter collation pg_catalog."fr-MR-x-icu"
  owner to postgres;

create collation pg_catalog."fr-MU-x-icu" (
  locale = 'fr-MU'
);

comment on collation pg_catalog."fr-MU-x-icu"
is 'French (Mauritius)';

alter collation pg_catalog."fr-MU-x-icu"
  owner to postgres;

create collation pg_catalog."fr-NC-x-icu" (
  locale = 'fr-NC'
);

comment on collation pg_catalog."fr-NC-x-icu"
is 'French (New Caledonia)';

alter collation pg_catalog."fr-NC-x-icu"
  owner to postgres;

create collation pg_catalog."fr-NE-x-icu" (
  locale = 'fr-NE'
);

comment on collation pg_catalog."fr-NE-x-icu"
is 'French (Niger)';

alter collation pg_catalog."fr-NE-x-icu"
  owner to postgres;

create collation pg_catalog."fr-PF-x-icu" (
  locale = 'fr-PF'
);

comment on collation pg_catalog."fr-PF-x-icu"
is 'French (French Polynesia)';

alter collation pg_catalog."fr-PF-x-icu"
  owner to postgres;

create collation pg_catalog."fr-PM-x-icu" (
  locale = 'fr-PM'
);

comment on collation pg_catalog."fr-PM-x-icu"
is 'French (St. Pierre & Miquelon)';

alter collation pg_catalog."fr-PM-x-icu"
  owner to postgres;

create collation pg_catalog."fr-RE-x-icu" (
  locale = 'fr-RE'
);

alter collation pg_catalog."fr-RE-x-icu"
  owner to postgres;

create collation pg_catalog."fr-RW-x-icu" (
  locale = 'fr-RW'
);

comment on collation pg_catalog."fr-RW-x-icu"
is 'French (Rwanda)';

alter collation pg_catalog."fr-RW-x-icu"
  owner to postgres;

create collation pg_catalog."fr-SC-x-icu" (
  locale = 'fr-SC'
);

comment on collation pg_catalog."fr-SC-x-icu"
is 'French (Seychelles)';

alter collation pg_catalog."fr-SC-x-icu"
  owner to postgres;

create collation pg_catalog."fr-SN-x-icu" (
  locale = 'fr-SN'
);

comment on collation pg_catalog."fr-SN-x-icu"
is 'French (Senegal)';

alter collation pg_catalog."fr-SN-x-icu"
  owner to postgres;

create collation pg_catalog."fr-SY-x-icu" (
  locale = 'fr-SY'
);

comment on collation pg_catalog."fr-SY-x-icu"
is 'French (Syria)';

alter collation pg_catalog."fr-SY-x-icu"
  owner to postgres;

create collation pg_catalog."fr-TD-x-icu" (
  locale = 'fr-TD'
);

comment on collation pg_catalog."fr-TD-x-icu"
is 'French (Chad)';

alter collation pg_catalog."fr-TD-x-icu"
  owner to postgres;

create collation pg_catalog."fr-TG-x-icu" (
  locale = 'fr-TG'
);

comment on collation pg_catalog."fr-TG-x-icu"
is 'French (Togo)';

alter collation pg_catalog."fr-TG-x-icu"
  owner to postgres;

create collation pg_catalog."fr-TN-x-icu" (
  locale = 'fr-TN'
);

comment on collation pg_catalog."fr-TN-x-icu"
is 'French (Tunisia)';

alter collation pg_catalog."fr-TN-x-icu"
  owner to postgres;

create collation pg_catalog."fr-VU-x-icu" (
  locale = 'fr-VU'
);

comment on collation pg_catalog."fr-VU-x-icu"
is 'French (Vanuatu)';

alter collation pg_catalog."fr-VU-x-icu"
  owner to postgres;

create collation pg_catalog."fr-WF-x-icu" (
  locale = 'fr-WF'
);

comment on collation pg_catalog."fr-WF-x-icu"
is 'French (Wallis & Futuna)';

alter collation pg_catalog."fr-WF-x-icu"
  owner to postgres;

create collation pg_catalog."fr-YT-x-icu" (
  locale = 'fr-YT'
);

comment on collation pg_catalog."fr-YT-x-icu"
is 'French (Mayotte)';

alter collation pg_catalog."fr-YT-x-icu"
  owner to postgres;

create collation pg_catalog."fur-x-icu" (
  locale = 'fur'
);

comment on collation pg_catalog."fur-x-icu"
is 'Friulian';

alter collation pg_catalog."fur-x-icu"
  owner to postgres;

create collation pg_catalog."fur-IT-x-icu" (
  locale = 'fur-IT'
);

comment on collation pg_catalog."fur-IT-x-icu"
is 'Friulian (Italy)';

alter collation pg_catalog."fur-IT-x-icu"
  owner to postgres;

create collation pg_catalog."fy-x-icu" (
  locale = 'fy'
);

comment on collation pg_catalog."fy-x-icu"
is 'Western Frisian';

alter collation pg_catalog."fy-x-icu"
  owner to postgres;

create collation pg_catalog."fy-NL-x-icu" (
  locale = 'fy-NL'
);

comment on collation pg_catalog."fy-NL-x-icu"
is 'Western Frisian (Netherlands)';

alter collation pg_catalog."fy-NL-x-icu"
  owner to postgres;

create collation pg_catalog."ga-x-icu" (
  locale = 'ga'
);

comment on collation pg_catalog."ga-x-icu"
is 'Irish';

alter collation pg_catalog."ga-x-icu"
  owner to postgres;

create collation pg_catalog."ga-IE-x-icu" (
  locale = 'ga-IE'
);

comment on collation pg_catalog."ga-IE-x-icu"
is 'Irish (Ireland)';

alter collation pg_catalog."ga-IE-x-icu"
  owner to postgres;

create collation pg_catalog."gd-x-icu" (
  locale = 'gd'
);

comment on collation pg_catalog."gd-x-icu"
is 'Scottish Gaelic';

alter collation pg_catalog."gd-x-icu"
  owner to postgres;

create collation pg_catalog."gd-GB-x-icu" (
  locale = 'gd-GB'
);

comment on collation pg_catalog."gd-GB-x-icu"
is 'Scottish Gaelic (United Kingdom)';

alter collation pg_catalog."gd-GB-x-icu"
  owner to postgres;

create collation pg_catalog."gl-x-icu" (
  locale = 'gl'
);

comment on collation pg_catalog."gl-x-icu"
is 'Galician';

alter collation pg_catalog."gl-x-icu"
  owner to postgres;

create collation pg_catalog."gl-ES-x-icu" (
  locale = 'gl-ES'
);

comment on collation pg_catalog."gl-ES-x-icu"
is 'Galician (Spain)';

alter collation pg_catalog."gl-ES-x-icu"
  owner to postgres;

create collation pg_catalog."gsw-x-icu" (
  locale = 'gsw'
);

comment on collation pg_catalog."gsw-x-icu"
is 'Swiss German';

alter collation pg_catalog."gsw-x-icu"
  owner to postgres;

create collation pg_catalog."gsw-CH-x-icu" (
  locale = 'gsw-CH'
);

comment on collation pg_catalog."gsw-CH-x-icu"
is 'Swiss German (Switzerland)';

alter collation pg_catalog."gsw-CH-x-icu"
  owner to postgres;

create collation pg_catalog."gsw-FR-x-icu" (
  locale = 'gsw-FR'
);

comment on collation pg_catalog."gsw-FR-x-icu"
is 'Swiss German (France)';

alter collation pg_catalog."gsw-FR-x-icu"
  owner to postgres;

create collation pg_catalog."gsw-LI-x-icu" (
  locale = 'gsw-LI'
);

comment on collation pg_catalog."gsw-LI-x-icu"
is 'Swiss German (Liechtenstein)';

alter collation pg_catalog."gsw-LI-x-icu"
  owner to postgres;

create collation pg_catalog."gu-x-icu" (
  locale = 'gu'
);

comment on collation pg_catalog."gu-x-icu"
is 'Gujarati';

alter collation pg_catalog."gu-x-icu"
  owner to postgres;

create collation pg_catalog."gu-IN-x-icu" (
  locale = 'gu-IN'
);

comment on collation pg_catalog."gu-IN-x-icu"
is 'Gujarati (India)';

alter collation pg_catalog."gu-IN-x-icu"
  owner to postgres;

create collation pg_catalog."guz-x-icu" (
  locale = 'guz'
);

comment on collation pg_catalog."guz-x-icu"
is 'Gusii';

alter collation pg_catalog."guz-x-icu"
  owner to postgres;

create collation pg_catalog."guz-KE-x-icu" (
  locale = 'guz-KE'
);

comment on collation pg_catalog."guz-KE-x-icu"
is 'Gusii (Kenya)';

alter collation pg_catalog."guz-KE-x-icu"
  owner to postgres;

create collation pg_catalog."gv-x-icu" (
  locale = 'gv'
);

comment on collation pg_catalog."gv-x-icu"
is 'Manx';

alter collation pg_catalog."gv-x-icu"
  owner to postgres;

create collation pg_catalog."gv-IM-x-icu" (
  locale = 'gv-IM'
);

comment on collation pg_catalog."gv-IM-x-icu"
is 'Manx (Isle of Man)';

alter collation pg_catalog."gv-IM-x-icu"
  owner to postgres;

create collation pg_catalog."ha-x-icu" (
  locale = 'ha'
);

comment on collation pg_catalog."ha-x-icu"
is 'Hausa';

alter collation pg_catalog."ha-x-icu"
  owner to postgres;

create collation pg_catalog."ha-GH-x-icu" (
  locale = 'ha-GH'
);

comment on collation pg_catalog."ha-GH-x-icu"
is 'Hausa (Ghana)';

alter collation pg_catalog."ha-GH-x-icu"
  owner to postgres;

create collation pg_catalog."ha-NE-x-icu" (
  locale = 'ha-NE'
);

comment on collation pg_catalog."ha-NE-x-icu"
is 'Hausa (Niger)';

alter collation pg_catalog."ha-NE-x-icu"
  owner to postgres;

create collation pg_catalog."ha-NG-x-icu" (
  locale = 'ha-NG'
);

comment on collation pg_catalog."ha-NG-x-icu"
is 'Hausa (Nigeria)';

alter collation pg_catalog."ha-NG-x-icu"
  owner to postgres;

create collation pg_catalog."haw-x-icu" (
  locale = 'haw'
);

comment on collation pg_catalog."haw-x-icu"
is 'Hawaiian';

alter collation pg_catalog."haw-x-icu"
  owner to postgres;

create collation pg_catalog."haw-US-x-icu" (
  locale = 'haw-US'
);

comment on collation pg_catalog."haw-US-x-icu"
is 'Hawaiian (United States)';

alter collation pg_catalog."haw-US-x-icu"
  owner to postgres;

create collation pg_catalog."he-x-icu" (
  locale = 'he'
);

comment on collation pg_catalog."he-x-icu"
is 'Hebrew';

alter collation pg_catalog."he-x-icu"
  owner to postgres;

create collation pg_catalog."he-IL-x-icu" (
  locale = 'he-IL'
);

comment on collation pg_catalog."he-IL-x-icu"
is 'Hebrew (Israel)';

alter collation pg_catalog."he-IL-x-icu"
  owner to postgres;

create collation pg_catalog."hi-x-icu" (
  locale = 'hi'
);

comment on collation pg_catalog."hi-x-icu"
is 'Hindi';

alter collation pg_catalog."hi-x-icu"
  owner to postgres;

create collation pg_catalog."hi-IN-x-icu" (
  locale = 'hi-IN'
);

comment on collation pg_catalog."hi-IN-x-icu"
is 'Hindi (India)';

alter collation pg_catalog."hi-IN-x-icu"
  owner to postgres;

create collation pg_catalog."hr-x-icu" (
  locale = 'hr'
);

comment on collation pg_catalog."hr-x-icu"
is 'Croatian';

alter collation pg_catalog."hr-x-icu"
  owner to postgres;

create collation pg_catalog."hr-BA-x-icu" (
  locale = 'hr-BA'
);

comment on collation pg_catalog."hr-BA-x-icu"
is 'Croatian (Bosnia & Herzegovina)';

alter collation pg_catalog."hr-BA-x-icu"
  owner to postgres;

create collation pg_catalog."hr-HR-x-icu" (
  locale = 'hr-HR'
);

comment on collation pg_catalog."hr-HR-x-icu"
is 'Croatian (Croatia)';

alter collation pg_catalog."hr-HR-x-icu"
  owner to postgres;

create collation pg_catalog."hsb-x-icu" (
  locale = 'hsb'
);

comment on collation pg_catalog."hsb-x-icu"
is 'Upper Sorbian';

alter collation pg_catalog."hsb-x-icu"
  owner to postgres;

create collation pg_catalog."hsb-DE-x-icu" (
  locale = 'hsb-DE'
);

comment on collation pg_catalog."hsb-DE-x-icu"
is 'Upper Sorbian (Germany)';

alter collation pg_catalog."hsb-DE-x-icu"
  owner to postgres;

create collation pg_catalog."hu-x-icu" (
  locale = 'hu'
);

comment on collation pg_catalog."hu-x-icu"
is 'Hungarian';

alter collation pg_catalog."hu-x-icu"
  owner to postgres;

create collation pg_catalog."hu-HU-x-icu" (
  locale = 'hu-HU'
);

comment on collation pg_catalog."hu-HU-x-icu"
is 'Hungarian (Hungary)';

alter collation pg_catalog."hu-HU-x-icu"
  owner to postgres;

create collation pg_catalog."hy-x-icu" (
  locale = 'hy'
);

comment on collation pg_catalog."hy-x-icu"
is 'Armenian';

alter collation pg_catalog."hy-x-icu"
  owner to postgres;

create collation pg_catalog."hy-AM-x-icu" (
  locale = 'hy-AM'
);

comment on collation pg_catalog."hy-AM-x-icu"
is 'Armenian (Armenia)';

alter collation pg_catalog."hy-AM-x-icu"
  owner to postgres;

create collation pg_catalog."id-x-icu" (
  locale = 'id'
);

comment on collation pg_catalog."id-x-icu"
is 'Indonesian';

alter collation pg_catalog."id-x-icu"
  owner to postgres;

create collation pg_catalog."id-ID-x-icu" (
  locale = 'id-ID'
);

comment on collation pg_catalog."id-ID-x-icu"
is 'Indonesian (Indonesia)';

alter collation pg_catalog."id-ID-x-icu"
  owner to postgres;

create collation pg_catalog."ig-x-icu" (
  locale = 'ig'
);

comment on collation pg_catalog."ig-x-icu"
is 'Igbo';

alter collation pg_catalog."ig-x-icu"
  owner to postgres;

create collation pg_catalog."ig-NG-x-icu" (
  locale = 'ig-NG'
);

comment on collation pg_catalog."ig-NG-x-icu"
is 'Igbo (Nigeria)';

alter collation pg_catalog."ig-NG-x-icu"
  owner to postgres;

create collation pg_catalog."ii-x-icu" (
  locale = 'ii'
);

comment on collation pg_catalog."ii-x-icu"
is 'Sichuan Yi';

alter collation pg_catalog."ii-x-icu"
  owner to postgres;

create collation pg_catalog."ii-CN-x-icu" (
  locale = 'ii-CN'
);

comment on collation pg_catalog."ii-CN-x-icu"
is 'Sichuan Yi (China)';

alter collation pg_catalog."ii-CN-x-icu"
  owner to postgres;

create collation pg_catalog."is-x-icu" (
  locale = 'is'
);

comment on collation pg_catalog."is-x-icu"
is 'Icelandic';

alter collation pg_catalog."is-x-icu"
  owner to postgres;

create collation pg_catalog."is-IS-x-icu" (
  locale = 'is-IS'
);

comment on collation pg_catalog."is-IS-x-icu"
is 'Icelandic (Iceland)';

alter collation pg_catalog."is-IS-x-icu"
  owner to postgres;

create collation pg_catalog."it-x-icu" (
  locale = 'it'
);

comment on collation pg_catalog."it-x-icu"
is 'Italian';

alter collation pg_catalog."it-x-icu"
  owner to postgres;

create collation pg_catalog."it-CH-x-icu" (
  locale = 'it-CH'
);

comment on collation pg_catalog."it-CH-x-icu"
is 'Italian (Switzerland)';

alter collation pg_catalog."it-CH-x-icu"
  owner to postgres;

create collation pg_catalog."it-IT-x-icu" (
  locale = 'it-IT'
);

comment on collation pg_catalog."it-IT-x-icu"
is 'Italian (Italy)';

alter collation pg_catalog."it-IT-x-icu"
  owner to postgres;

create collation pg_catalog."it-SM-x-icu" (
  locale = 'it-SM'
);

comment on collation pg_catalog."it-SM-x-icu"
is 'Italian (San Marino)';

alter collation pg_catalog."it-SM-x-icu"
  owner to postgres;

create collation pg_catalog."ja-x-icu" (
  locale = 'ja'
);

comment on collation pg_catalog."ja-x-icu"
is 'Japanese';

alter collation pg_catalog."ja-x-icu"
  owner to postgres;

create collation pg_catalog."ja-JP-x-icu" (
  locale = 'ja-JP'
);

comment on collation pg_catalog."ja-JP-x-icu"
is 'Japanese (Japan)';

alter collation pg_catalog."ja-JP-x-icu"
  owner to postgres;

create collation pg_catalog."jgo-x-icu" (
  locale = 'jgo'
);

comment on collation pg_catalog."jgo-x-icu"
is 'Ngomba';

alter collation pg_catalog."jgo-x-icu"
  owner to postgres;

create collation pg_catalog."jgo-CM-x-icu" (
  locale = 'jgo-CM'
);

comment on collation pg_catalog."jgo-CM-x-icu"
is 'Ngomba (Cameroon)';

alter collation pg_catalog."jgo-CM-x-icu"
  owner to postgres;

create collation pg_catalog."jmc-x-icu" (
  locale = 'jmc'
);

comment on collation pg_catalog."jmc-x-icu"
is 'Machame';

alter collation pg_catalog."jmc-x-icu"
  owner to postgres;

create collation pg_catalog."jmc-TZ-x-icu" (
  locale = 'jmc-TZ'
);

comment on collation pg_catalog."jmc-TZ-x-icu"
is 'Machame (Tanzania)';

alter collation pg_catalog."jmc-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."ka-x-icu" (
  locale = 'ka'
);

comment on collation pg_catalog."ka-x-icu"
is 'Georgian';

alter collation pg_catalog."ka-x-icu"
  owner to postgres;

create collation pg_catalog."ka-GE-x-icu" (
  locale = 'ka-GE'
);

comment on collation pg_catalog."ka-GE-x-icu"
is 'Georgian (Georgia)';

alter collation pg_catalog."ka-GE-x-icu"
  owner to postgres;

create collation pg_catalog."kab-x-icu" (
  locale = 'kab'
);

comment on collation pg_catalog."kab-x-icu"
is 'Kabyle';

alter collation pg_catalog."kab-x-icu"
  owner to postgres;

create collation pg_catalog."kab-DZ-x-icu" (
  locale = 'kab-DZ'
);

comment on collation pg_catalog."kab-DZ-x-icu"
is 'Kabyle (Algeria)';

alter collation pg_catalog."kab-DZ-x-icu"
  owner to postgres;

create collation pg_catalog."kam-x-icu" (
  locale = 'kam'
);

comment on collation pg_catalog."kam-x-icu"
is 'Kamba';

alter collation pg_catalog."kam-x-icu"
  owner to postgres;

create collation pg_catalog."kam-KE-x-icu" (
  locale = 'kam-KE'
);

comment on collation pg_catalog."kam-KE-x-icu"
is 'Kamba (Kenya)';

alter collation pg_catalog."kam-KE-x-icu"
  owner to postgres;

create collation pg_catalog."kde-x-icu" (
  locale = 'kde'
);

comment on collation pg_catalog."kde-x-icu"
is 'Makonde';

alter collation pg_catalog."kde-x-icu"
  owner to postgres;

create collation pg_catalog."kde-TZ-x-icu" (
  locale = 'kde-TZ'
);

comment on collation pg_catalog."kde-TZ-x-icu"
is 'Makonde (Tanzania)';

alter collation pg_catalog."kde-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."kea-x-icu" (
  locale = 'kea'
);

comment on collation pg_catalog."kea-x-icu"
is 'Kabuverdianu';

alter collation pg_catalog."kea-x-icu"
  owner to postgres;

create collation pg_catalog."kea-CV-x-icu" (
  locale = 'kea-CV'
);

comment on collation pg_catalog."kea-CV-x-icu"
is 'Kabuverdianu (Cape Verde)';

alter collation pg_catalog."kea-CV-x-icu"
  owner to postgres;

create collation pg_catalog."khq-x-icu" (
  locale = 'khq'
);

comment on collation pg_catalog."khq-x-icu"
is 'Koyra Chiini';

alter collation pg_catalog."khq-x-icu"
  owner to postgres;

create collation pg_catalog."khq-ML-x-icu" (
  locale = 'khq-ML'
);

comment on collation pg_catalog."khq-ML-x-icu"
is 'Koyra Chiini (Mali)';

alter collation pg_catalog."khq-ML-x-icu"
  owner to postgres;

create collation pg_catalog."ki-x-icu" (
  locale = 'ki'
);

comment on collation pg_catalog."ki-x-icu"
is 'Kikuyu';

alter collation pg_catalog."ki-x-icu"
  owner to postgres;

create collation pg_catalog."ki-KE-x-icu" (
  locale = 'ki-KE'
);

comment on collation pg_catalog."ki-KE-x-icu"
is 'Kikuyu (Kenya)';

alter collation pg_catalog."ki-KE-x-icu"
  owner to postgres;

create collation pg_catalog."kk-x-icu" (
  locale = 'kk'
);

comment on collation pg_catalog."kk-x-icu"
is 'Kazakh';

alter collation pg_catalog."kk-x-icu"
  owner to postgres;

create collation pg_catalog."kk-KZ-x-icu" (
  locale = 'kk-KZ'
);

comment on collation pg_catalog."kk-KZ-x-icu"
is 'Kazakh (Kazakhstan)';

alter collation pg_catalog."kk-KZ-x-icu"
  owner to postgres;

create collation pg_catalog."kkj-x-icu" (
  locale = 'kkj'
);

comment on collation pg_catalog."kkj-x-icu"
is 'Kako';

alter collation pg_catalog."kkj-x-icu"
  owner to postgres;

create collation pg_catalog."kkj-CM-x-icu" (
  locale = 'kkj-CM'
);

comment on collation pg_catalog."kkj-CM-x-icu"
is 'Kako (Cameroon)';

alter collation pg_catalog."kkj-CM-x-icu"
  owner to postgres;

create collation pg_catalog."kl-x-icu" (
  locale = 'kl'
);

comment on collation pg_catalog."kl-x-icu"
is 'Kalaallisut';

alter collation pg_catalog."kl-x-icu"
  owner to postgres;

create collation pg_catalog."kl-GL-x-icu" (
  locale = 'kl-GL'
);

comment on collation pg_catalog."kl-GL-x-icu"
is 'Kalaallisut (Greenland)';

alter collation pg_catalog."kl-GL-x-icu"
  owner to postgres;

create collation pg_catalog."kln-x-icu" (
  locale = 'kln'
);

comment on collation pg_catalog."kln-x-icu"
is 'Kalenjin';

alter collation pg_catalog."kln-x-icu"
  owner to postgres;

create collation pg_catalog."kln-KE-x-icu" (
  locale = 'kln-KE'
);

comment on collation pg_catalog."kln-KE-x-icu"
is 'Kalenjin (Kenya)';

alter collation pg_catalog."kln-KE-x-icu"
  owner to postgres;

create collation pg_catalog."km-x-icu" (
  locale = 'km'
);

comment on collation pg_catalog."km-x-icu"
is 'Khmer';

alter collation pg_catalog."km-x-icu"
  owner to postgres;

create collation pg_catalog."km-KH-x-icu" (
  locale = 'km-KH'
);

comment on collation pg_catalog."km-KH-x-icu"
is 'Khmer (Cambodia)';

alter collation pg_catalog."km-KH-x-icu"
  owner to postgres;

create collation pg_catalog."kn-x-icu" (
  locale = 'kn'
);

comment on collation pg_catalog."kn-x-icu"
is 'Kannada';

alter collation pg_catalog."kn-x-icu"
  owner to postgres;

create collation pg_catalog."kn-IN-x-icu" (
  locale = 'kn-IN'
);

comment on collation pg_catalog."kn-IN-x-icu"
is 'Kannada (India)';

alter collation pg_catalog."kn-IN-x-icu"
  owner to postgres;

create collation pg_catalog."ko-x-icu" (
  locale = 'ko'
);

comment on collation pg_catalog."ko-x-icu"
is 'Korean';

alter collation pg_catalog."ko-x-icu"
  owner to postgres;

create collation pg_catalog."ko-KP-x-icu" (
  locale = 'ko-KP'
);

comment on collation pg_catalog."ko-KP-x-icu"
is 'Korean (North Korea)';

alter collation pg_catalog."ko-KP-x-icu"
  owner to postgres;

create collation pg_catalog."ko-KR-x-icu" (
  locale = 'ko-KR'
);

comment on collation pg_catalog."ko-KR-x-icu"
is 'Korean (South Korea)';

alter collation pg_catalog."ko-KR-x-icu"
  owner to postgres;

create collation pg_catalog."kok-x-icu" (
  locale = 'kok'
);

comment on collation pg_catalog."kok-x-icu"
is 'Konkani';

alter collation pg_catalog."kok-x-icu"
  owner to postgres;

create collation pg_catalog."kok-IN-x-icu" (
  locale = 'kok-IN'
);

comment on collation pg_catalog."kok-IN-x-icu"
is 'Konkani (India)';

alter collation pg_catalog."kok-IN-x-icu"
  owner to postgres;

create collation pg_catalog."ks-x-icu" (
  locale = 'ks'
);

comment on collation pg_catalog."ks-x-icu"
is 'Kashmiri';

alter collation pg_catalog."ks-x-icu"
  owner to postgres;

create collation pg_catalog."ks-IN-x-icu" (
  locale = 'ks-IN'
);

comment on collation pg_catalog."ks-IN-x-icu"
is 'Kashmiri (India)';

alter collation pg_catalog."ks-IN-x-icu"
  owner to postgres;

create collation pg_catalog."ksb-x-icu" (
  locale = 'ksb'
);

comment on collation pg_catalog."ksb-x-icu"
is 'Shambala';

alter collation pg_catalog."ksb-x-icu"
  owner to postgres;

create collation pg_catalog."ksb-TZ-x-icu" (
  locale = 'ksb-TZ'
);

comment on collation pg_catalog."ksb-TZ-x-icu"
is 'Shambala (Tanzania)';

alter collation pg_catalog."ksb-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."ksf-x-icu" (
  locale = 'ksf'
);

comment on collation pg_catalog."ksf-x-icu"
is 'Bafia';

alter collation pg_catalog."ksf-x-icu"
  owner to postgres;

create collation pg_catalog."ksf-CM-x-icu" (
  locale = 'ksf-CM'
);

comment on collation pg_catalog."ksf-CM-x-icu"
is 'Bafia (Cameroon)';

alter collation pg_catalog."ksf-CM-x-icu"
  owner to postgres;

create collation pg_catalog."ksh-x-icu" (
  locale = 'ksh'
);

comment on collation pg_catalog."ksh-x-icu"
is 'Colognian';

alter collation pg_catalog."ksh-x-icu"
  owner to postgres;

create collation pg_catalog."ksh-DE-x-icu" (
  locale = 'ksh-DE'
);

comment on collation pg_catalog."ksh-DE-x-icu"
is 'Colognian (Germany)';

alter collation pg_catalog."ksh-DE-x-icu"
  owner to postgres;

create collation pg_catalog."kw-x-icu" (
  locale = 'kw'
);

comment on collation pg_catalog."kw-x-icu"
is 'Cornish';

alter collation pg_catalog."kw-x-icu"
  owner to postgres;

create collation pg_catalog."kw-GB-x-icu" (
  locale = 'kw-GB'
);

comment on collation pg_catalog."kw-GB-x-icu"
is 'Cornish (United Kingdom)';

alter collation pg_catalog."kw-GB-x-icu"
  owner to postgres;

create collation pg_catalog."ky-x-icu" (
  locale = 'ky'
);

comment on collation pg_catalog."ky-x-icu"
is 'Kyrgyz';

alter collation pg_catalog."ky-x-icu"
  owner to postgres;

create collation pg_catalog."ky-KG-x-icu" (
  locale = 'ky-KG'
);

comment on collation pg_catalog."ky-KG-x-icu"
is 'Kyrgyz (Kyrgyzstan)';

alter collation pg_catalog."ky-KG-x-icu"
  owner to postgres;

create collation pg_catalog."lag-x-icu" (
  locale = 'lag'
);

comment on collation pg_catalog."lag-x-icu"
is 'Langi';

alter collation pg_catalog."lag-x-icu"
  owner to postgres;

create collation pg_catalog."lag-TZ-x-icu" (
  locale = 'lag-TZ'
);

comment on collation pg_catalog."lag-TZ-x-icu"
is 'Langi (Tanzania)';

alter collation pg_catalog."lag-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."lb-x-icu" (
  locale = 'lb'
);

comment on collation pg_catalog."lb-x-icu"
is 'Luxembourgish';

alter collation pg_catalog."lb-x-icu"
  owner to postgres;

create collation pg_catalog."lb-LU-x-icu" (
  locale = 'lb-LU'
);

comment on collation pg_catalog."lb-LU-x-icu"
is 'Luxembourgish (Luxembourg)';

alter collation pg_catalog."lb-LU-x-icu"
  owner to postgres;

create collation pg_catalog."lg-x-icu" (
  locale = 'lg'
);

comment on collation pg_catalog."lg-x-icu"
is 'Ganda';

alter collation pg_catalog."lg-x-icu"
  owner to postgres;

create collation pg_catalog."lg-UG-x-icu" (
  locale = 'lg-UG'
);

comment on collation pg_catalog."lg-UG-x-icu"
is 'Ganda (Uganda)';

alter collation pg_catalog."lg-UG-x-icu"
  owner to postgres;

create collation pg_catalog."lkt-x-icu" (
  locale = 'lkt'
);

comment on collation pg_catalog."lkt-x-icu"
is 'Lakota';

alter collation pg_catalog."lkt-x-icu"
  owner to postgres;

create collation pg_catalog."lkt-US-x-icu" (
  locale = 'lkt-US'
);

comment on collation pg_catalog."lkt-US-x-icu"
is 'Lakota (United States)';

alter collation pg_catalog."lkt-US-x-icu"
  owner to postgres;

create collation pg_catalog."ln-x-icu" (
  locale = 'ln'
);

comment on collation pg_catalog."ln-x-icu"
is 'Lingala';

alter collation pg_catalog."ln-x-icu"
  owner to postgres;

create collation pg_catalog."ln-AO-x-icu" (
  locale = 'ln-AO'
);

comment on collation pg_catalog."ln-AO-x-icu"
is 'Lingala (Angola)';

alter collation pg_catalog."ln-AO-x-icu"
  owner to postgres;

create collation pg_catalog."ln-CD-x-icu" (
  locale = 'ln-CD'
);

comment on collation pg_catalog."ln-CD-x-icu"
is 'Lingala (Congo - Kinshasa)';

alter collation pg_catalog."ln-CD-x-icu"
  owner to postgres;

create collation pg_catalog."ln-CF-x-icu" (
  locale = 'ln-CF'
);

comment on collation pg_catalog."ln-CF-x-icu"
is 'Lingala (Central African Republic)';

alter collation pg_catalog."ln-CF-x-icu"
  owner to postgres;

create collation pg_catalog."ln-CG-x-icu" (
  locale = 'ln-CG'
);

comment on collation pg_catalog."ln-CG-x-icu"
is 'Lingala (Congo - Brazzaville)';

alter collation pg_catalog."ln-CG-x-icu"
  owner to postgres;

create collation pg_catalog."lo-x-icu" (
  locale = 'lo'
);

comment on collation pg_catalog."lo-x-icu"
is 'Lao';

alter collation pg_catalog."lo-x-icu"
  owner to postgres;

create collation pg_catalog."lo-LA-x-icu" (
  locale = 'lo-LA'
);

comment on collation pg_catalog."lo-LA-x-icu"
is 'Lao (Laos)';

alter collation pg_catalog."lo-LA-x-icu"
  owner to postgres;

create collation pg_catalog."lrc-x-icu" (
  locale = 'lrc'
);

comment on collation pg_catalog."lrc-x-icu"
is 'Northern Luri';

alter collation pg_catalog."lrc-x-icu"
  owner to postgres;

create collation pg_catalog."lrc-IQ-x-icu" (
  locale = 'lrc-IQ'
);

comment on collation pg_catalog."lrc-IQ-x-icu"
is 'Northern Luri (Iraq)';

alter collation pg_catalog."lrc-IQ-x-icu"
  owner to postgres;

create collation pg_catalog."lrc-IR-x-icu" (
  locale = 'lrc-IR'
);

comment on collation pg_catalog."lrc-IR-x-icu"
is 'Northern Luri (Iran)';

alter collation pg_catalog."lrc-IR-x-icu"
  owner to postgres;

create collation pg_catalog."lt-x-icu" (
  locale = 'lt'
);

comment on collation pg_catalog."lt-x-icu"
is 'Lithuanian';

alter collation pg_catalog."lt-x-icu"
  owner to postgres;

create collation pg_catalog."lt-LT-x-icu" (
  locale = 'lt-LT'
);

comment on collation pg_catalog."lt-LT-x-icu"
is 'Lithuanian (Lithuania)';

alter collation pg_catalog."lt-LT-x-icu"
  owner to postgres;

create collation pg_catalog."lu-x-icu" (
  locale = 'lu'
);

comment on collation pg_catalog."lu-x-icu"
is 'Luba-Katanga';

alter collation pg_catalog."lu-x-icu"
  owner to postgres;

create collation pg_catalog."lu-CD-x-icu" (
  locale = 'lu-CD'
);

comment on collation pg_catalog."lu-CD-x-icu"
is 'Luba-Katanga (Congo - Kinshasa)';

alter collation pg_catalog."lu-CD-x-icu"
  owner to postgres;

create collation pg_catalog."luo-x-icu" (
  locale = 'luo'
);

comment on collation pg_catalog."luo-x-icu"
is 'Luo';

alter collation pg_catalog."luo-x-icu"
  owner to postgres;

create collation pg_catalog."luo-KE-x-icu" (
  locale = 'luo-KE'
);

comment on collation pg_catalog."luo-KE-x-icu"
is 'Luo (Kenya)';

alter collation pg_catalog."luo-KE-x-icu"
  owner to postgres;

create collation pg_catalog."luy-x-icu" (
  locale = 'luy'
);

comment on collation pg_catalog."luy-x-icu"
is 'Luyia';

alter collation pg_catalog."luy-x-icu"
  owner to postgres;

create collation pg_catalog."luy-KE-x-icu" (
  locale = 'luy-KE'
);

comment on collation pg_catalog."luy-KE-x-icu"
is 'Luyia (Kenya)';

alter collation pg_catalog."luy-KE-x-icu"
  owner to postgres;

create collation pg_catalog."lv-x-icu" (
  locale = 'lv'
);

comment on collation pg_catalog."lv-x-icu"
is 'Latvian';

alter collation pg_catalog."lv-x-icu"
  owner to postgres;

create collation pg_catalog."lv-LV-x-icu" (
  locale = 'lv-LV'
);

comment on collation pg_catalog."lv-LV-x-icu"
is 'Latvian (Latvia)';

alter collation pg_catalog."lv-LV-x-icu"
  owner to postgres;

create collation pg_catalog."mas-x-icu" (
  locale = 'mas'
);

comment on collation pg_catalog."mas-x-icu"
is 'Masai';

alter collation pg_catalog."mas-x-icu"
  owner to postgres;

create collation pg_catalog."mas-KE-x-icu" (
  locale = 'mas-KE'
);

comment on collation pg_catalog."mas-KE-x-icu"
is 'Masai (Kenya)';

alter collation pg_catalog."mas-KE-x-icu"
  owner to postgres;

create collation pg_catalog."mas-TZ-x-icu" (
  locale = 'mas-TZ'
);

comment on collation pg_catalog."mas-TZ-x-icu"
is 'Masai (Tanzania)';

alter collation pg_catalog."mas-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."mer-x-icu" (
  locale = 'mer'
);

comment on collation pg_catalog."mer-x-icu"
is 'Meru';

alter collation pg_catalog."mer-x-icu"
  owner to postgres;

create collation pg_catalog."mer-KE-x-icu" (
  locale = 'mer-KE'
);

comment on collation pg_catalog."mer-KE-x-icu"
is 'Meru (Kenya)';

alter collation pg_catalog."mer-KE-x-icu"
  owner to postgres;

create collation pg_catalog."mfe-x-icu" (
  locale = 'mfe'
);

comment on collation pg_catalog."mfe-x-icu"
is 'Morisyen';

alter collation pg_catalog."mfe-x-icu"
  owner to postgres;

create collation pg_catalog."mfe-MU-x-icu" (
  locale = 'mfe-MU'
);

comment on collation pg_catalog."mfe-MU-x-icu"
is 'Morisyen (Mauritius)';

alter collation pg_catalog."mfe-MU-x-icu"
  owner to postgres;

create collation pg_catalog."mg-x-icu" (
  locale = 'mg'
);

comment on collation pg_catalog."mg-x-icu"
is 'Malagasy';

alter collation pg_catalog."mg-x-icu"
  owner to postgres;

create collation pg_catalog."mg-MG-x-icu" (
  locale = 'mg-MG'
);

comment on collation pg_catalog."mg-MG-x-icu"
is 'Malagasy (Madagascar)';

alter collation pg_catalog."mg-MG-x-icu"
  owner to postgres;

create collation pg_catalog."mgh-x-icu" (
  locale = 'mgh'
);

comment on collation pg_catalog."mgh-x-icu"
is 'Makhuwa-Meetto';

alter collation pg_catalog."mgh-x-icu"
  owner to postgres;

create collation pg_catalog."mgh-MZ-x-icu" (
  locale = 'mgh-MZ'
);

comment on collation pg_catalog."mgh-MZ-x-icu"
is 'Makhuwa-Meetto (Mozambique)';

alter collation pg_catalog."mgh-MZ-x-icu"
  owner to postgres;

create collation pg_catalog."mgo-x-icu" (
  locale = 'mgo'
);

alter collation pg_catalog."mgo-x-icu"
  owner to postgres;

create collation pg_catalog."mgo-CM-x-icu" (
  locale = 'mgo-CM'
);

alter collation pg_catalog."mgo-CM-x-icu"
  owner to postgres;

create collation pg_catalog."mk-x-icu" (
  locale = 'mk'
);

comment on collation pg_catalog."mk-x-icu"
is 'Macedonian';

alter collation pg_catalog."mk-x-icu"
  owner to postgres;

create collation pg_catalog."mk-MK-x-icu" (
  locale = 'mk-MK'
);

comment on collation pg_catalog."mk-MK-x-icu"
is 'Macedonian (Macedonia)';

alter collation pg_catalog."mk-MK-x-icu"
  owner to postgres;

create collation pg_catalog."ml-x-icu" (
  locale = 'ml'
);

comment on collation pg_catalog."ml-x-icu"
is 'Malayalam';

alter collation pg_catalog."ml-x-icu"
  owner to postgres;

create collation pg_catalog."ml-IN-x-icu" (
  locale = 'ml-IN'
);

comment on collation pg_catalog."ml-IN-x-icu"
is 'Malayalam (India)';

alter collation pg_catalog."ml-IN-x-icu"
  owner to postgres;

create collation pg_catalog."mn-x-icu" (
  locale = 'mn'
);

comment on collation pg_catalog."mn-x-icu"
is 'Mongolian';

alter collation pg_catalog."mn-x-icu"
  owner to postgres;

create collation pg_catalog."mn-MN-x-icu" (
  locale = 'mn-MN'
);

comment on collation pg_catalog."mn-MN-x-icu"
is 'Mongolian (Mongolia)';

alter collation pg_catalog."mn-MN-x-icu"
  owner to postgres;

create collation pg_catalog."mr-x-icu" (
  locale = 'mr'
);

comment on collation pg_catalog."mr-x-icu"
is 'Marathi';

alter collation pg_catalog."mr-x-icu"
  owner to postgres;

create collation pg_catalog."mr-IN-x-icu" (
  locale = 'mr-IN'
);

comment on collation pg_catalog."mr-IN-x-icu"
is 'Marathi (India)';

alter collation pg_catalog."mr-IN-x-icu"
  owner to postgres;

create collation pg_catalog."ms-x-icu" (
  locale = 'ms'
);

comment on collation pg_catalog."ms-x-icu"
is 'Malay';

alter collation pg_catalog."ms-x-icu"
  owner to postgres;

create collation pg_catalog."ms-BN-x-icu" (
  locale = 'ms-BN'
);

comment on collation pg_catalog."ms-BN-x-icu"
is 'Malay (Brunei)';

alter collation pg_catalog."ms-BN-x-icu"
  owner to postgres;

create collation pg_catalog."ms-MY-x-icu" (
  locale = 'ms-MY'
);

comment on collation pg_catalog."ms-MY-x-icu"
is 'Malay (Malaysia)';

alter collation pg_catalog."ms-MY-x-icu"
  owner to postgres;

create collation pg_catalog."ms-SG-x-icu" (
  locale = 'ms-SG'
);

comment on collation pg_catalog."ms-SG-x-icu"
is 'Malay (Singapore)';

alter collation pg_catalog."ms-SG-x-icu"
  owner to postgres;

create collation pg_catalog."mt-x-icu" (
  locale = 'mt'
);

comment on collation pg_catalog."mt-x-icu"
is 'Maltese';

alter collation pg_catalog."mt-x-icu"
  owner to postgres;

create collation pg_catalog."mt-MT-x-icu" (
  locale = 'mt-MT'
);

comment on collation pg_catalog."mt-MT-x-icu"
is 'Maltese (Malta)';

alter collation pg_catalog."mt-MT-x-icu"
  owner to postgres;

create collation pg_catalog."mua-x-icu" (
  locale = 'mua'
);

comment on collation pg_catalog."mua-x-icu"
is 'Mundang';

alter collation pg_catalog."mua-x-icu"
  owner to postgres;

create collation pg_catalog."mua-CM-x-icu" (
  locale = 'mua-CM'
);

comment on collation pg_catalog."mua-CM-x-icu"
is 'Mundang (Cameroon)';

alter collation pg_catalog."mua-CM-x-icu"
  owner to postgres;

create collation pg_catalog."my-x-icu" (
  locale = 'my'
);

comment on collation pg_catalog."my-x-icu"
is 'Burmese';

alter collation pg_catalog."my-x-icu"
  owner to postgres;

create collation pg_catalog."my-MM-x-icu" (
  locale = 'my-MM'
);

comment on collation pg_catalog."my-MM-x-icu"
is 'Burmese (Myanmar [Burma])';

alter collation pg_catalog."my-MM-x-icu"
  owner to postgres;

create collation pg_catalog."mzn-x-icu" (
  locale = 'mzn'
);

comment on collation pg_catalog."mzn-x-icu"
is 'Mazanderani';

alter collation pg_catalog."mzn-x-icu"
  owner to postgres;

create collation pg_catalog."mzn-IR-x-icu" (
  locale = 'mzn-IR'
);

comment on collation pg_catalog."mzn-IR-x-icu"
is 'Mazanderani (Iran)';

alter collation pg_catalog."mzn-IR-x-icu"
  owner to postgres;

create collation pg_catalog."naq-x-icu" (
  locale = 'naq'
);

comment on collation pg_catalog."naq-x-icu"
is 'Nama';

alter collation pg_catalog."naq-x-icu"
  owner to postgres;

create collation pg_catalog."naq-NA-x-icu" (
  locale = 'naq-NA'
);

comment on collation pg_catalog."naq-NA-x-icu"
is 'Nama (Namibia)';

alter collation pg_catalog."naq-NA-x-icu"
  owner to postgres;

create collation pg_catalog."nb-x-icu" (
  locale = 'nb'
);

alter collation pg_catalog."nb-x-icu"
  owner to postgres;

create collation pg_catalog."nb-NO-x-icu" (
  locale = 'nb-NO'
);

alter collation pg_catalog."nb-NO-x-icu"
  owner to postgres;

create collation pg_catalog."nb-SJ-x-icu" (
  locale = 'nb-SJ'
);

alter collation pg_catalog."nb-SJ-x-icu"
  owner to postgres;

create collation pg_catalog."nd-x-icu" (
  locale = 'nd'
);

comment on collation pg_catalog."nd-x-icu"
is 'North Ndebele';

alter collation pg_catalog."nd-x-icu"
  owner to postgres;

create collation pg_catalog."nd-ZW-x-icu" (
  locale = 'nd-ZW'
);

comment on collation pg_catalog."nd-ZW-x-icu"
is 'North Ndebele (Zimbabwe)';

alter collation pg_catalog."nd-ZW-x-icu"
  owner to postgres;

create collation pg_catalog."ne-x-icu" (
  locale = 'ne'
);

comment on collation pg_catalog."ne-x-icu"
is 'Nepali';

alter collation pg_catalog."ne-x-icu"
  owner to postgres;

create collation pg_catalog."ne-IN-x-icu" (
  locale = 'ne-IN'
);

comment on collation pg_catalog."ne-IN-x-icu"
is 'Nepali (India)';

alter collation pg_catalog."ne-IN-x-icu"
  owner to postgres;

create collation pg_catalog."ne-NP-x-icu" (
  locale = 'ne-NP'
);

comment on collation pg_catalog."ne-NP-x-icu"
is 'Nepali (Nepal)';

alter collation pg_catalog."ne-NP-x-icu"
  owner to postgres;

create collation pg_catalog."nl-x-icu" (
  locale = 'nl'
);

comment on collation pg_catalog."nl-x-icu"
is 'Dutch';

alter collation pg_catalog."nl-x-icu"
  owner to postgres;

create collation pg_catalog."nl-AW-x-icu" (
  locale = 'nl-AW'
);

comment on collation pg_catalog."nl-AW-x-icu"
is 'Dutch (Aruba)';

alter collation pg_catalog."nl-AW-x-icu"
  owner to postgres;

create collation pg_catalog."nl-BE-x-icu" (
  locale = 'nl-BE'
);

comment on collation pg_catalog."nl-BE-x-icu"
is 'Dutch (Belgium)';

alter collation pg_catalog."nl-BE-x-icu"
  owner to postgres;

create collation pg_catalog."nl-BQ-x-icu" (
  locale = 'nl-BQ'
);

comment on collation pg_catalog."nl-BQ-x-icu"
is 'Dutch (Caribbean Netherlands)';

alter collation pg_catalog."nl-BQ-x-icu"
  owner to postgres;

create collation pg_catalog."nl-CW-x-icu" (
  locale = 'nl-CW'
);

alter collation pg_catalog."nl-CW-x-icu"
  owner to postgres;

create collation pg_catalog."nl-NL-x-icu" (
  locale = 'nl-NL'
);

comment on collation pg_catalog."nl-NL-x-icu"
is 'Dutch (Netherlands)';

alter collation pg_catalog."nl-NL-x-icu"
  owner to postgres;

create collation pg_catalog."nl-SR-x-icu" (
  locale = 'nl-SR'
);

comment on collation pg_catalog."nl-SR-x-icu"
is 'Dutch (Suriname)';

alter collation pg_catalog."nl-SR-x-icu"
  owner to postgres;

create collation pg_catalog."nl-SX-x-icu" (
  locale = 'nl-SX'
);

comment on collation pg_catalog."nl-SX-x-icu"
is 'Dutch (Sint Maarten)';

alter collation pg_catalog."nl-SX-x-icu"
  owner to postgres;

create collation pg_catalog."nmg-x-icu" (
  locale = 'nmg'
);

comment on collation pg_catalog."nmg-x-icu"
is 'Kwasio';

alter collation pg_catalog."nmg-x-icu"
  owner to postgres;

create collation pg_catalog."nmg-CM-x-icu" (
  locale = 'nmg-CM'
);

comment on collation pg_catalog."nmg-CM-x-icu"
is 'Kwasio (Cameroon)';

alter collation pg_catalog."nmg-CM-x-icu"
  owner to postgres;

create collation pg_catalog."nn-x-icu" (
  locale = 'nn'
);

comment on collation pg_catalog."nn-x-icu"
is 'Norwegian Nynorsk';

alter collation pg_catalog."nn-x-icu"
  owner to postgres;

create collation pg_catalog."nn-NO-x-icu" (
  locale = 'nn-NO'
);

comment on collation pg_catalog."nn-NO-x-icu"
is 'Norwegian Nynorsk (Norway)';

alter collation pg_catalog."nn-NO-x-icu"
  owner to postgres;

create collation pg_catalog."nnh-x-icu" (
  locale = 'nnh'
);

comment on collation pg_catalog."nnh-x-icu"
is 'Ngiemboon';

alter collation pg_catalog."nnh-x-icu"
  owner to postgres;

create collation pg_catalog."nnh-CM-x-icu" (
  locale = 'nnh-CM'
);

comment on collation pg_catalog."nnh-CM-x-icu"
is 'Ngiemboon (Cameroon)';

alter collation pg_catalog."nnh-CM-x-icu"
  owner to postgres;

create collation pg_catalog."nus-x-icu" (
  locale = 'nus'
);

comment on collation pg_catalog."nus-x-icu"
is 'Nuer';

alter collation pg_catalog."nus-x-icu"
  owner to postgres;

create collation pg_catalog."nus-SS-x-icu" (
  locale = 'nus-SS'
);

comment on collation pg_catalog."nus-SS-x-icu"
is 'Nuer (South Sudan)';

alter collation pg_catalog."nus-SS-x-icu"
  owner to postgres;

create collation pg_catalog."nyn-x-icu" (
  locale = 'nyn'
);

comment on collation pg_catalog."nyn-x-icu"
is 'Nyankole';

alter collation pg_catalog."nyn-x-icu"
  owner to postgres;

create collation pg_catalog."nyn-UG-x-icu" (
  locale = 'nyn-UG'
);

comment on collation pg_catalog."nyn-UG-x-icu"
is 'Nyankole (Uganda)';

alter collation pg_catalog."nyn-UG-x-icu"
  owner to postgres;

create collation pg_catalog."om-x-icu" (
  locale = 'om'
);

comment on collation pg_catalog."om-x-icu"
is 'Oromo';

alter collation pg_catalog."om-x-icu"
  owner to postgres;

create collation pg_catalog."om-ET-x-icu" (
  locale = 'om-ET'
);

comment on collation pg_catalog."om-ET-x-icu"
is 'Oromo (Ethiopia)';

alter collation pg_catalog."om-ET-x-icu"
  owner to postgres;

create collation pg_catalog."om-KE-x-icu" (
  locale = 'om-KE'
);

comment on collation pg_catalog."om-KE-x-icu"
is 'Oromo (Kenya)';

alter collation pg_catalog."om-KE-x-icu"
  owner to postgres;

create collation pg_catalog."or-x-icu" (
  locale = 'or'
);

comment on collation pg_catalog."or-x-icu"
is 'Oriya';

alter collation pg_catalog."or-x-icu"
  owner to postgres;

create collation pg_catalog."or-IN-x-icu" (
  locale = 'or-IN'
);

comment on collation pg_catalog."or-IN-x-icu"
is 'Oriya (India)';

alter collation pg_catalog."or-IN-x-icu"
  owner to postgres;

create collation pg_catalog."os-x-icu" (
  locale = 'os'
);

comment on collation pg_catalog."os-x-icu"
is 'Ossetic';

alter collation pg_catalog."os-x-icu"
  owner to postgres;

create collation pg_catalog."os-GE-x-icu" (
  locale = 'os-GE'
);

comment on collation pg_catalog."os-GE-x-icu"
is 'Ossetic (Georgia)';

alter collation pg_catalog."os-GE-x-icu"
  owner to postgres;

create collation pg_catalog."os-RU-x-icu" (
  locale = 'os-RU'
);

comment on collation pg_catalog."os-RU-x-icu"
is 'Ossetic (Russia)';

alter collation pg_catalog."os-RU-x-icu"
  owner to postgres;

create collation pg_catalog."pa-x-icu" (
  locale = 'pa'
);

comment on collation pg_catalog."pa-x-icu"
is 'Punjabi';

alter collation pg_catalog."pa-x-icu"
  owner to postgres;

create collation pg_catalog."pa-Arab-x-icu" (
  locale = 'pa-Arab'
);

comment on collation pg_catalog."pa-Arab-x-icu"
is 'Punjabi (Arabic)';

alter collation pg_catalog."pa-Arab-x-icu"
  owner to postgres;

create collation pg_catalog."pa-Arab-PK-x-icu" (
  locale = 'pa-Arab-PK'
);

comment on collation pg_catalog."pa-Arab-PK-x-icu"
is 'Punjabi (Arabic, Pakistan)';

alter collation pg_catalog."pa-Arab-PK-x-icu"
  owner to postgres;

create collation pg_catalog."pa-Guru-x-icu" (
  locale = 'pa-Guru'
);

comment on collation pg_catalog."pa-Guru-x-icu"
is 'Punjabi (Gurmukhi)';

alter collation pg_catalog."pa-Guru-x-icu"
  owner to postgres;

create collation pg_catalog."pa-Guru-IN-x-icu" (
  locale = 'pa-Guru-IN'
);

comment on collation pg_catalog."pa-Guru-IN-x-icu"
is 'Punjabi (Gurmukhi, India)';

alter collation pg_catalog."pa-Guru-IN-x-icu"
  owner to postgres;

create collation pg_catalog."pl-x-icu" (
  locale = 'pl'
);

comment on collation pg_catalog."pl-x-icu"
is 'Polish';

alter collation pg_catalog."pl-x-icu"
  owner to postgres;

create collation pg_catalog."pl-PL-x-icu" (
  locale = 'pl-PL'
);

comment on collation pg_catalog."pl-PL-x-icu"
is 'Polish (Poland)';

alter collation pg_catalog."pl-PL-x-icu"
  owner to postgres;

create collation pg_catalog."ps-x-icu" (
  locale = 'ps'
);

comment on collation pg_catalog."ps-x-icu"
is 'Pashto';

alter collation pg_catalog."ps-x-icu"
  owner to postgres;

create collation pg_catalog."ps-AF-x-icu" (
  locale = 'ps-AF'
);

comment on collation pg_catalog."ps-AF-x-icu"
is 'Pashto (Afghanistan)';

alter collation pg_catalog."ps-AF-x-icu"
  owner to postgres;

create collation pg_catalog."pt-x-icu" (
  locale = 'pt'
);

comment on collation pg_catalog."pt-x-icu"
is 'Portuguese';

alter collation pg_catalog."pt-x-icu"
  owner to postgres;

create collation pg_catalog."pt-AO-x-icu" (
  locale = 'pt-AO'
);

comment on collation pg_catalog."pt-AO-x-icu"
is 'Portuguese (Angola)';

alter collation pg_catalog."pt-AO-x-icu"
  owner to postgres;

create collation pg_catalog."pt-BR-x-icu" (
  locale = 'pt-BR'
);

comment on collation pg_catalog."pt-BR-x-icu"
is 'Portuguese (Brazil)';

alter collation pg_catalog."pt-BR-x-icu"
  owner to postgres;

create collation pg_catalog."pt-CV-x-icu" (
  locale = 'pt-CV'
);

comment on collation pg_catalog."pt-CV-x-icu"
is 'Portuguese (Cape Verde)';

alter collation pg_catalog."pt-CV-x-icu"
  owner to postgres;

create collation pg_catalog."pt-GW-x-icu" (
  locale = 'pt-GW'
);

comment on collation pg_catalog."pt-GW-x-icu"
is 'Portuguese (Guinea-Bissau)';

alter collation pg_catalog."pt-GW-x-icu"
  owner to postgres;

create collation pg_catalog."pt-MO-x-icu" (
  locale = 'pt-MO'
);

comment on collation pg_catalog."pt-MO-x-icu"
is 'Portuguese (Macau SAR China)';

alter collation pg_catalog."pt-MO-x-icu"
  owner to postgres;

create collation pg_catalog."pt-MZ-x-icu" (
  locale = 'pt-MZ'
);

comment on collation pg_catalog."pt-MZ-x-icu"
is 'Portuguese (Mozambique)';

alter collation pg_catalog."pt-MZ-x-icu"
  owner to postgres;

create collation pg_catalog."pt-PT-x-icu" (
  locale = 'pt-PT'
);

comment on collation pg_catalog."pt-PT-x-icu"
is 'Portuguese (Portugal)';

alter collation pg_catalog."pt-PT-x-icu"
  owner to postgres;

create collation pg_catalog."pt-ST-x-icu" (
  locale = 'pt-ST'
);

alter collation pg_catalog."pt-ST-x-icu"
  owner to postgres;

create collation pg_catalog."pt-TL-x-icu" (
  locale = 'pt-TL'
);

comment on collation pg_catalog."pt-TL-x-icu"
is 'Portuguese (Timor-Leste)';

alter collation pg_catalog."pt-TL-x-icu"
  owner to postgres;

create collation pg_catalog."qu-x-icu" (
  locale = 'qu'
);

comment on collation pg_catalog."qu-x-icu"
is 'Quechua';

alter collation pg_catalog."qu-x-icu"
  owner to postgres;

create collation pg_catalog."qu-BO-x-icu" (
  locale = 'qu-BO'
);

comment on collation pg_catalog."qu-BO-x-icu"
is 'Quechua (Bolivia)';

alter collation pg_catalog."qu-BO-x-icu"
  owner to postgres;

create collation pg_catalog."qu-EC-x-icu" (
  locale = 'qu-EC'
);

comment on collation pg_catalog."qu-EC-x-icu"
is 'Quechua (Ecuador)';

alter collation pg_catalog."qu-EC-x-icu"
  owner to postgres;

create collation pg_catalog."qu-PE-x-icu" (
  locale = 'qu-PE'
);

comment on collation pg_catalog."qu-PE-x-icu"
is 'Quechua (Peru)';

alter collation pg_catalog."qu-PE-x-icu"
  owner to postgres;

create collation pg_catalog."rm-x-icu" (
  locale = 'rm'
);

comment on collation pg_catalog."rm-x-icu"
is 'Romansh';

alter collation pg_catalog."rm-x-icu"
  owner to postgres;

create collation pg_catalog."rm-CH-x-icu" (
  locale = 'rm-CH'
);

comment on collation pg_catalog."rm-CH-x-icu"
is 'Romansh (Switzerland)';

alter collation pg_catalog."rm-CH-x-icu"
  owner to postgres;

create collation pg_catalog."rn-x-icu" (
  locale = 'rn'
);

comment on collation pg_catalog."rn-x-icu"
is 'Rundi';

alter collation pg_catalog."rn-x-icu"
  owner to postgres;

create collation pg_catalog."rn-BI-x-icu" (
  locale = 'rn-BI'
);

comment on collation pg_catalog."rn-BI-x-icu"
is 'Rundi (Burundi)';

alter collation pg_catalog."rn-BI-x-icu"
  owner to postgres;

create collation pg_catalog."ro-x-icu" (
  locale = 'ro'
);

comment on collation pg_catalog."ro-x-icu"
is 'Romanian';

alter collation pg_catalog."ro-x-icu"
  owner to postgres;

create collation pg_catalog."ro-MD-x-icu" (
  locale = 'ro-MD'
);

comment on collation pg_catalog."ro-MD-x-icu"
is 'Romanian (Moldova)';

alter collation pg_catalog."ro-MD-x-icu"
  owner to postgres;

create collation pg_catalog."ro-RO-x-icu" (
  locale = 'ro-RO'
);

comment on collation pg_catalog."ro-RO-x-icu"
is 'Romanian (Romania)';

alter collation pg_catalog."ro-RO-x-icu"
  owner to postgres;

create collation pg_catalog."rof-x-icu" (
  locale = 'rof'
);

comment on collation pg_catalog."rof-x-icu"
is 'Rombo';

alter collation pg_catalog."rof-x-icu"
  owner to postgres;

create collation pg_catalog."rof-TZ-x-icu" (
  locale = 'rof-TZ'
);

comment on collation pg_catalog."rof-TZ-x-icu"
is 'Rombo (Tanzania)';

alter collation pg_catalog."rof-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."ru-x-icu" (
  locale = 'ru'
);

comment on collation pg_catalog."ru-x-icu"
is 'Russian';

alter collation pg_catalog."ru-x-icu"
  owner to postgres;

create collation pg_catalog."ru-BY-x-icu" (
  locale = 'ru-BY'
);

comment on collation pg_catalog."ru-BY-x-icu"
is 'Russian (Belarus)';

alter collation pg_catalog."ru-BY-x-icu"
  owner to postgres;

create collation pg_catalog."ru-KG-x-icu" (
  locale = 'ru-KG'
);

comment on collation pg_catalog."ru-KG-x-icu"
is 'Russian (Kyrgyzstan)';

alter collation pg_catalog."ru-KG-x-icu"
  owner to postgres;

create collation pg_catalog."ru-KZ-x-icu" (
  locale = 'ru-KZ'
);

comment on collation pg_catalog."ru-KZ-x-icu"
is 'Russian (Kazakhstan)';

alter collation pg_catalog."ru-KZ-x-icu"
  owner to postgres;

create collation pg_catalog."ru-MD-x-icu" (
  locale = 'ru-MD'
);

comment on collation pg_catalog."ru-MD-x-icu"
is 'Russian (Moldova)';

alter collation pg_catalog."ru-MD-x-icu"
  owner to postgres;

create collation pg_catalog."ru-RU-x-icu" (
  locale = 'ru-RU'
);

comment on collation pg_catalog."ru-RU-x-icu"
is 'Russian (Russia)';

alter collation pg_catalog."ru-RU-x-icu"
  owner to postgres;

create collation pg_catalog."ru-UA-x-icu" (
  locale = 'ru-UA'
);

comment on collation pg_catalog."ru-UA-x-icu"
is 'Russian (Ukraine)';

alter collation pg_catalog."ru-UA-x-icu"
  owner to postgres;

create collation pg_catalog."rw-x-icu" (
  locale = 'rw'
);

comment on collation pg_catalog."rw-x-icu"
is 'Kinyarwanda';

alter collation pg_catalog."rw-x-icu"
  owner to postgres;

create collation pg_catalog."rw-RW-x-icu" (
  locale = 'rw-RW'
);

comment on collation pg_catalog."rw-RW-x-icu"
is 'Kinyarwanda (Rwanda)';

alter collation pg_catalog."rw-RW-x-icu"
  owner to postgres;

create collation pg_catalog."rwk-x-icu" (
  locale = 'rwk'
);

comment on collation pg_catalog."rwk-x-icu"
is 'Rwa';

alter collation pg_catalog."rwk-x-icu"
  owner to postgres;

create collation pg_catalog."rwk-TZ-x-icu" (
  locale = 'rwk-TZ'
);

comment on collation pg_catalog."rwk-TZ-x-icu"
is 'Rwa (Tanzania)';

alter collation pg_catalog."rwk-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."sah-x-icu" (
  locale = 'sah'
);

comment on collation pg_catalog."sah-x-icu"
is 'Sakha';

alter collation pg_catalog."sah-x-icu"
  owner to postgres;

create collation pg_catalog."sah-RU-x-icu" (
  locale = 'sah-RU'
);

comment on collation pg_catalog."sah-RU-x-icu"
is 'Sakha (Russia)';

alter collation pg_catalog."sah-RU-x-icu"
  owner to postgres;

create collation pg_catalog."saq-x-icu" (
  locale = 'saq'
);

comment on collation pg_catalog."saq-x-icu"
is 'Samburu';

alter collation pg_catalog."saq-x-icu"
  owner to postgres;

create collation pg_catalog."saq-KE-x-icu" (
  locale = 'saq-KE'
);

comment on collation pg_catalog."saq-KE-x-icu"
is 'Samburu (Kenya)';

alter collation pg_catalog."saq-KE-x-icu"
  owner to postgres;

create collation pg_catalog."sbp-x-icu" (
  locale = 'sbp'
);

comment on collation pg_catalog."sbp-x-icu"
is 'Sangu';

alter collation pg_catalog."sbp-x-icu"
  owner to postgres;

create collation pg_catalog."sbp-TZ-x-icu" (
  locale = 'sbp-TZ'
);

comment on collation pg_catalog."sbp-TZ-x-icu"
is 'Sangu (Tanzania)';

alter collation pg_catalog."sbp-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."se-x-icu" (
  locale = 'se'
);

comment on collation pg_catalog."se-x-icu"
is 'Northern Sami';

alter collation pg_catalog."se-x-icu"
  owner to postgres;

create collation pg_catalog."se-FI-x-icu" (
  locale = 'se-FI'
);

comment on collation pg_catalog."se-FI-x-icu"
is 'Northern Sami (Finland)';

alter collation pg_catalog."se-FI-x-icu"
  owner to postgres;

create collation pg_catalog."se-NO-x-icu" (
  locale = 'se-NO'
);

comment on collation pg_catalog."se-NO-x-icu"
is 'Northern Sami (Norway)';

alter collation pg_catalog."se-NO-x-icu"
  owner to postgres;

create collation pg_catalog."se-SE-x-icu" (
  locale = 'se-SE'
);

comment on collation pg_catalog."se-SE-x-icu"
is 'Northern Sami (Sweden)';

alter collation pg_catalog."se-SE-x-icu"
  owner to postgres;

create collation pg_catalog."seh-x-icu" (
  locale = 'seh'
);

comment on collation pg_catalog."seh-x-icu"
is 'Sena';

alter collation pg_catalog."seh-x-icu"
  owner to postgres;

create collation pg_catalog."seh-MZ-x-icu" (
  locale = 'seh-MZ'
);

comment on collation pg_catalog."seh-MZ-x-icu"
is 'Sena (Mozambique)';

alter collation pg_catalog."seh-MZ-x-icu"
  owner to postgres;

create collation pg_catalog."ses-x-icu" (
  locale = 'ses'
);

comment on collation pg_catalog."ses-x-icu"
is 'Koyraboro Senni';

alter collation pg_catalog."ses-x-icu"
  owner to postgres;

create collation pg_catalog."ses-ML-x-icu" (
  locale = 'ses-ML'
);

comment on collation pg_catalog."ses-ML-x-icu"
is 'Koyraboro Senni (Mali)';

alter collation pg_catalog."ses-ML-x-icu"
  owner to postgres;

create collation pg_catalog."sg-x-icu" (
  locale = 'sg'
);

comment on collation pg_catalog."sg-x-icu"
is 'Sango';

alter collation pg_catalog."sg-x-icu"
  owner to postgres;

create collation pg_catalog."sg-CF-x-icu" (
  locale = 'sg-CF'
);

comment on collation pg_catalog."sg-CF-x-icu"
is 'Sango (Central African Republic)';

alter collation pg_catalog."sg-CF-x-icu"
  owner to postgres;

create collation pg_catalog."shi-x-icu" (
  locale = 'shi'
);

comment on collation pg_catalog."shi-x-icu"
is 'Tachelhit';

alter collation pg_catalog."shi-x-icu"
  owner to postgres;

create collation pg_catalog."shi-Latn-x-icu" (
  locale = 'shi-Latn'
);

comment on collation pg_catalog."shi-Latn-x-icu"
is 'Tachelhit (Latin)';

alter collation pg_catalog."shi-Latn-x-icu"
  owner to postgres;

create collation pg_catalog."shi-Latn-MA-x-icu" (
  locale = 'shi-Latn-MA'
);

comment on collation pg_catalog."shi-Latn-MA-x-icu"
is 'Tachelhit (Latin, Morocco)';

alter collation pg_catalog."shi-Latn-MA-x-icu"
  owner to postgres;

create collation pg_catalog."shi-Tfng-x-icu" (
  locale = 'shi-Tfng'
);

comment on collation pg_catalog."shi-Tfng-x-icu"
is 'Tachelhit (Tifinagh)';

alter collation pg_catalog."shi-Tfng-x-icu"
  owner to postgres;

create collation pg_catalog."shi-Tfng-MA-x-icu" (
  locale = 'shi-Tfng-MA'
);

comment on collation pg_catalog."shi-Tfng-MA-x-icu"
is 'Tachelhit (Tifinagh, Morocco)';

alter collation pg_catalog."shi-Tfng-MA-x-icu"
  owner to postgres;

create collation pg_catalog."si-x-icu" (
  locale = 'si'
);

comment on collation pg_catalog."si-x-icu"
is 'Sinhala';

alter collation pg_catalog."si-x-icu"
  owner to postgres;

create collation pg_catalog."si-LK-x-icu" (
  locale = 'si-LK'
);

comment on collation pg_catalog."si-LK-x-icu"
is 'Sinhala (Sri Lanka)';

alter collation pg_catalog."si-LK-x-icu"
  owner to postgres;

create collation pg_catalog."sk-x-icu" (
  locale = 'sk'
);

comment on collation pg_catalog."sk-x-icu"
is 'Slovak';

alter collation pg_catalog."sk-x-icu"
  owner to postgres;

create collation pg_catalog."sk-SK-x-icu" (
  locale = 'sk-SK'
);

comment on collation pg_catalog."sk-SK-x-icu"
is 'Slovak (Slovakia)';

alter collation pg_catalog."sk-SK-x-icu"
  owner to postgres;

create collation pg_catalog."sl-x-icu" (
  locale = 'sl'
);

comment on collation pg_catalog."sl-x-icu"
is 'Slovenian';

alter collation pg_catalog."sl-x-icu"
  owner to postgres;

create collation pg_catalog."sl-SI-x-icu" (
  locale = 'sl-SI'
);

comment on collation pg_catalog."sl-SI-x-icu"
is 'Slovenian (Slovenia)';

alter collation pg_catalog."sl-SI-x-icu"
  owner to postgres;

create collation pg_catalog."smn-x-icu" (
  locale = 'smn'
);

comment on collation pg_catalog."smn-x-icu"
is 'Inari Sami';

alter collation pg_catalog."smn-x-icu"
  owner to postgres;

create collation pg_catalog."smn-FI-x-icu" (
  locale = 'smn-FI'
);

comment on collation pg_catalog."smn-FI-x-icu"
is 'Inari Sami (Finland)';

alter collation pg_catalog."smn-FI-x-icu"
  owner to postgres;

create collation pg_catalog."sn-x-icu" (
  locale = 'sn'
);

comment on collation pg_catalog."sn-x-icu"
is 'Shona';

alter collation pg_catalog."sn-x-icu"
  owner to postgres;

create collation pg_catalog."sn-ZW-x-icu" (
  locale = 'sn-ZW'
);

comment on collation pg_catalog."sn-ZW-x-icu"
is 'Shona (Zimbabwe)';

alter collation pg_catalog."sn-ZW-x-icu"
  owner to postgres;

create collation pg_catalog."so-x-icu" (
  locale = 'so'
);

comment on collation pg_catalog."so-x-icu"
is 'Somali';

alter collation pg_catalog."so-x-icu"
  owner to postgres;

create collation pg_catalog."so-DJ-x-icu" (
  locale = 'so-DJ'
);

comment on collation pg_catalog."so-DJ-x-icu"
is 'Somali (Djibouti)';

alter collation pg_catalog."so-DJ-x-icu"
  owner to postgres;

create collation pg_catalog."so-ET-x-icu" (
  locale = 'so-ET'
);

comment on collation pg_catalog."so-ET-x-icu"
is 'Somali (Ethiopia)';

alter collation pg_catalog."so-ET-x-icu"
  owner to postgres;

create collation pg_catalog."so-KE-x-icu" (
  locale = 'so-KE'
);

comment on collation pg_catalog."so-KE-x-icu"
is 'Somali (Kenya)';

alter collation pg_catalog."so-KE-x-icu"
  owner to postgres;

create collation pg_catalog."so-SO-x-icu" (
  locale = 'so-SO'
);

comment on collation pg_catalog."so-SO-x-icu"
is 'Somali (Somalia)';

alter collation pg_catalog."so-SO-x-icu"
  owner to postgres;

create collation pg_catalog."sq-x-icu" (
  locale = 'sq'
);

comment on collation pg_catalog."sq-x-icu"
is 'Albanian';

alter collation pg_catalog."sq-x-icu"
  owner to postgres;

create collation pg_catalog."sq-AL-x-icu" (
  locale = 'sq-AL'
);

comment on collation pg_catalog."sq-AL-x-icu"
is 'Albanian (Albania)';

alter collation pg_catalog."sq-AL-x-icu"
  owner to postgres;

create collation pg_catalog."sq-MK-x-icu" (
  locale = 'sq-MK'
);

comment on collation pg_catalog."sq-MK-x-icu"
is 'Albanian (Macedonia)';

alter collation pg_catalog."sq-MK-x-icu"
  owner to postgres;

create collation pg_catalog."sq-XK-x-icu" (
  locale = 'sq-XK'
);

comment on collation pg_catalog."sq-XK-x-icu"
is 'Albanian (Kosovo)';

alter collation pg_catalog."sq-XK-x-icu"
  owner to postgres;

create collation pg_catalog."sr-x-icu" (
  locale = 'sr'
);

comment on collation pg_catalog."sr-x-icu"
is 'Serbian';

alter collation pg_catalog."sr-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Cyrl-x-icu" (
  locale = 'sr-Cyrl'
);

comment on collation pg_catalog."sr-Cyrl-x-icu"
is 'Serbian (Cyrillic)';

alter collation pg_catalog."sr-Cyrl-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Cyrl-BA-x-icu" (
  locale = 'sr-Cyrl-BA'
);

comment on collation pg_catalog."sr-Cyrl-BA-x-icu"
is 'Serbian (Cyrillic, Bosnia & Herzegovina)';

alter collation pg_catalog."sr-Cyrl-BA-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Cyrl-ME-x-icu" (
  locale = 'sr-Cyrl-ME'
);

comment on collation pg_catalog."sr-Cyrl-ME-x-icu"
is 'Serbian (Cyrillic, Montenegro)';

alter collation pg_catalog."sr-Cyrl-ME-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Cyrl-RS-x-icu" (
  locale = 'sr-Cyrl-RS'
);

comment on collation pg_catalog."sr-Cyrl-RS-x-icu"
is 'Serbian (Cyrillic, Serbia)';

alter collation pg_catalog."sr-Cyrl-RS-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Cyrl-XK-x-icu" (
  locale = 'sr-Cyrl-XK'
);

comment on collation pg_catalog."sr-Cyrl-XK-x-icu"
is 'Serbian (Cyrillic, Kosovo)';

alter collation pg_catalog."sr-Cyrl-XK-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Latn-x-icu" (
  locale = 'sr-Latn'
);

comment on collation pg_catalog."sr-Latn-x-icu"
is 'Serbian (Latin)';

alter collation pg_catalog."sr-Latn-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Latn-BA-x-icu" (
  locale = 'sr-Latn-BA'
);

comment on collation pg_catalog."sr-Latn-BA-x-icu"
is 'Serbian (Latin, Bosnia & Herzegovina)';

alter collation pg_catalog."sr-Latn-BA-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Latn-ME-x-icu" (
  locale = 'sr-Latn-ME'
);

comment on collation pg_catalog."sr-Latn-ME-x-icu"
is 'Serbian (Latin, Montenegro)';

alter collation pg_catalog."sr-Latn-ME-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Latn-RS-x-icu" (
  locale = 'sr-Latn-RS'
);

comment on collation pg_catalog."sr-Latn-RS-x-icu"
is 'Serbian (Latin, Serbia)';

alter collation pg_catalog."sr-Latn-RS-x-icu"
  owner to postgres;

create collation pg_catalog."sr-Latn-XK-x-icu" (
  locale = 'sr-Latn-XK'
);

comment on collation pg_catalog."sr-Latn-XK-x-icu"
is 'Serbian (Latin, Kosovo)';

alter collation pg_catalog."sr-Latn-XK-x-icu"
  owner to postgres;

create collation pg_catalog."sv-x-icu" (
  locale = 'sv'
);

comment on collation pg_catalog."sv-x-icu"
is 'Swedish';

alter collation pg_catalog."sv-x-icu"
  owner to postgres;

create collation pg_catalog."sv-AX-x-icu" (
  locale = 'sv-AX'
);

alter collation pg_catalog."sv-AX-x-icu"
  owner to postgres;

create collation pg_catalog."sv-FI-x-icu" (
  locale = 'sv-FI'
);

comment on collation pg_catalog."sv-FI-x-icu"
is 'Swedish (Finland)';

alter collation pg_catalog."sv-FI-x-icu"
  owner to postgres;

create collation pg_catalog."sv-SE-x-icu" (
  locale = 'sv-SE'
);

comment on collation pg_catalog."sv-SE-x-icu"
is 'Swedish (Sweden)';

alter collation pg_catalog."sv-SE-x-icu"
  owner to postgres;

create collation pg_catalog."sw-x-icu" (
  locale = 'sw'
);

comment on collation pg_catalog."sw-x-icu"
is 'Swahili';

alter collation pg_catalog."sw-x-icu"
  owner to postgres;

create collation pg_catalog."sw-CD-x-icu" (
  locale = 'sw-CD'
);

comment on collation pg_catalog."sw-CD-x-icu"
is 'Swahili (Congo - Kinshasa)';

alter collation pg_catalog."sw-CD-x-icu"
  owner to postgres;

create collation pg_catalog."sw-KE-x-icu" (
  locale = 'sw-KE'
);

comment on collation pg_catalog."sw-KE-x-icu"
is 'Swahili (Kenya)';

alter collation pg_catalog."sw-KE-x-icu"
  owner to postgres;

create collation pg_catalog."sw-TZ-x-icu" (
  locale = 'sw-TZ'
);

comment on collation pg_catalog."sw-TZ-x-icu"
is 'Swahili (Tanzania)';

alter collation pg_catalog."sw-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."sw-UG-x-icu" (
  locale = 'sw-UG'
);

comment on collation pg_catalog."sw-UG-x-icu"
is 'Swahili (Uganda)';

alter collation pg_catalog."sw-UG-x-icu"
  owner to postgres;

create collation pg_catalog."ta-x-icu" (
  locale = 'ta'
);

comment on collation pg_catalog."ta-x-icu"
is 'Tamil';

alter collation pg_catalog."ta-x-icu"
  owner to postgres;

create collation pg_catalog."ta-IN-x-icu" (
  locale = 'ta-IN'
);

comment on collation pg_catalog."ta-IN-x-icu"
is 'Tamil (India)';

alter collation pg_catalog."ta-IN-x-icu"
  owner to postgres;

create collation pg_catalog."ta-LK-x-icu" (
  locale = 'ta-LK'
);

comment on collation pg_catalog."ta-LK-x-icu"
is 'Tamil (Sri Lanka)';

alter collation pg_catalog."ta-LK-x-icu"
  owner to postgres;

create collation pg_catalog."ta-MY-x-icu" (
  locale = 'ta-MY'
);

comment on collation pg_catalog."ta-MY-x-icu"
is 'Tamil (Malaysia)';

alter collation pg_catalog."ta-MY-x-icu"
  owner to postgres;

create collation pg_catalog."ta-SG-x-icu" (
  locale = 'ta-SG'
);

comment on collation pg_catalog."ta-SG-x-icu"
is 'Tamil (Singapore)';

alter collation pg_catalog."ta-SG-x-icu"
  owner to postgres;

create collation pg_catalog."te-x-icu" (
  locale = 'te'
);

comment on collation pg_catalog."te-x-icu"
is 'Telugu';

alter collation pg_catalog."te-x-icu"
  owner to postgres;

create collation pg_catalog."te-IN-x-icu" (
  locale = 'te-IN'
);

comment on collation pg_catalog."te-IN-x-icu"
is 'Telugu (India)';

alter collation pg_catalog."te-IN-x-icu"
  owner to postgres;

create collation pg_catalog."teo-x-icu" (
  locale = 'teo'
);

comment on collation pg_catalog."teo-x-icu"
is 'Teso';

alter collation pg_catalog."teo-x-icu"
  owner to postgres;

create collation pg_catalog."teo-KE-x-icu" (
  locale = 'teo-KE'
);

comment on collation pg_catalog."teo-KE-x-icu"
is 'Teso (Kenya)';

alter collation pg_catalog."teo-KE-x-icu"
  owner to postgres;

create collation pg_catalog."teo-UG-x-icu" (
  locale = 'teo-UG'
);

comment on collation pg_catalog."teo-UG-x-icu"
is 'Teso (Uganda)';

alter collation pg_catalog."teo-UG-x-icu"
  owner to postgres;

create collation pg_catalog."th-x-icu" (
  locale = 'th'
);

comment on collation pg_catalog."th-x-icu"
is 'Thai';

alter collation pg_catalog."th-x-icu"
  owner to postgres;

create collation pg_catalog."th-TH-x-icu" (
  locale = 'th-TH'
);

comment on collation pg_catalog."th-TH-x-icu"
is 'Thai (Thailand)';

alter collation pg_catalog."th-TH-x-icu"
  owner to postgres;

create collation pg_catalog."ti-x-icu" (
  locale = 'ti'
);

comment on collation pg_catalog."ti-x-icu"
is 'Tigrinya';

alter collation pg_catalog."ti-x-icu"
  owner to postgres;

create collation pg_catalog."ti-ER-x-icu" (
  locale = 'ti-ER'
);

comment on collation pg_catalog."ti-ER-x-icu"
is 'Tigrinya (Eritrea)';

alter collation pg_catalog."ti-ER-x-icu"
  owner to postgres;

create collation pg_catalog."ti-ET-x-icu" (
  locale = 'ti-ET'
);

comment on collation pg_catalog."ti-ET-x-icu"
is 'Tigrinya (Ethiopia)';

alter collation pg_catalog."ti-ET-x-icu"
  owner to postgres;

create collation pg_catalog."to-x-icu" (
  locale = 'to'
);

comment on collation pg_catalog."to-x-icu"
is 'Tongan';

alter collation pg_catalog."to-x-icu"
  owner to postgres;

create collation pg_catalog."to-TO-x-icu" (
  locale = 'to-TO'
);

comment on collation pg_catalog."to-TO-x-icu"
is 'Tongan (Tonga)';

alter collation pg_catalog."to-TO-x-icu"
  owner to postgres;

create collation pg_catalog."tr-x-icu" (
  locale = 'tr'
);

comment on collation pg_catalog."tr-x-icu"
is 'Turkish';

alter collation pg_catalog."tr-x-icu"
  owner to postgres;

create collation pg_catalog."tr-CY-x-icu" (
  locale = 'tr-CY'
);

comment on collation pg_catalog."tr-CY-x-icu"
is 'Turkish (Cyprus)';

alter collation pg_catalog."tr-CY-x-icu"
  owner to postgres;

create collation pg_catalog."tr-TR-x-icu" (
  locale = 'tr-TR'
);

comment on collation pg_catalog."tr-TR-x-icu"
is 'Turkish (Turkey)';

alter collation pg_catalog."tr-TR-x-icu"
  owner to postgres;

create collation pg_catalog."twq-x-icu" (
  locale = 'twq'
);

comment on collation pg_catalog."twq-x-icu"
is 'Tasawaq';

alter collation pg_catalog."twq-x-icu"
  owner to postgres;

create collation pg_catalog."twq-NE-x-icu" (
  locale = 'twq-NE'
);

comment on collation pg_catalog."twq-NE-x-icu"
is 'Tasawaq (Niger)';

alter collation pg_catalog."twq-NE-x-icu"
  owner to postgres;

create collation pg_catalog."tzm-x-icu" (
  locale = 'tzm'
);

comment on collation pg_catalog."tzm-x-icu"
is 'Central Atlas Tamazight';

alter collation pg_catalog."tzm-x-icu"
  owner to postgres;

create collation pg_catalog."tzm-MA-x-icu" (
  locale = 'tzm-MA'
);

comment on collation pg_catalog."tzm-MA-x-icu"
is 'Central Atlas Tamazight (Morocco)';

alter collation pg_catalog."tzm-MA-x-icu"
  owner to postgres;

create collation pg_catalog."ug-x-icu" (
  locale = 'ug'
);

comment on collation pg_catalog."ug-x-icu"
is 'Uyghur';

alter collation pg_catalog."ug-x-icu"
  owner to postgres;

create collation pg_catalog."ug-CN-x-icu" (
  locale = 'ug-CN'
);

comment on collation pg_catalog."ug-CN-x-icu"
is 'Uyghur (China)';

alter collation pg_catalog."ug-CN-x-icu"
  owner to postgres;

create collation pg_catalog."uk-x-icu" (
  locale = 'uk'
);

comment on collation pg_catalog."uk-x-icu"
is 'Ukrainian';

alter collation pg_catalog."uk-x-icu"
  owner to postgres;

create collation pg_catalog."uk-UA-x-icu" (
  locale = 'uk-UA'
);

comment on collation pg_catalog."uk-UA-x-icu"
is 'Ukrainian (Ukraine)';

alter collation pg_catalog."uk-UA-x-icu"
  owner to postgres;

create collation pg_catalog."ur-x-icu" (
  locale = 'ur'
);

comment on collation pg_catalog."ur-x-icu"
is 'Urdu';

alter collation pg_catalog."ur-x-icu"
  owner to postgres;

create collation pg_catalog."ur-IN-x-icu" (
  locale = 'ur-IN'
);

comment on collation pg_catalog."ur-IN-x-icu"
is 'Urdu (India)';

alter collation pg_catalog."ur-IN-x-icu"
  owner to postgres;

create collation pg_catalog."ur-PK-x-icu" (
  locale = 'ur-PK'
);

comment on collation pg_catalog."ur-PK-x-icu"
is 'Urdu (Pakistan)';

alter collation pg_catalog."ur-PK-x-icu"
  owner to postgres;

create collation pg_catalog."uz-x-icu" (
  locale = 'uz'
);

comment on collation pg_catalog."uz-x-icu"
is 'Uzbek';

alter collation pg_catalog."uz-x-icu"
  owner to postgres;

create collation pg_catalog."uz-Arab-x-icu" (
  locale = 'uz-Arab'
);

comment on collation pg_catalog."uz-Arab-x-icu"
is 'Uzbek (Arabic)';

alter collation pg_catalog."uz-Arab-x-icu"
  owner to postgres;

create collation pg_catalog."uz-Arab-AF-x-icu" (
  locale = 'uz-Arab-AF'
);

comment on collation pg_catalog."uz-Arab-AF-x-icu"
is 'Uzbek (Arabic, Afghanistan)';

alter collation pg_catalog."uz-Arab-AF-x-icu"
  owner to postgres;

create collation pg_catalog."uz-Cyrl-x-icu" (
  locale = 'uz-Cyrl'
);

comment on collation pg_catalog."uz-Cyrl-x-icu"
is 'Uzbek (Cyrillic)';

alter collation pg_catalog."uz-Cyrl-x-icu"
  owner to postgres;

create collation pg_catalog."uz-Cyrl-UZ-x-icu" (
  locale = 'uz-Cyrl-UZ'
);

comment on collation pg_catalog."uz-Cyrl-UZ-x-icu"
is 'Uzbek (Cyrillic, Uzbekistan)';

alter collation pg_catalog."uz-Cyrl-UZ-x-icu"
  owner to postgres;

create collation pg_catalog."uz-Latn-x-icu" (
  locale = 'uz-Latn'
);

comment on collation pg_catalog."uz-Latn-x-icu"
is 'Uzbek (Latin)';

alter collation pg_catalog."uz-Latn-x-icu"
  owner to postgres;

create collation pg_catalog."uz-Latn-UZ-x-icu" (
  locale = 'uz-Latn-UZ'
);

comment on collation pg_catalog."uz-Latn-UZ-x-icu"
is 'Uzbek (Latin, Uzbekistan)';

alter collation pg_catalog."uz-Latn-UZ-x-icu"
  owner to postgres;

create collation pg_catalog."vai-x-icu" (
  locale = 'vai'
);

comment on collation pg_catalog."vai-x-icu"
is 'Vai';

alter collation pg_catalog."vai-x-icu"
  owner to postgres;

create collation pg_catalog."vai-Latn-x-icu" (
  locale = 'vai-Latn'
);

comment on collation pg_catalog."vai-Latn-x-icu"
is 'Vai (Latin)';

alter collation pg_catalog."vai-Latn-x-icu"
  owner to postgres;

create collation pg_catalog."vai-Latn-LR-x-icu" (
  locale = 'vai-Latn-LR'
);

comment on collation pg_catalog."vai-Latn-LR-x-icu"
is 'Vai (Latin, Liberia)';

alter collation pg_catalog."vai-Latn-LR-x-icu"
  owner to postgres;

create collation pg_catalog."vai-Vaii-x-icu" (
  locale = 'vai-Vaii'
);

comment on collation pg_catalog."vai-Vaii-x-icu"
is 'Vai (Vai)';

alter collation pg_catalog."vai-Vaii-x-icu"
  owner to postgres;

create collation pg_catalog."vai-Vaii-LR-x-icu" (
  locale = 'vai-Vaii-LR'
);

comment on collation pg_catalog."vai-Vaii-LR-x-icu"
is 'Vai (Vai, Liberia)';

alter collation pg_catalog."vai-Vaii-LR-x-icu"
  owner to postgres;

create collation pg_catalog."vi-x-icu" (
  locale = 'vi'
);

comment on collation pg_catalog."vi-x-icu"
is 'Vietnamese';

alter collation pg_catalog."vi-x-icu"
  owner to postgres;

create collation pg_catalog."vi-VN-x-icu" (
  locale = 'vi-VN'
);

comment on collation pg_catalog."vi-VN-x-icu"
is 'Vietnamese (Vietnam)';

alter collation pg_catalog."vi-VN-x-icu"
  owner to postgres;

create collation pg_catalog."vun-x-icu" (
  locale = 'vun'
);

comment on collation pg_catalog."vun-x-icu"
is 'Vunjo';

alter collation pg_catalog."vun-x-icu"
  owner to postgres;

create collation pg_catalog."vun-TZ-x-icu" (
  locale = 'vun-TZ'
);

comment on collation pg_catalog."vun-TZ-x-icu"
is 'Vunjo (Tanzania)';

alter collation pg_catalog."vun-TZ-x-icu"
  owner to postgres;

create collation pg_catalog."wae-x-icu" (
  locale = 'wae'
);

comment on collation pg_catalog."wae-x-icu"
is 'Walser';

alter collation pg_catalog."wae-x-icu"
  owner to postgres;

create collation pg_catalog."wae-CH-x-icu" (
  locale = 'wae-CH'
);

comment on collation pg_catalog."wae-CH-x-icu"
is 'Walser (Switzerland)';

alter collation pg_catalog."wae-CH-x-icu"
  owner to postgres;

create collation pg_catalog."xog-x-icu" (
  locale = 'xog'
);

comment on collation pg_catalog."xog-x-icu"
is 'Soga';

alter collation pg_catalog."xog-x-icu"
  owner to postgres;

create collation pg_catalog."xog-UG-x-icu" (
  locale = 'xog-UG'
);

comment on collation pg_catalog."xog-UG-x-icu"
is 'Soga (Uganda)';

alter collation pg_catalog."xog-UG-x-icu"
  owner to postgres;

create collation pg_catalog."yav-x-icu" (
  locale = 'yav'
);

comment on collation pg_catalog."yav-x-icu"
is 'Yangben';

alter collation pg_catalog."yav-x-icu"
  owner to postgres;

create collation pg_catalog."yav-CM-x-icu" (
  locale = 'yav-CM'
);

comment on collation pg_catalog."yav-CM-x-icu"
is 'Yangben (Cameroon)';

alter collation pg_catalog."yav-CM-x-icu"
  owner to postgres;

create collation pg_catalog."yi-x-icu" (
  locale = 'yi'
);

comment on collation pg_catalog."yi-x-icu"
is 'Yiddish';

alter collation pg_catalog."yi-x-icu"
  owner to postgres;

create collation pg_catalog."yi-001-x-icu" (
  locale = 'yi-001'
);

comment on collation pg_catalog."yi-001-x-icu"
is 'Yiddish (World)';

alter collation pg_catalog."yi-001-x-icu"
  owner to postgres;

create collation pg_catalog."yo-x-icu" (
  locale = 'yo'
);

comment on collation pg_catalog."yo-x-icu"
is 'Yoruba';

alter collation pg_catalog."yo-x-icu"
  owner to postgres;

create collation pg_catalog."yo-BJ-x-icu" (
  locale = 'yo-BJ'
);

comment on collation pg_catalog."yo-BJ-x-icu"
is 'Yoruba (Benin)';

alter collation pg_catalog."yo-BJ-x-icu"
  owner to postgres;

create collation pg_catalog."yo-NG-x-icu" (
  locale = 'yo-NG'
);

comment on collation pg_catalog."yo-NG-x-icu"
is 'Yoruba (Nigeria)';

alter collation pg_catalog."yo-NG-x-icu"
  owner to postgres;

create collation pg_catalog."yue-x-icu" (
  locale = 'yue'
);

comment on collation pg_catalog."yue-x-icu"
is 'Cantonese';

alter collation pg_catalog."yue-x-icu"
  owner to postgres;

create collation pg_catalog."yue-HK-x-icu" (
  locale = 'yue-HK'
);

comment on collation pg_catalog."yue-HK-x-icu"
is 'Cantonese (Hong Kong SAR China)';

alter collation pg_catalog."yue-HK-x-icu"
  owner to postgres;

create collation pg_catalog."zgh-x-icu" (
  locale = 'zgh'
);

comment on collation pg_catalog."zgh-x-icu"
is 'Standard Moroccan Tamazight';

alter collation pg_catalog."zgh-x-icu"
  owner to postgres;

create collation pg_catalog."zgh-MA-x-icu" (
  locale = 'zgh-MA'
);

comment on collation pg_catalog."zgh-MA-x-icu"
is 'Standard Moroccan Tamazight (Morocco)';

alter collation pg_catalog."zgh-MA-x-icu"
  owner to postgres;

create collation pg_catalog."zh-x-icu" (
  locale = 'zh'
);

comment on collation pg_catalog."zh-x-icu"
is 'Chinese';

alter collation pg_catalog."zh-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hans-x-icu" (
  locale = 'zh-Hans'
);

comment on collation pg_catalog."zh-Hans-x-icu"
is 'Chinese (Simplified)';

alter collation pg_catalog."zh-Hans-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hans-CN-x-icu" (
  locale = 'zh-Hans-CN'
);

comment on collation pg_catalog."zh-Hans-CN-x-icu"
is 'Chinese (Simplified, China)';

alter collation pg_catalog."zh-Hans-CN-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hans-HK-x-icu" (
  locale = 'zh-Hans-HK'
);

comment on collation pg_catalog."zh-Hans-HK-x-icu"
is 'Chinese (Simplified, Hong Kong SAR China)';

alter collation pg_catalog."zh-Hans-HK-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hans-MO-x-icu" (
  locale = 'zh-Hans-MO'
);

comment on collation pg_catalog."zh-Hans-MO-x-icu"
is 'Chinese (Simplified, Macau SAR China)';

alter collation pg_catalog."zh-Hans-MO-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hans-SG-x-icu" (
  locale = 'zh-Hans-SG'
);

comment on collation pg_catalog."zh-Hans-SG-x-icu"
is 'Chinese (Simplified, Singapore)';

alter collation pg_catalog."zh-Hans-SG-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hant-x-icu" (
  locale = 'zh-Hant'
);

comment on collation pg_catalog."zh-Hant-x-icu"
is 'Chinese (Traditional)';

alter collation pg_catalog."zh-Hant-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hant-HK-x-icu" (
  locale = 'zh-Hant-HK'
);

comment on collation pg_catalog."zh-Hant-HK-x-icu"
is 'Chinese (Traditional, Hong Kong SAR China)';

alter collation pg_catalog."zh-Hant-HK-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hant-MO-x-icu" (
  locale = 'zh-Hant-MO'
);

comment on collation pg_catalog."zh-Hant-MO-x-icu"
is 'Chinese (Traditional, Macau SAR China)';

alter collation pg_catalog."zh-Hant-MO-x-icu"
  owner to postgres;

create collation pg_catalog."zh-Hant-TW-x-icu" (
  locale = 'zh-Hant-TW'
);

comment on collation pg_catalog."zh-Hant-TW-x-icu"
is 'Chinese (Traditional, Taiwan)';

alter collation pg_catalog."zh-Hant-TW-x-icu"
  owner to postgres;

create collation pg_catalog."zu-x-icu" (
  locale = 'zu'
);

comment on collation pg_catalog."zu-x-icu"
is 'Zulu';

alter collation pg_catalog."zu-x-icu"
  owner to postgres;

create collation pg_catalog."zu-ZA-x-icu" (
  locale = 'zu-ZA'
);

comment on collation pg_catalog."zu-ZA-x-icu"
is 'Zulu (South Africa)';

alter collation pg_catalog."zu-ZA-x-icu"
  owner to postgres;

create aggregate pg_catalog.max(anyarray) (
  sfunc = pg_catalog.array_larger,
  stype = anyarray,
  combinefunc = pg_catalog.array_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(anyarray)
is 'maximum value of all anyarray input values';

alter aggregate pg_catalog.max(anyarray)
  owner to postgres;

create aggregate pg_catalog.min(anyarray) (
  sfunc = pg_catalog.array_smaller,
  stype = anyarray,
  combinefunc = pg_catalog.array_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(anyarray)
is 'minimum value of all anyarray input values';

alter aggregate pg_catalog.min(anyarray)
  owner to postgres;

create aggregate pg_catalog.avg(bigint) (
  sfunc = pg_catalog.int8_avg_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_avg,
  combinefunc = pg_catalog.int8_avg_combine,
  serialfunc = pg_catalog.int8_avg_serialize,
  deserialfunc = pg_catalog.int8_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_avg_accum,
  minvfunc = pg_catalog.int8_avg_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_avg
);

comment on aggregate pg_catalog.avg(bigint)
is 'the average (arithmetic mean) as numeric of all bigint values';

alter aggregate pg_catalog.avg(bigint)
  owner to postgres;

create aggregate pg_catalog.avg(integer) (
  sfunc = pg_catalog.int4_avg_accum,
  stype = bigint [],
  finalfunc = pg_catalog.int8_avg,
  combinefunc = pg_catalog.int4_avg_combine,
  initcond = '{0,0}',
  parallel = safe,
  msfunc = pg_catalog.int4_avg_accum,
  minvfunc = pg_catalog.int4_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int8_avg,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.avg(integer)
is 'the average (arithmetic mean) as numeric of all integer values';

alter aggregate pg_catalog.avg(integer)
  owner to postgres;

create aggregate pg_catalog.avg(smallint) (
  sfunc = pg_catalog.int2_avg_accum,
  stype = bigint [],
  finalfunc = pg_catalog.int8_avg,
  combinefunc = pg_catalog.int4_avg_combine,
  initcond = '{0,0}',
  parallel = safe,
  msfunc = pg_catalog.int2_avg_accum,
  minvfunc = pg_catalog.int2_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int8_avg,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.avg(smallint)
is 'the average (arithmetic mean) as numeric of all smallint values';

alter aggregate pg_catalog.avg(smallint)
  owner to postgres;

create aggregate pg_catalog.avg(numeric) (
  sfunc = pg_catalog.numeric_avg_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_avg,
  combinefunc = pg_catalog.numeric_avg_combine,
  serialfunc = pg_catalog.numeric_avg_serialize,
  deserialfunc = pg_catalog.numeric_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_avg_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_avg
);

comment on aggregate pg_catalog.avg(numeric)
is 'the average (arithmetic mean) as numeric of all numeric values';

alter aggregate pg_catalog.avg(numeric)
  owner to postgres;

create aggregate pg_catalog.avg(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_avg,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.avg(real)
is 'the average (arithmetic mean) as float8 of all float4 values';

alter aggregate pg_catalog.avg(real)
  owner to postgres;

create aggregate pg_catalog.avg(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_avg,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.avg(double precision)
is 'the average (arithmetic mean) as float8 of all float8 values';

alter aggregate pg_catalog.avg(double precision)
  owner to postgres;

create aggregate pg_catalog.avg(interval) (
  sfunc = pg_catalog.interval_accum,
  stype = interval [],
  finalfunc = pg_catalog.interval_avg,
  combinefunc = pg_catalog.interval_combine,
  initcond = '{0 second,0 second}',
  parallel = safe,
  msfunc = pg_catalog.interval_accum,
  minvfunc = pg_catalog.interval_accum_inv,
  mstype = interval [],
  mfinalfunc = pg_catalog.interval_avg,
  minitcond = '{0 second,0 second}'
);

comment on aggregate pg_catalog.avg(interval)
is 'the average (arithmetic mean) as interval of all interval values';

alter aggregate pg_catalog.avg(interval)
  owner to postgres;

create aggregate pg_catalog.sum(bigint) (
  sfunc = pg_catalog.int8_avg_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_sum,
  combinefunc = pg_catalog.int8_avg_combine,
  serialfunc = pg_catalog.int8_avg_serialize,
  deserialfunc = pg_catalog.int8_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_avg_accum,
  minvfunc = pg_catalog.int8_avg_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_sum
);

comment on aggregate pg_catalog.sum(bigint)
is 'sum as numeric across all bigint input values';

alter aggregate pg_catalog.sum(bigint)
  owner to postgres;

create aggregate pg_catalog.sum(integer) (
  sfunc = pg_catalog.int4_sum,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  parallel = safe,
  msfunc = pg_catalog.int4_avg_accum,
  minvfunc = pg_catalog.int4_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int2int4_sum,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.sum(integer)
is 'sum as bigint across all integer input values';

alter aggregate pg_catalog.sum(integer)
  owner to postgres;

create aggregate pg_catalog.sum(smallint) (
  sfunc = pg_catalog.int2_sum,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  parallel = safe,
  msfunc = pg_catalog.int2_avg_accum,
  minvfunc = pg_catalog.int2_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int2int4_sum,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.sum(smallint)
is 'sum as bigint across all smallint input values';

alter aggregate pg_catalog.sum(smallint)
  owner to postgres;

create aggregate pg_catalog.sum(real) (
  sfunc = pg_catalog.float4pl,
  stype = real,
  combinefunc = pg_catalog.float4pl,
  parallel = safe
);

comment on aggregate pg_catalog.sum(real)
is 'sum as float4 across all float4 input values';

alter aggregate pg_catalog.sum(real)
  owner to postgres;

create aggregate pg_catalog.sum(double precision) (
  sfunc = pg_catalog.float8pl,
  stype = double precision,
  combinefunc = pg_catalog.float8pl,
  parallel = safe
);

comment on aggregate pg_catalog.sum(double precision)
is 'sum as float8 across all float8 input values';

alter aggregate pg_catalog.sum(double precision)
  owner to postgres;

create aggregate pg_catalog.sum(money) (
  sfunc = pg_catalog.cash_pl,
  stype = money,
  combinefunc = pg_catalog.cash_pl,
  parallel = safe,
  msfunc = pg_catalog.cash_pl,
  minvfunc = pg_catalog.cash_mi,
  mstype = money
);

comment on aggregate pg_catalog.sum(money)
is 'sum as money across all money input values';

alter aggregate pg_catalog.sum(money)
  owner to postgres;

create aggregate pg_catalog.sum(interval) (
  sfunc = pg_catalog.interval_pl,
  stype = interval,
  combinefunc = pg_catalog.interval_pl,
  parallel = safe,
  msfunc = pg_catalog.interval_pl,
  minvfunc = pg_catalog.interval_mi,
  mstype = interval
);

comment on aggregate pg_catalog.sum(interval)
is 'sum as interval across all interval input values';

alter aggregate pg_catalog.sum(interval)
  owner to postgres;

create aggregate pg_catalog.sum(numeric) (
  sfunc = pg_catalog.numeric_avg_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_sum,
  combinefunc = pg_catalog.numeric_avg_combine,
  serialfunc = pg_catalog.numeric_avg_serialize,
  deserialfunc = pg_catalog.numeric_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_avg_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_sum
);

comment on aggregate pg_catalog.sum(numeric)
is 'sum as numeric across all numeric input values';

alter aggregate pg_catalog.sum(numeric)
  owner to postgres;

create aggregate pg_catalog.max(bigint) (
  sfunc = pg_catalog.int8larger,
  stype = bigint,
  combinefunc = pg_catalog.int8larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(bigint)
is 'maximum value of all bigint input values';

alter aggregate pg_catalog.max(bigint)
  owner to postgres;

create aggregate pg_catalog.max(integer) (
  sfunc = pg_catalog.int4larger,
  stype = integer,
  combinefunc = pg_catalog.int4larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(integer)
is 'maximum value of all integer input values';

alter aggregate pg_catalog.max(integer)
  owner to postgres;

create aggregate pg_catalog.max(smallint) (
  sfunc = pg_catalog.int2larger,
  stype = smallint,
  combinefunc = pg_catalog.int2larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(smallint)
is 'maximum value of all smallint input values';

alter aggregate pg_catalog.max(smallint)
  owner to postgres;

create aggregate pg_catalog.max(oid) (
  sfunc = pg_catalog.oidlarger,
  stype = oid,
  combinefunc = pg_catalog.oidlarger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(oid)
is 'maximum value of all oid input values';

alter aggregate pg_catalog.max(oid)
  owner to postgres;

create aggregate pg_catalog.max(real) (
  sfunc = pg_catalog.float4larger,
  stype = real,
  combinefunc = pg_catalog.float4larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(real)
is 'maximum value of all float4 input values';

alter aggregate pg_catalog.max(real)
  owner to postgres;

create aggregate pg_catalog.max(double precision) (
  sfunc = pg_catalog.float8larger,
  stype = double precision,
  combinefunc = pg_catalog.float8larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(double precision)
is 'maximum value of all float8 input values';

alter aggregate pg_catalog.max(double precision)
  owner to postgres;

create aggregate pg_catalog.max(abstime) (
  sfunc = pg_catalog.int4larger,
  stype = abstime,
  combinefunc = pg_catalog.int4larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(abstime)
is 'maximum value of all abstime input values';

alter aggregate pg_catalog.max(abstime)
  owner to postgres;

create aggregate pg_catalog.max(date) (
  sfunc = pg_catalog.date_larger,
  stype = date,
  combinefunc = pg_catalog.date_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(date)
is 'maximum value of all date input values';

alter aggregate pg_catalog.max(date)
  owner to postgres;

create aggregate pg_catalog.max(time) (
  sfunc = pg_catalog.time_larger,
  stype = time,
  combinefunc = pg_catalog.time_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(time)
is 'maximum value of all time input values';

alter aggregate pg_catalog.max(time)
  owner to postgres;

create aggregate pg_catalog.max(time with time zone) (
  sfunc = pg_catalog.timetz_larger,
  stype = time with time zone,
  combinefunc = pg_catalog.timetz_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(time with time zone)
is 'maximum value of all time with time zone input values';

alter aggregate pg_catalog.max(time with time zone)
  owner to postgres;

create aggregate pg_catalog.max(money) (
  sfunc = pg_catalog.cashlarger,
  stype = money,
  combinefunc = pg_catalog.cashlarger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(money)
is 'maximum value of all money input values';

alter aggregate pg_catalog.max(money)
  owner to postgres;

create aggregate pg_catalog.max(timestamp) (
  sfunc = pg_catalog.timestamp_larger,
  stype = timestamp,
  combinefunc = pg_catalog.timestamp_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(timestamp)
is 'maximum value of all timestamp input values';

alter aggregate pg_catalog.max(timestamp)
  owner to postgres;

create aggregate pg_catalog.max(timestamp with time zone) (
  sfunc = pg_catalog.timestamptz_larger,
  stype = timestamp with time zone,
  combinefunc = pg_catalog.timestamptz_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(timestamp with time zone)
is 'maximum value of all timestamp with time zone input values';

alter aggregate pg_catalog.max(timestamp with time zone)
  owner to postgres;

create aggregate pg_catalog.max(interval) (
  sfunc = pg_catalog.interval_larger,
  stype = interval,
  combinefunc = pg_catalog.interval_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(interval)
is 'maximum value of all interval input values';

alter aggregate pg_catalog.max(interval)
  owner to postgres;

create aggregate pg_catalog.max(text) (
  sfunc = pg_catalog.text_larger,
  stype = text,
  combinefunc = pg_catalog.text_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(text)
is 'maximum value of all text input values';

alter aggregate pg_catalog.max(text)
  owner to postgres;

create aggregate pg_catalog.max(numeric) (
  sfunc = pg_catalog.numeric_larger,
  stype = numeric,
  combinefunc = pg_catalog.numeric_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(numeric)
is 'maximum value of all numeric input values';

alter aggregate pg_catalog.max(numeric)
  owner to postgres;

create aggregate pg_catalog.min(bigint) (
  sfunc = pg_catalog.int8smaller,
  stype = bigint,
  combinefunc = pg_catalog.int8smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(bigint)
is 'minimum value of all bigint input values';

alter aggregate pg_catalog.min(bigint)
  owner to postgres;

create aggregate pg_catalog.min(integer) (
  sfunc = pg_catalog.int4smaller,
  stype = integer,
  combinefunc = pg_catalog.int4smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(integer)
is 'minimum value of all integer input values';

alter aggregate pg_catalog.min(integer)
  owner to postgres;

create aggregate pg_catalog.min(smallint) (
  sfunc = pg_catalog.int2smaller,
  stype = smallint,
  combinefunc = pg_catalog.int2smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(smallint)
is 'minimum value of all smallint input values';

alter aggregate pg_catalog.min(smallint)
  owner to postgres;

create aggregate pg_catalog.min(oid) (
  sfunc = pg_catalog.oidsmaller,
  stype = oid,
  combinefunc = pg_catalog.oidsmaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(oid)
is 'minimum value of all oid input values';

alter aggregate pg_catalog.min(oid)
  owner to postgres;

create aggregate pg_catalog.min(real) (
  sfunc = pg_catalog.float4smaller,
  stype = real,
  combinefunc = pg_catalog.float4smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(real)
is 'minimum value of all float4 input values';

alter aggregate pg_catalog.min(real)
  owner to postgres;

create aggregate pg_catalog.min(double precision) (
  sfunc = pg_catalog.float8smaller,
  stype = double precision,
  combinefunc = pg_catalog.float8smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(double precision)
is 'minimum value of all float8 input values';

alter aggregate pg_catalog.min(double precision)
  owner to postgres;

create aggregate pg_catalog.min(abstime) (
  sfunc = pg_catalog.int4smaller,
  stype = abstime,
  combinefunc = pg_catalog.int4smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(abstime)
is 'minimum value of all abstime input values';

alter aggregate pg_catalog.min(abstime)
  owner to postgres;

create aggregate pg_catalog.min(date) (
  sfunc = pg_catalog.date_smaller,
  stype = date,
  combinefunc = pg_catalog.date_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(date)
is 'minimum value of all date input values';

alter aggregate pg_catalog.min(date)
  owner to postgres;

create aggregate pg_catalog.min(time) (
  sfunc = pg_catalog.time_smaller,
  stype = time,
  combinefunc = pg_catalog.time_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(time)
is 'minimum value of all time input values';

alter aggregate pg_catalog.min(time)
  owner to postgres;

create aggregate pg_catalog.min(time with time zone) (
  sfunc = pg_catalog.timetz_smaller,
  stype = time with time zone,
  combinefunc = pg_catalog.timetz_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(time with time zone)
is 'minimum value of all time with time zone input values';

alter aggregate pg_catalog.min(time with time zone)
  owner to postgres;

create aggregate pg_catalog.min(money) (
  sfunc = pg_catalog.cashsmaller,
  stype = money,
  combinefunc = pg_catalog.cashsmaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(money)
is 'minimum value of all money input values';

alter aggregate pg_catalog.min(money)
  owner to postgres;

create aggregate pg_catalog.min(timestamp) (
  sfunc = pg_catalog.timestamp_smaller,
  stype = timestamp,
  combinefunc = pg_catalog.timestamp_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(timestamp)
is 'minimum value of all timestamp input values';

alter aggregate pg_catalog.min(timestamp)
  owner to postgres;

create aggregate pg_catalog.min(timestamp with time zone) (
  sfunc = pg_catalog.timestamptz_smaller,
  stype = timestamp with time zone,
  combinefunc = pg_catalog.timestamptz_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(timestamp with time zone)
is 'minimum value of all timestamp with time zone input values';

alter aggregate pg_catalog.min(timestamp with time zone)
  owner to postgres;

create aggregate pg_catalog.min(interval) (
  sfunc = pg_catalog.interval_smaller,
  stype = interval,
  combinefunc = pg_catalog.interval_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(interval)
is 'minimum value of all interval input values';

alter aggregate pg_catalog.min(interval)
  owner to postgres;

create aggregate pg_catalog.min(text) (
  sfunc = pg_catalog.text_smaller,
  stype = text,
  combinefunc = pg_catalog.text_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(text)
is 'minimum value of all text values';

alter aggregate pg_catalog.min(text)
  owner to postgres;

create aggregate pg_catalog.min(numeric) (
  sfunc = pg_catalog.numeric_smaller,
  stype = numeric,
  combinefunc = pg_catalog.numeric_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(numeric)
is 'minimum value of all numeric input values';

alter aggregate pg_catalog.min(numeric)
  owner to postgres;

create aggregate pg_catalog.count("any") (
  sfunc = pg_catalog.int8inc_any,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  initcond = '0',
  parallel = safe,
  msfunc = pg_catalog.int8inc_any,
  minvfunc = pg_catalog.int8dec_any,
  mstype = bigint,
  minitcond = '0'
);

comment on aggregate pg_catalog.count("any")
is 'number of input rows for which the input expression is not null';

alter aggregate pg_catalog.count("any")
  owner to postgres;

create aggregate pg_catalog.variance(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.variance(bigint)
is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(bigint)
  owner to postgres;

create aggregate pg_catalog.variance(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(integer)
is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(integer)
  owner to postgres;

create aggregate pg_catalog.variance(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(smallint)
is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(smallint)
  owner to postgres;

create aggregate pg_catalog.variance(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.variance(real)
is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(real)
  owner to postgres;

create aggregate pg_catalog.variance(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.variance(double precision)
is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(double precision)
  owner to postgres;

create aggregate pg_catalog.variance(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.variance(numeric)
is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(numeric)
  owner to postgres;

create aggregate pg_catalog.stddev(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(bigint)
is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(bigint)
  owner to postgres;

create aggregate pg_catalog.stddev(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(integer)
is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(integer)
  owner to postgres;

create aggregate pg_catalog.stddev(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(smallint)
is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(smallint)
  owner to postgres;

create aggregate pg_catalog.stddev(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev(real)
is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(real)
  owner to postgres;

create aggregate pg_catalog.stddev(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev(double precision)
is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(double precision)
  owner to postgres;

create aggregate pg_catalog.stddev(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(numeric)
is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(numeric)
  owner to postgres;

create aggregate pg_catalog.bit_and(smallint) (
  sfunc = pg_catalog.int2and,
  stype = smallint,
  combinefunc = pg_catalog.int2and,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(smallint)
is 'bitwise-and smallint aggregate';

alter aggregate pg_catalog.bit_and(smallint)
  owner to postgres;

create aggregate pg_catalog.bit_or(smallint) (
  sfunc = pg_catalog.int2or,
  stype = smallint,
  combinefunc = pg_catalog.int2or,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(smallint)
is 'bitwise-or smallint aggregate';

alter aggregate pg_catalog.bit_or(smallint)
  owner to postgres;

create aggregate pg_catalog.bit_and(integer) (
  sfunc = pg_catalog.int4and,
  stype = integer,
  combinefunc = pg_catalog.int4and,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(integer)
is 'bitwise-and integer aggregate';

alter aggregate pg_catalog.bit_and(integer)
  owner to postgres;

create aggregate pg_catalog.bit_or(integer) (
  sfunc = pg_catalog.int4or,
  stype = integer,
  combinefunc = pg_catalog.int4or,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(integer)
is 'bitwise-or integer aggregate';

alter aggregate pg_catalog.bit_or(integer)
  owner to postgres;

create aggregate pg_catalog.bit_and(bigint) (
  sfunc = pg_catalog.int8and,
  stype = bigint,
  combinefunc = pg_catalog.int8and,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(bigint)
is 'bitwise-and bigint aggregate';

alter aggregate pg_catalog.bit_and(bigint)
  owner to postgres;

create aggregate pg_catalog.bit_or(bigint) (
  sfunc = pg_catalog.int8or,
  stype = bigint,
  combinefunc = pg_catalog.int8or,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(bigint)
is 'bitwise-or bigint aggregate';

alter aggregate pg_catalog.bit_or(bigint)
  owner to postgres;

create aggregate pg_catalog.bit_and(bit) (
  sfunc = pg_catalog.bitand,
  stype = bit,
  combinefunc = pg_catalog.bitand,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(bit)
is 'bitwise-and bit aggregate';

alter aggregate pg_catalog.bit_and(bit)
  owner to postgres;

create aggregate pg_catalog.bit_or(bit) (
  sfunc = pg_catalog.bitor,
  stype = bit,
  combinefunc = pg_catalog.bitor,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(bit)
is 'bitwise-or bit aggregate';

alter aggregate pg_catalog.bit_or(bit)
  owner to postgres;

create aggregate pg_catalog.max(char) (
  sfunc = pg_catalog.bpchar_larger,
  stype = char,
  combinefunc = pg_catalog.bpchar_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(char)
is 'maximum value of all bpchar input values';

alter aggregate pg_catalog.max(char)
  owner to postgres;

create aggregate pg_catalog.min(char) (
  sfunc = pg_catalog.bpchar_smaller,
  stype = char,
  combinefunc = pg_catalog.bpchar_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(char)
is 'minimum value of all bpchar input values';

alter aggregate pg_catalog.min(char)
  owner to postgres;

create aggregate pg_catalog.array_agg(anynonarray) (
  sfunc = pg_catalog.array_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.array_agg_finalfn,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.array_agg(anynonarray)
is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anynonarray)
  owner to postgres;

create aggregate pg_catalog.bool_and(boolean) (
  sfunc = pg_catalog.booland_statefunc,
  stype = boolean,
  combinefunc = pg_catalog.booland_statefunc,
  parallel = safe,
  msfunc = pg_catalog.bool_accum,
  minvfunc = pg_catalog.bool_accum_inv,
  mstype = internal,
  msspace = 16,
  mfinalfunc = pg_catalog.bool_alltrue,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.bool_and(boolean)
is 'boolean-and aggregate';

alter aggregate pg_catalog.bool_and(boolean)
  owner to postgres;

create aggregate pg_catalog.bool_or(boolean) (
  sfunc = pg_catalog.boolor_statefunc,
  stype = boolean,
  combinefunc = pg_catalog.boolor_statefunc,
  parallel = safe,
  msfunc = pg_catalog.bool_accum,
  minvfunc = pg_catalog.bool_accum_inv,
  mstype = internal,
  msspace = 16,
  mfinalfunc = pg_catalog.bool_anytrue,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.bool_or(boolean)
is 'boolean-or aggregate';

alter aggregate pg_catalog.bool_or(boolean)
  owner to postgres;

create aggregate pg_catalog.every(boolean) (
  sfunc = pg_catalog.booland_statefunc,
  stype = boolean,
  combinefunc = pg_catalog.booland_statefunc,
  parallel = safe,
  msfunc = pg_catalog.bool_accum,
  minvfunc = pg_catalog.bool_accum_inv,
  mstype = internal,
  msspace = 16,
  mfinalfunc = pg_catalog.bool_alltrue,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.every(boolean)
is 'boolean-and aggregate';

alter aggregate pg_catalog.every(boolean)
  owner to postgres;

create aggregate pg_catalog.var_samp(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(bigint)
is 'sample variance of bigint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(bigint)
  owner to postgres;

create aggregate pg_catalog.var_samp(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(integer)
is 'sample variance of integer input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(integer)
  owner to postgres;

create aggregate pg_catalog.var_samp(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(smallint)
is 'sample variance of smallint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(smallint)
  owner to postgres;

create aggregate pg_catalog.var_samp(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_samp(real)
is 'sample variance of float4 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(real)
  owner to postgres;

create aggregate pg_catalog.var_samp(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_samp(double precision)
is 'sample variance of float8 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(double precision)
  owner to postgres;

create aggregate pg_catalog.var_samp(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(numeric)
is 'sample variance of numeric input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(numeric)
  owner to postgres;

create aggregate pg_catalog.stddev_samp(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(bigint)
is 'sample standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_samp(bigint)
  owner to postgres;

create aggregate pg_catalog.stddev_samp(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(integer)
is 'sample standard deviation of integer input values';

alter aggregate pg_catalog.stddev_samp(integer)
  owner to postgres;

create aggregate pg_catalog.stddev_samp(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(smallint)
is 'sample standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_samp(smallint)
  owner to postgres;

create aggregate pg_catalog.stddev_samp(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_samp(real)
is 'sample standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_samp(real)
  owner to postgres;

create aggregate pg_catalog.stddev_samp(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_samp(double precision)
is 'sample standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_samp(double precision)
  owner to postgres;

create aggregate pg_catalog.stddev_samp(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(numeric)
is 'sample standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_samp(numeric)
  owner to postgres;

create aggregate pg_catalog.var_pop(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(bigint)
is 'population variance of bigint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(bigint)
  owner to postgres;

create aggregate pg_catalog.var_pop(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(integer)
is 'population variance of integer input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(integer)
  owner to postgres;

create aggregate pg_catalog.var_pop(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(smallint)
is 'population variance of smallint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(smallint)
  owner to postgres;

create aggregate pg_catalog.var_pop(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_pop(real)
is 'population variance of float4 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(real)
  owner to postgres;

create aggregate pg_catalog.var_pop(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_pop(double precision)
is 'population variance of float8 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(double precision)
  owner to postgres;

create aggregate pg_catalog.var_pop(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(numeric)
is 'population variance of numeric input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(numeric)
  owner to postgres;

create aggregate pg_catalog.stddev_pop(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(bigint)
is 'population standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_pop(bigint)
  owner to postgres;

create aggregate pg_catalog.stddev_pop(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(integer)
is 'population standard deviation of integer input values';

alter aggregate pg_catalog.stddev_pop(integer)
  owner to postgres;

create aggregate pg_catalog.stddev_pop(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(smallint)
is 'population standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_pop(smallint)
  owner to postgres;

create aggregate pg_catalog.stddev_pop(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_pop(real)
is 'population standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_pop(real)
  owner to postgres;

create aggregate pg_catalog.stddev_pop(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_pop(double precision)
is 'population standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_pop(double precision)
  owner to postgres;

create aggregate pg_catalog.stddev_pop(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(numeric)
is 'population standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_pop(numeric)
  owner to postgres;

create aggregate pg_catalog.max(tid) (
  sfunc = pg_catalog.tidlarger,
  stype = tid,
  combinefunc = pg_catalog.tidlarger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(tid)
is 'maximum value of all tid input values';

alter aggregate pg_catalog.max(tid)
  owner to postgres;

create aggregate pg_catalog.min(tid) (
  sfunc = pg_catalog.tidsmaller,
  stype = tid,
  combinefunc = pg_catalog.tidsmaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(tid)
is 'minimum value of all tid input values';

alter aggregate pg_catalog.min(tid)
  owner to postgres;

create aggregate pg_catalog.count() (
  sfunc = pg_catalog.int8inc,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  initcond = '0',
  parallel = safe,
  msfunc = pg_catalog.int8inc,
  minvfunc = pg_catalog.int8dec,
  mstype = bigint,
  minitcond = '0'
);

comment on aggregate pg_catalog.count()
is 'number of input rows';

alter aggregate pg_catalog.count()
  owner to postgres;

create aggregate pg_catalog.regr_count(double precision, double precision) (
  sfunc = pg_catalog.int8inc_float8_float8,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  initcond = '0',
  parallel = safe
);

comment on aggregate pg_catalog.regr_count(double precision, double precision)
is 'number of input rows in which both expressions are not null';

alter aggregate pg_catalog.regr_count(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_sxx(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_sxx,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_sxx(double precision, double precision)
is 'sum of squares of the independent variable (sum(X^2) - sum(X)^2/N)';

alter aggregate pg_catalog.regr_sxx(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_syy(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_syy,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_syy(double precision, double precision)
is 'sum of squares of the dependent variable (sum(Y^2) - sum(Y)^2/N)';

alter aggregate pg_catalog.regr_syy(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_sxy(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_sxy,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_sxy(double precision, double precision)
is 'sum of products of independent times dependent variable (sum(X*Y) - sum(X) * sum(Y)/N)';

alter aggregate pg_catalog.regr_sxy(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_avgx(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_avgx,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_avgx(double precision, double precision)
is 'average of the independent variable (sum(X)/N)';

alter aggregate pg_catalog.regr_avgx(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_avgy(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_avgy,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_avgy(double precision, double precision)
is 'average of the dependent variable (sum(Y)/N)';

alter aggregate pg_catalog.regr_avgy(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_r2(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_r2,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_r2(double precision, double precision)
is 'square of the correlation coefficient';

alter aggregate pg_catalog.regr_r2(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_slope(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_slope,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_slope(double precision, double precision)
is 'slope of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_slope(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.regr_intercept(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_intercept,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_intercept(double precision, double precision)
is 'y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_intercept(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.covar_pop(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_covar_pop,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.covar_pop(double precision, double precision)
is 'population covariance';

alter aggregate pg_catalog.covar_pop(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.covar_samp(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_covar_samp,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.covar_samp(double precision, double precision)
is 'sample covariance';

alter aggregate pg_catalog.covar_samp(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.corr(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_corr,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.corr(double precision, double precision)
is 'correlation coefficient';

alter aggregate pg_catalog.corr(double precision, double precision)
  owner to postgres;

create aggregate pg_catalog.xmlagg(xml) (
  sfunc = pg_catalog.xmlconcat2,
  stype = xml,
  parallel = safe
);

comment on aggregate pg_catalog.xmlagg(xml)
is 'concatenate XML values';

alter aggregate pg_catalog.xmlagg(xml)
  owner to postgres;

create aggregate pg_catalog.json_agg(anyelement) (
  sfunc = pg_catalog.json_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.json_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.json_agg(anyelement)
is 'aggregate input into json';

alter aggregate pg_catalog.json_agg(anyelement)
  owner to postgres;

create aggregate pg_catalog.json_object_agg("any", "any") (
  sfunc = pg_catalog.json_object_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.json_object_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.json_object_agg("any", "any")
is 'aggregate input into a json object';

alter aggregate pg_catalog.json_object_agg("any", "any")
  owner to postgres;

create aggregate pg_catalog.jsonb_agg(anyelement) (
  sfunc = pg_catalog.jsonb_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.jsonb_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.jsonb_agg(anyelement)
is 'aggregate input into jsonb';

alter aggregate pg_catalog.jsonb_agg(anyelement)
  owner to postgres;

create aggregate pg_catalog.jsonb_object_agg("any", "any") (
  sfunc = pg_catalog.jsonb_object_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.jsonb_object_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.jsonb_object_agg("any", "any")
is 'aggregate inputs into jsonb object';

alter aggregate pg_catalog.jsonb_object_agg("any", "any")
  owner to postgres;

create aggregate pg_catalog.max(anyenum) (
  sfunc = pg_catalog.enum_larger,
  stype = anyenum,
  combinefunc = pg_catalog.enum_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(anyenum)
is 'maximum value of all enum input values';

alter aggregate pg_catalog.max(anyenum)
  owner to postgres;

create aggregate pg_catalog.min(anyenum) (
  sfunc = pg_catalog.enum_smaller,
  stype = anyenum,
  combinefunc = pg_catalog.enum_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(anyenum)
is 'minimum value of all enum input values';

alter aggregate pg_catalog.min(anyenum)
  owner to postgres;

create aggregate pg_catalog.string_agg(text, text) (
  sfunc = pg_catalog.string_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.string_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.string_agg(text, text)
is 'concatenate aggregate input into a string';

alter aggregate pg_catalog.string_agg(text, text)
  owner to postgres;

create aggregate pg_catalog.string_agg(bytea, bytea) (
  sfunc = pg_catalog.bytea_string_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.bytea_string_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.string_agg(bytea, bytea)
is 'concatenate aggregate input into a bytea';

alter aggregate pg_catalog.string_agg(bytea, bytea)
  owner to postgres;

create aggregate pg_catalog.max(inet) (
  sfunc = pg_catalog.network_larger,
  stype = inet,
  combinefunc = pg_catalog.network_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(inet)
is 'maximum value of all inet input values';

alter aggregate pg_catalog.max(inet)
  owner to postgres;

create aggregate pg_catalog.min(inet) (
  sfunc = pg_catalog.network_smaller,
  stype = inet,
  combinefunc = pg_catalog.network_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(inet)
is 'minimum value of all inet input values';

alter aggregate pg_catalog.min(inet)
  owner to postgres;

create aggregate pg_catalog.percentile_disc(double precision order by anyelement) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_disc_final,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_disc(double precision, anyelement)
is 'discrete percentile';

alter aggregate pg_catalog.percentile_disc(double precision order by anyelement)
  owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision order by double precision) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_float8_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision, double precision)
is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont(double precision order by double precision)
  owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision order by interval) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_interval_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision, interval)
is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont(double precision order by interval)
  owner to postgres;

create aggregate pg_catalog.percentile_disc(double precision [] order by anyelement) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_disc_multi_final,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_disc(double precision [], anyelement)
is 'multiple discrete percentiles';

alter aggregate pg_catalog.percentile_disc(double precision [] order by anyelement)
  owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision [] order by double precision) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_float8_multi_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision [], double precision)
is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont(double precision [] order by double precision)
  owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision [] order by interval) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_interval_multi_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision [], interval)
is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont(double precision [] order by interval)
  owner to postgres;

create aggregate pg_catalog.mode(order by anyelement) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.mode_final,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.mode(anyelement)
is 'most common value';

alter aggregate pg_catalog.mode(order by anyelement)
  owner to postgres;

create aggregate pg_catalog.rank("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.rank_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.rank("any")
is 'rank of hypothetical row';

alter aggregate pg_catalog.rank("any")
  owner to postgres;

create aggregate pg_catalog.percent_rank("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.percent_rank_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.percent_rank("any")
is 'fractional rank of hypothetical row';

alter aggregate pg_catalog.percent_rank("any")
  owner to postgres;

create aggregate pg_catalog.cume_dist("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.cume_dist_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.cume_dist("any")
is 'cumulative distribution of hypothetical row';

alter aggregate pg_catalog.cume_dist("any")
  owner to postgres;

create aggregate pg_catalog.dense_rank("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.dense_rank_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.dense_rank("any")
is 'rank of hypothetical row without gaps';

alter aggregate pg_catalog.dense_rank("any")
  owner to postgres;

create aggregate pg_catalog.array_agg(anyarray) (
  sfunc = pg_catalog.array_agg_array_transfn,
  stype = internal,
  finalfunc = pg_catalog.array_agg_array_finalfn,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.array_agg(anyarray)
is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anyarray)
  owner to postgres;


